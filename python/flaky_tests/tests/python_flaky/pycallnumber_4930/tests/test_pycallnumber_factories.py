# Automatically generated by Pynguin.
import pytest
import pycallnumber.factories as module_0
import pycallnumber.exceptions as module_1

def test_case_0():
    dict_0 = {}
    var_0 = module_0.cnrange(dict_0, dict_0, useropts=dict_0, unittypes=dict_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pycallnumber.set.RangeSet'
    assert f'{type(var_0.start).__module__}.{type(var_0.start).__qualname__}' == 'pycallnumber.utils.Infinity'
    assert f'{type(var_0.end).__module__}.{type(var_0.end).__qualname__}' == 'pycallnumber.utils.Infinity'

@pytest.mark.xfail(strict=True)
def test_case_1():
    none_type_0 = None
    module_0.callnumber(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    str_0 = '64Gg'
    var_0 = module_0.callnumber(str_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pycallnumber.units.callnumbers.local.Local'
    assert f'{type(var_0.options).__module__}.{type(var_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(var_0.options) == 7
    assert var_0.definition == 'a local call number with a non-specific structure'
    assert var_0.is_separator is False
    assert var_0.display_case == ''
    assert var_0.search_case == 'lower'
    assert var_0.sort_case == 'lower'
    assert var_0.use_formatting_in_search is False
    assert var_0.use_formatting_in_sort is False
    assert var_0.name == ''
    assert var_0.part_names == ['parts']
    assert var_0.has_part_names is True
    assert f'{type(var_0.parts).__module__}.{type(var_0.parts).__qualname__}' == 'pycallnumber.unit.MultiUnitWrapper'
    assert len(var_0.parts) == 2
    bool_0 = True
    bool_1 = True
    module_0.cnrange(bool_0, bool_0, str_0, bool_1)

@pytest.mark.xfail(strict=True)
def test_case_3():
    int_0 = 2327
    module_0.cnrange(int_0, int_0, useropts=int_0, rangesettype=int_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    bytes_0 = b'\xea\xb8\xeaD\xcf\xae\xd0N`\x1doJp=k[\xb44\xa3'
    module_0.cnrange(bytes_0, bytes_0, rangesettype=bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    bytes_0 = b'\x8b'
    module_0.cnset(bytes_0)

def test_case_6():
    dict_0 = {}
    var_0 = module_0.cnset(dict_0, unittypes=dict_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pycallnumber.set.RangeSet'
    assert var_0.start is None
    assert var_0.end is None
    assert var_0.unittype is None

@pytest.mark.xfail(strict=True)
def test_case_7():
    str_0 = 'U`c,\tW|C8df+H-'
    module_0.cnset(str_0, useropts=str_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = 'L\teUo5FR\\1+umW'
    module_0.cnset(str_0, unittypes=str_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    bytes_0 = b'\xb2\xb8\xa7\x9d\xb7z\x03 \xc5\xb6\xe5z\x0fU'
    none_type_0 = None
    module_0.cnset(bytes_0, useropts=none_type_0, rangesettype=bytes_0)

def test_case_10():
    str_0 = 'L\teUo5FR\\1+umW'
    with pytest.raises(module_1.SettingsError):
        module_0.cnset(str_0, str_0, unittypes=str_0)

def test_case_11():
    str_0 = ''
    with pytest.raises(module_1.InvalidCallNumberStringError):
        module_0.callnumber(str_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    str_0 = 'g'
    var_0 = module_0.callnumber(str_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pycallnumber.units.callnumbers.local.Local'
    assert f'{type(var_0.options).__module__}.{type(var_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(var_0.options) == 7
    assert var_0.definition == 'a local call number with a non-specific structure'
    assert var_0.is_separator is False
    assert var_0.display_case == ''
    assert var_0.search_case == 'lower'
    assert var_0.sort_case == 'lower'
    assert var_0.use_formatting_in_search is False
    assert var_0.use_formatting_in_sort is False
    assert var_0.name == ''
    assert var_0.part_names == ['parts']
    assert var_0.has_part_names is True
    assert f'{type(var_0.parts).__module__}.{type(var_0.parts).__qualname__}' == 'pycallnumber.unit.MultiUnitWrapper'
    assert len(var_0.parts) == 1
    bool_0 = False
    bool_1 = True
    var_1 = module_0.cnrange(bool_0, bool_0, str_0, bool_1)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'pycallnumber.set.RangeSet'
    assert f'{type(var_1.start).__module__}.{type(var_1.start).__qualname__}' == 'pycallnumber.utils.Infinity'
    assert f'{type(var_1.end).__module__}.{type(var_1.end).__qualname__}' == 'pycallnumber.utils.Infinity'
    module_0.cnrange(bool_0, var_1, unittypes=str_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    float_0 = -1352.20731
    module_0.cnrange(float_0, float_0, endname=float_0, unittypes=float_0)

@pytest.mark.xfail(strict=True)
def test_case_14():
    bool_0 = False
    list_0 = [bool_0]
    dict_0 = {}
    settings_error_0 = module_1.SettingsError(*list_0, **dict_0)
    dict_1 = {settings_error_0: bool_0, bool_0: bool_0, bool_0: list_0}
    module_0.cnset(dict_1, dict_0)

@pytest.mark.xfail(strict=True)
def test_case_15():
    none_type_0 = None
    bool_0 = False
    dict_0 = {none_type_0: none_type_0, none_type_0: bool_0, none_type_0: bool_0}
    str_0 = 'q\n'
    module_0.cnrange(dict_0, str_0, none_type_0, rangesettype=none_type_0)