# Automatically generated by Pynguin.
import pytest
import pycallnumber.units.numbers as module_0
import inspect as module_1
import ast as module_2

@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    module_0.BaseCompoundNumber(none_type_0)

def test_case_1():
    str_0 = '9999999'
    number_0 = module_0.Number(str_0)
    assert f'{type(number_0).__module__}.{type(number_0).__qualname__}' == 'pycallnumber.units.numbers.Number'
    assert f'{type(number_0.options).__module__}.{type(number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(number_0.options) == 7
    assert number_0.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert number_0.is_separator is False
    assert number_0.display_case == ''
    assert number_0.search_case == 'lower'
    assert number_0.sort_case == 'lower'
    assert number_0.use_formatting_in_search is False
    assert number_0.use_formatting_in_sort is False
    assert number_0.name == 'default'
    assert number_0.part_names == ['wholenumber', 'sep0', 'decimal']
    assert number_0.has_part_names is True
    assert f'{type(number_0.wholenumber).__module__}.{type(number_0.wholenumber).__qualname__}' == 'pycallnumber.units.simple.Numeric'
    assert number_0.sep0 is None
    assert number_0.decimal is None
    assert module_0.Number.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert module_0.Number.min_val == 0
    assert module_0.Number.max_val == pytest.approx(10000000000.0, abs=0.01, rel=0.01)
    assert module_0.Number.min_interval == pytest.approx(1e-09, abs=0.01, rel=0.01)
    assert module_0.Number.is_whole_number is False
    assert module_0.Number.min_decimal_places == 0
    assert module_0.Number.max_decimal_places == 9
    assert f'{type(module_0.Number.string_to_value).__module__}.{type(module_0.Number.string_to_value).__qualname__}' == 'builtins.method'

@pytest.mark.xfail(strict=True)
def test_case_2():
    str_0 = ',C3lxDAp'
    module_0.OrdinalNumber(str_0, str_0)

def test_case_3():
    str_0 = '9999999'
    number_0 = module_0.Number(str_0)
    assert f'{type(number_0).__module__}.{type(number_0).__qualname__}' == 'pycallnumber.units.numbers.Number'
    assert f'{type(number_0.options).__module__}.{type(number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(number_0.options) == 7
    assert number_0.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert number_0.is_separator is False
    assert number_0.display_case == ''
    assert number_0.search_case == 'lower'
    assert number_0.sort_case == 'lower'
    assert number_0.use_formatting_in_search is False
    assert number_0.use_formatting_in_sort is False
    assert number_0.name == 'default'
    assert number_0.part_names == ['wholenumber', 'sep0', 'decimal']
    assert number_0.has_part_names is True
    assert f'{type(number_0.wholenumber).__module__}.{type(number_0.wholenumber).__qualname__}' == 'pycallnumber.units.simple.Numeric'
    assert number_0.sep0 is None
    assert number_0.decimal is None
    assert module_0.Number.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert module_0.Number.min_val == 0
    assert module_0.Number.max_val == pytest.approx(10000000000.0, abs=0.01, rel=0.01)
    assert module_0.Number.min_interval == pytest.approx(1e-09, abs=0.01, rel=0.01)
    assert module_0.Number.is_whole_number is False
    assert module_0.Number.min_decimal_places == 0
    assert module_0.Number.max_decimal_places == 9
    assert f'{type(module_0.Number.string_to_value).__module__}.{type(module_0.Number.string_to_value).__qualname__}' == 'builtins.method'
    ordinal_number_0 = number_0.__ne__(str_0)

def test_case_4():
    str_0 = '9.99'
    number_0 = module_0.Number(str_0)
    assert f'{type(number_0).__module__}.{type(number_0).__qualname__}' == 'pycallnumber.units.numbers.Number'
    assert f'{type(number_0.options).__module__}.{type(number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(number_0.options) == 7
    assert number_0.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert number_0.is_separator is False
    assert number_0.display_case == ''
    assert number_0.search_case == 'lower'
    assert number_0.sort_case == 'lower'
    assert number_0.use_formatting_in_search is False
    assert number_0.use_formatting_in_sort is False
    assert number_0.name == 'default'
    assert number_0.part_names == ['wholenumber', 'decimal']
    assert number_0.has_part_names is True
    assert f'{type(number_0.wholenumber).__module__}.{type(number_0.wholenumber).__qualname__}' == 'pycallnumber.units.simple.Numeric'
    assert f'{type(number_0.decimal).__module__}.{type(number_0.decimal).__qualname__}' == 'pycallnumber.units.simple.Decimal'
    assert module_0.Number.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert module_0.Number.min_val == 0
    assert module_0.Number.max_val == pytest.approx(10000000000.0, abs=0.01, rel=0.01)
    assert module_0.Number.min_interval == pytest.approx(1e-09, abs=0.01, rel=0.01)
    assert module_0.Number.is_whole_number is False
    assert module_0.Number.min_decimal_places == 0
    assert module_0.Number.max_decimal_places == 9
    assert f'{type(module_0.Number.string_to_value).__module__}.{type(module_0.Number.string_to_value).__qualname__}' == 'builtins.method'

def test_case_5():
    str_0 = '9.99'
    number_0 = module_0.Number(str_0)
    assert f'{type(number_0).__module__}.{type(number_0).__qualname__}' == 'pycallnumber.units.numbers.Number'
    assert f'{type(number_0.options).__module__}.{type(number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(number_0.options) == 7
    assert number_0.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert number_0.is_separator is False
    assert number_0.display_case == ''
    assert number_0.search_case == 'lower'
    assert number_0.sort_case == 'lower'
    assert number_0.use_formatting_in_search is False
    assert number_0.use_formatting_in_sort is False
    assert number_0.name == 'default'
    assert number_0.part_names == ['wholenumber', 'decimal']
    assert number_0.has_part_names is True
    assert f'{type(number_0.wholenumber).__module__}.{type(number_0.wholenumber).__qualname__}' == 'pycallnumber.units.simple.Numeric'
    assert f'{type(number_0.decimal).__module__}.{type(number_0.decimal).__qualname__}' == 'pycallnumber.units.simple.Decimal'
    assert module_0.Number.definition == 'a non-negative integer or floating point number, formatted based on US or British conventions: a period is used as a decimal point, if needed, and commas may be used as thousands separators (but are optional)'
    assert module_0.Number.min_val == 0
    assert module_0.Number.max_val == pytest.approx(10000000000.0, abs=0.01, rel=0.01)
    assert module_0.Number.min_interval == pytest.approx(1e-09, abs=0.01, rel=0.01)
    assert module_0.Number.is_whole_number is False
    assert module_0.Number.min_decimal_places == 0
    assert module_0.Number.max_decimal_places == 9
    assert f'{type(module_0.Number.string_to_value).__module__}.{type(module_0.Number.string_to_value).__qualname__}' == 'builtins.method'
    var_0 = number_0.__eq__(str_0)

@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = '9.99'
    base_compound_number_0 = module_0.BaseCompoundNumber(str_0, str_0)
    assert f'{type(base_compound_number_0).__module__}.{type(base_compound_number_0).__qualname__}' == 'pycallnumber.units.numbers.BaseCompoundNumber'
    assert f'{type(base_compound_number_0.options).__module__}.{type(base_compound_number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(base_compound_number_0.options) == 7
    assert base_compound_number_0.definition is None
    assert base_compound_number_0.is_separator is False
    assert base_compound_number_0.display_case == ''
    assert base_compound_number_0.search_case == 'lower'
    assert base_compound_number_0.sort_case == 'lower'
    assert base_compound_number_0.use_formatting_in_search is False
    assert base_compound_number_0.use_formatting_in_sort is False
    assert base_compound_number_0.name == '9.99'
    assert base_compound_number_0.part_names == ['parts']
    assert base_compound_number_0.has_part_names is True
    assert f'{type(base_compound_number_0.parts).__module__}.{type(base_compound_number_0.parts).__qualname__}' == 'pycallnumber.unit.MultiUnitWrapper'
    assert len(base_compound_number_0.parts) == 3
    assert module_0.BaseCompoundNumber.min_val == 0
    assert module_0.BaseCompoundNumber.max_val == 9999999999
    assert module_0.BaseCompoundNumber.min_interval == 1
    assert module_0.BaseCompoundNumber.min_decimal_places == 0
    assert module_0.BaseCompoundNumber.max_decimal_places == 0
    assert f'{type(module_0.BaseCompoundNumber.validate).__module__}.{type(module_0.BaseCompoundNumber.validate).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.string_to_value).__module__}.{type(module_0.BaseCompoundNumber.string_to_value).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.create_decimal).__module__}.{type(module_0.BaseCompoundNumber.create_decimal).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.describe_short).__module__}.{type(module_0.BaseCompoundNumber.describe_short).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.describe_long).__module__}.{type(module_0.BaseCompoundNumber.describe_long).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.value).__module__}.{type(module_0.BaseCompoundNumber.value).__qualname__}' == 'builtins.property'
    module_1.getmembers(base_compound_number_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    str_0 = '99999E99'
    module_0.Number(str_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = '9.5'
    base_compound_number_0 = module_0.BaseCompoundNumber(str_0)
    assert f'{type(base_compound_number_0).__module__}.{type(base_compound_number_0).__qualname__}' == 'pycallnumber.units.numbers.BaseCompoundNumber'
    assert f'{type(base_compound_number_0.options).__module__}.{type(base_compound_number_0.options).__qualname__}' == 'pycallnumber.options.Options'
    assert len(base_compound_number_0.options) == 7
    assert base_compound_number_0.definition is None
    assert base_compound_number_0.is_separator is False
    assert base_compound_number_0.display_case == ''
    assert base_compound_number_0.search_case == 'lower'
    assert base_compound_number_0.sort_case == 'lower'
    assert base_compound_number_0.use_formatting_in_search is False
    assert base_compound_number_0.use_formatting_in_sort is False
    assert base_compound_number_0.name == 'default'
    assert base_compound_number_0.part_names == ['parts']
    assert base_compound_number_0.has_part_names is True
    assert f'{type(base_compound_number_0.parts).__module__}.{type(base_compound_number_0.parts).__qualname__}' == 'pycallnumber.unit.MultiUnitWrapper'
    assert len(base_compound_number_0.parts) == 3
    assert module_0.BaseCompoundNumber.min_val == 0
    assert module_0.BaseCompoundNumber.max_val == 9999999999
    assert module_0.BaseCompoundNumber.min_interval == 1
    assert module_0.BaseCompoundNumber.min_decimal_places == 0
    assert module_0.BaseCompoundNumber.max_decimal_places == 0
    assert f'{type(module_0.BaseCompoundNumber.validate).__module__}.{type(module_0.BaseCompoundNumber.validate).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.string_to_value).__module__}.{type(module_0.BaseCompoundNumber.string_to_value).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.create_decimal).__module__}.{type(module_0.BaseCompoundNumber.create_decimal).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.describe_short).__module__}.{type(module_0.BaseCompoundNumber.describe_short).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.describe_long).__module__}.{type(module_0.BaseCompoundNumber.describe_long).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.BaseCompoundNumber.value).__module__}.{type(module_0.BaseCompoundNumber.value).__qualname__}' == 'builtins.property'
    var_0 = base_compound_number_0.apply_options_to_self()
    var_1 = base_compound_number_0.describe_long()
    assert var_1 == 'The ``BaseCompoundNumber`` Unit type uses the following template.\n\nA CompoundTemplate with grouping ``parts``.\n\nThe ``parts`` grouping should contain 1 or more of the following Units:\n\n    Alphabetic -- a string with 1 or more letters\n\n    Numeric -- a string with 1 or more digits that has a value of 0 to 9999999999\n\n    Formatting -- a string with 1 or more non-alphanumeric symbols\n\nGroupings can be separated by optional whitespace.. It has an overall value of 0 to 9999999999'
    var_2 = module_2.Store()
    var_2.__and__(base_compound_number_0)