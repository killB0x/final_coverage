# Automatically generated by Pynguin.
import pytest
import live_trace.main as module_0

def test_case_0():
    argument_parser_0 = module_0.ArgumentParser()
    assert f'{type(argument_parser_0).__module__}.{type(argument_parser_0).__qualname__}' == 'live_trace.main.ArgumentParser'
    assert argument_parser_0.description == 'Read stacktraces log which where created by live_trace. Logs are searched in /root/tmp/live_trace. By default a new file is created for every day. If unsure, use sum-last-frame without other arguments to see the summary of today\'s output.\n\nlive_trace: A "daemon" thread monitors the process and writes out stracktraces of every N (float) seconds. This command line tool helps to see where the interpreter spent the most time.\n\nEvery stacktrace has several frames (call stack). In most cases you want to see "sum-last-frame" ("last" means "deepest" frames: that\'s where the interpreter was interrupted by the monitor thread). A simple regex tries to mark our code (vs python/django code) with <====.'
    assert argument_parser_0.argument_default is None
    assert argument_parser_0.prefix_chars == '-'
    assert argument_parser_0.conflict_handler == 'error'
    assert argument_parser_0.usage is None
    assert argument_parser_0.epilog is None
    assert argument_parser_0.fromfile_prefix_chars is None
    assert argument_parser_0.add_help is True
    assert argument_parser_0.allow_abbrev is True
    assert argument_parser_0.exit_on_error is True

def test_case_1():
    str_0 = '&.bEw'
    with pytest.raises(ValueError):
        module_0.get_command_from_path(str_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    namespace_0 = module_0.Namespace()
    bool_0 = True
    module_0.live_trace_is_running__now_run_code_which_should_get_traced(bool_0, bool_0, bool_0)

def test_case_3():
    var_0 = module_0.start_idempotent()

def test_case_4():
    float_0 = 2400.0
    var_0 = module_0.start_idempotent(outfile_template=float_0)
    module_0.analyze(var_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    str_0 = 'Tb=w'
    module_0.pre_execfile(str_0)

def test_case_6():
    argument_parser_0 = module_0.ArgumentParser()
    assert f'{type(argument_parser_0).__module__}.{type(argument_parser_0).__qualname__}' == 'live_trace.main.ArgumentParser'
    assert argument_parser_0.description == 'Read stacktraces log which where created by live_trace. Logs are searched in /root/tmp/live_trace. By default a new file is created for every day. If unsure, use sum-last-frame without other arguments to see the summary of today\'s output.\n\nlive_trace: A "daemon" thread monitors the process and writes out stracktraces of every N (float) seconds. This command line tool helps to see where the interpreter spent the most time.\n\nEvery stacktrace has several frames (call stack). In most cases you want to see "sum-last-frame" ("last" means "deepest" frames: that\'s where the interpreter was interrupted by the monitor thread). A simple regex tries to mark our code (vs python/django code) with <====.'
    assert argument_parser_0.argument_default is None
    assert argument_parser_0.prefix_chars == '-'
    assert argument_parser_0.conflict_handler == 'error'
    assert argument_parser_0.usage is None
    assert argument_parser_0.epilog is None
    assert argument_parser_0.fromfile_prefix_chars is None
    assert argument_parser_0.add_help is True
    assert argument_parser_0.allow_abbrev is True
    assert argument_parser_0.exit_on_error is True
    set_0 = {argument_parser_0, argument_parser_0}
    module_0.run(set_0)

def test_case_7():
    argument_parser_0 = module_0.ArgumentParser()
    assert f'{type(argument_parser_0).__module__}.{type(argument_parser_0).__qualname__}' == 'live_trace.main.ArgumentParser'
    assert argument_parser_0.description == 'Read stacktraces log which where created by live_trace. Logs are searched in /root/tmp/live_trace. By default a new file is created for every day. If unsure, use sum-last-frame without other arguments to see the summary of today\'s output.\n\nlive_trace: A "daemon" thread monitors the process and writes out stracktraces of every N (float) seconds. This command line tool helps to see where the interpreter spent the most time.\n\nEvery stacktrace has several frames (call stack). In most cases you want to see "sum-last-frame" ("last" means "deepest" frames: that\'s where the interpreter was interrupted by the monitor thread). A simple regex tries to mark our code (vs python/django code) with <====.'
    assert argument_parser_0.argument_default is None
    assert argument_parser_0.prefix_chars == '-'
    assert argument_parser_0.conflict_handler == 'error'
    assert argument_parser_0.usage is None
    assert argument_parser_0.epilog is None
    assert argument_parser_0.fromfile_prefix_chars is None
    assert argument_parser_0.add_help is True
    assert argument_parser_0.allow_abbrev is True
    assert argument_parser_0.exit_on_error is True
    tuple_0 = ()
    var_0 = module_0.start_idempotent()
    module_0.analyze_from_fd(tuple_0, tuple_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    int_0 = 1118
    module_0.version(int_0)

def test_case_9():
    var_0 = module_0.start_idempotent()
    argument_parser_0 = module_0.ArgumentParser()
    var_1 = module_0.stop()
    var_2 = argument_parser_0.parse_args()
    var_3 = var_2.parse_args()

@pytest.mark.xfail(strict=True)
def test_case_10():
    module_0.start()

def test_case_11():
    tuple_0 = module_0.stop()

def test_case_12():
    str_0 = ''
    var_0 = module_0.get_command_from_path(str_0)
    assert var_0 == '/usr/local/bin/'
    var_0.error(var_0)

def test_case_13():
    var_0 = module_0.ArgumentParser()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'live_trace.main.ArgumentParser'
    assert var_0.description == 'Read stacktraces log which where created by live_trace. Logs are searched in /root/tmp/live_trace. By default a new file is created for every day. If unsure, use sum-last-frame without other arguments to see the summary of today\'s output.\n\nlive_trace: A "daemon" thread monitors the process and writes out stracktraces of every N (float) seconds. This command line tool helps to see where the interpreter spent the most time.\n\nEvery stacktrace has several frames (call stack). In most cases you want to see "sum-last-frame" ("last" means "deepest" frames: that\'s where the interpreter was interrupted by the monitor thread). A simple regex tries to mark our code (vs python/django code) with <====.'
    assert var_0.argument_default is None
    assert var_0.prefix_chars == '-'
    assert var_0.conflict_handler == 'error'
    assert var_0.usage is None
    assert var_0.epilog is None
    assert var_0.fromfile_prefix_chars is None
    assert var_0.add_help is True
    assert var_0.allow_abbrev is True
    assert var_0.exit_on_error is True
    str_0 = '/'
    argument_parser_0 = module_0.ArgumentParser()
    var_1 = module_0.pre_execfile(str_0)
    var_1.error(var_1)