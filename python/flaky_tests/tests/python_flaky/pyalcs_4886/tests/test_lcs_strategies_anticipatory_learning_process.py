# Automatically generated by Pynguin.
import pytest
import lcs.strategies.anticipatory_learning_process as module_0

def test_case_0():
    list_0 = []
    none_type_0 = module_0.add_classifier(list_0, list_0, list_0, list_0)

@pytest.mark.xfail(strict=True)
def test_case_1():
    list_0 = []
    none_type_0 = module_0.add_classifier(list_0, list_0, list_0, list_0)
    module_0.add_classifier(list_0, list_0, list_0, list_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    tuple_0 = ()
    bool_0 = False
    str_0 = 'eCMtH\\O\\@.tS'
    module_0.add_classifier(tuple_0, tuple_0, str_0, bool_0)

@pytest.mark.xfail(strict=True)
def test_case_3():
    list_0 = []
    str_0 = '\n        Specializes the effect part where necessary to correctly anticipate\n        the changes from p0 to p1 and returns a condition which specifies\n        the attributes which must be specified in the condition part.\n        The specific attributes in the returned conditions are set to\n        the necessary values.\n\n        For real-valued representation a random noise might be added to both\n        `p0` and `p1` (see `Configuration`, `cover_noise` parameter).\n\n        Parameters\n        ----------\n        p0: Perception\n            previous raw perception obtained from environment\n        p1: Perception\n            current raw perception obtained from environment\n        leave_specialized: bool\n            Requires the effect attribute to be a wildcard to specialize it.\n            By default false\n        '
    list_1 = [list_0, list_0, str_0, list_0]
    int_0 = 17
    module_0.add_classifier(list_0, list_0, list_1, int_0)