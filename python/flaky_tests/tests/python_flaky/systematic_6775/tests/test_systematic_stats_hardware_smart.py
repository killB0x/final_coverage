# Automatically generated by Pynguin.
import pytest
import systematic.stats.hardware.smart as module_0
import re as module_1
import codecs as module_2

def test_case_0():
    smart_ctl_config_0 = module_0.SmartCtlConfig()
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')

def test_case_1():
    smart_ctl_config_0 = module_0.SmartCtlConfig()
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    with pytest.raises(module_0.SmartError):
        smart_ctl_config_0.load(smart_ctl_config_0)

def test_case_2():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'

@pytest.mark.xfail(strict=True)
def test_case_3():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_ctl_client_0.to_json()

@pytest.mark.xfail(strict=True)
def test_case_4():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_ctl_client_0.as_dict()

@pytest.mark.xfail(strict=True)
def test_case_5():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_info_field_0 = module_0.SmartInfoField(smart_ctl_client_0, smart_ctl_client_0, smart_ctl_client_0)
    var_0 = smart_ctl_client_0.find_drive(smart_ctl_client_0)
    smart_ctl_client_0.to_json(smart_info_field_0)

def test_case_6():
    str_0 = '}PJ-{m"#\x0bM^^~__Hww'
    smart_ctl_config_0 = module_0.SmartCtlConfig(str_0)
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')

def test_case_7():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(smart_ctl_client_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = '}PJ-{m"#\x0bM^^~__Hww'
    smart_attribute_0 = module_0.SmartAttribute(str_0, str_0, str_0)
    assert f'{type(smart_attribute_0).__module__}.{type(smart_attribute_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartAttribute'
    assert len(smart_attribute_0) == 0
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(smart_ctl_client_0)
    smart_info_field_0 = module_0.SmartInfoField(str_0, dict_0, str_0)
    smart_ctl_client_0.as_dict(dict_0)

def test_case_9():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.is_ignored(smart_ctl_client_0)
    assert var_0 is False

@pytest.mark.xfail(strict=True)
def test_case_10():
    str_0 = '}PJ-{m"#\x0bM^^~__Hww'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_info_field_0 = module_0.SmartInfoField(smart_ctl_client_0, str_0, smart_ctl_client_0)
    var_0 = smart_info_field_0.__repr__()
    assert var_0 == 'smart stats'
    smart_ctl_client_0.as_dict(smart_info_field_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_ctl_client_0.scan()

def test_case_12():
    smart_ctl_config_0 = module_0.SmartCtlConfig()
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    var_0 = smart_ctl_config_0.get_driver(smart_ctl_config_0)

def test_case_13():
    str_0 = '}PJ-{m"#\x0bM^^~__Hww'
    smart_ctl_config_0 = module_0.SmartCtlConfig(str_0)
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    var_0 = smart_ctl_config_0.load(str_0)

def test_case_14():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.update_timestamp()
    var_1 = smart_ctl_client_0.as_dict()

@pytest.mark.xfail(strict=True)
def test_case_15():
    str_0 = '}PJ-{m"#\x0bM^^~__Hww'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_info_field_0 = module_0.SmartInfoField(smart_ctl_client_0, str_0, smart_ctl_client_0)
    var_0 = smart_ctl_client_0.is_ignored(dict_0)
    assert var_0 is False
    smart_info_field_1 = module_0.SmartInfoField(smart_info_field_0, smart_info_field_0, dict_0)
    smart_ctl_config_0 = module_0.SmartCtlConfig(var_0)
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    var_0.find_drive(var_0)

@pytest.mark.xfail(strict=True)
def test_case_16():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(smart_ctl_client_0)
    smart_ctl_config_0 = module_0.SmartCtlConfig(smart_ctl_client_0, var_0)
    assert f'{type(smart_ctl_config_0).__module__}.{type(smart_ctl_config_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert smart_ctl_config_0.drivers == {}
    smart_ctl_client_0.as_dict(var_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    str_0 = '}PJ-{m"#]M^~YHMw'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.is_ignored(str_0)
    assert var_0 is False
    smart_attribute_0 = module_0.SmartAttribute(smart_ctl_client_0, var_0, smart_ctl_client_0, **dict_0)
    assert f'{type(smart_attribute_0).__module__}.{type(smart_attribute_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartAttribute'
    assert len(smart_attribute_0) == 1
    smart_attribute_0.__repr__()

def test_case_18():
    str_0 = 'No search terms given'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'No search terms given'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'No search terms given'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_overview()

@pytest.mark.xfail(strict=True)
def test_case_19():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == '1n'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == '1n'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.__ne__(smart_ctl_client_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_1 = smart_drive_0.__repr__()
    smart_ctl_client_0.as_dict(dict_0)

def test_case_21():
    str_0 = 'y#DlKA30L'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'y#DlKA30L'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'y#DlKA30L'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    with pytest.raises(module_0.SmartError):
        smart_drive_0.as_dict()

@pytest.mark.xfail(strict=True)
def test_case_22():
    str_0 = 'No search terms given'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'No search terms given'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'No search terms given'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.set_attribute_autosave(str_0)

@pytest.mark.xfail(strict=True)
def test_case_23():
    str_0 = "y#DlF-\x0c'A30L"
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == "y#DlF-\x0c'A30L"
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == "y#DlF-\x0c'A30L"
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.set_offline_testing(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_24():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    var_1 = smart_ctl_client_0.is_ignored(str_0)
    assert var_1 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_ctl_client_0.execute(smart_drive_0)

@pytest.mark.xfail(strict=True)
def test_case_25():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_ctl_client_1 = module_0.SmartCtlClient()
    assert smart_ctl_client_1.drives == []
    assert f'{type(smart_ctl_client_1.config).__module__}.{type(smart_ctl_client_1.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    str_0 = 'zorW'
    dict_0 = {str_0: str_0}
    smart_ctl_client_2 = module_0.SmartCtlClient(**dict_0)
    assert smart_ctl_client_2.drives == []
    assert f'{type(smart_ctl_client_2.config).__module__}.{type(smart_ctl_client_2.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    smart_ctl_config_0 = module_0.SmartCtlConfig(load_system_config=smart_ctl_client_2)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_2, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'zorW'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'zorW'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_attributes()
    smart_ctl_config_1 = module_0.SmartCtlConfig()
    var_1 = smart_ctl_client_1.update_timestamp()
    var_2 = smart_drive_0.get_overview()
    var_3 = smart_ctl_client_2.is_ignored(str_0)
    assert var_3 is False
    smart_drive_0.set_attribute_autosave(var_2)

@pytest.mark.xfail(strict=True)
def test_case_26():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    var_1 = smart_ctl_client_0.is_ignored(str_0)
    assert var_1 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_2 = smart_drive_0.get_overview()
    smart_drive_0.__le__(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_27():
    str_0 = '>'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.is_ignored(str_0)
    assert var_0 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == '>'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == '>'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_1 = smart_drive_0.get_overview()
    var_2 = smart_ctl_client_0.__repr__()
    assert var_2 == 'smart stats'
    var_3 = smart_drive_0.__lt__(smart_drive_0)
    assert var_3 is False
    var_2.to_json()

@pytest.mark.xfail(strict=True)
def test_case_28():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    var_1 = smart_ctl_client_0.is_ignored(str_0)
    assert var_1 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.__eq__(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_29():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    str_0 = 'zmo9e'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'zmo9e'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'zmo9e'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_attributes()
    var_1 = smart_drive_0.__re_line_matches__(smart_drive_0, var_0)
    smart_drive_0.__re_line_matches__(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_30():
    str_0 = 'No search terms given'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'No search terms given'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'No search terms given'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_overview()
    smart_drive_0.__ge__(smart_ctl_client_0)

@pytest.mark.xfail(strict=True)
def test_case_31():
    var_0 = module_1.purge()
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    int_0 = 2617
    var_1 = smart_ctl_client_0.find_drive(int_0)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_2 = smart_drive_0.__ne__(str_0)
    assert var_2 is False
    smart_ctl_client_0.to_json()

@pytest.mark.xfail(strict=True)
def test_case_32():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_1 = smart_drive_0.get_overview()
    var_2 = var_1.__repr__()
    smart_drive_0.set_offline_testing(var_0)

@pytest.mark.xfail(strict=True)
def test_case_33():
    str_0 = 'Nni'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0, smart_ctl_client_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'Nni'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'Nni'
    assert f'{type(smart_drive_0.flags).__module__}.{type(smart_drive_0.flags).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.set_smart_status(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    str_0 = '1n'
    dict_0 = {}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.set_smart_status(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    str_0 = 'l'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    stream_reader_0 = module_2.StreamReader(smart_ctl_client_0)
    var_0 = smart_ctl_client_0.is_ignored(str_0)
    assert var_0 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'l'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'l'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_1 = smart_drive_0.get_overview()
    var_2 = smart_drive_0.__le__(str_0)
    assert var_2 is True
    var_3 = stream_reader_0.__le__(dict_0)
    smart_drive_0.set_offline_testing(stream_reader_0)

def test_case_36():
    str_0 = 'Nni'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0, smart_ctl_client_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'Nni'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'Nni'
    assert f'{type(smart_drive_0.flags).__module__}.{type(smart_drive_0.flags).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_overview()

def test_case_37():
    str_0 = 'Nni'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0, smart_ctl_client_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'Nni'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'Nni'
    assert f'{type(smart_drive_0.flags).__module__}.{type(smart_drive_0.flags).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.get_attributes()

def test_case_38():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.is_ignored(str_0)
    assert var_0 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == '1n'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == '1n'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_1 = smart_drive_0.get_overview()
    var_2 = smart_drive_0.__ge__(str_0)
    assert var_2 is True
    with pytest.raises(module_0.SmartError):
        smart_drive_0.as_dict(var_0)

@pytest.mark.xfail(strict=True)
def test_case_39():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    var_0 = smart_ctl_client_0.find_drive(dict_0)
    var_1 = smart_ctl_client_0.is_ignored(str_0)
    assert var_1 is False
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_2 = smart_drive_0.get_overview()
    var_3 = var_0.__repr__()
    var_4 = smart_drive_0.__gt__(var_3)
    assert var_4 is False
    var_2.get_attributes()

@pytest.mark.xfail(strict=True)
def test_case_40():
    str_0 = 'Nni'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'Nni'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'Nni'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_ctl_client_0.__repr__()
    assert var_0 == 'smart stats'
    smart_drive_0.__gt__(smart_ctl_client_0)

@pytest.mark.xfail(strict=True)
def test_case_41():
    str_0 = 'Nn'
    dict_0 = {str_0: str_0}
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'Nn'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'Nn'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    var_0 = smart_drive_0.__lt__(str_0)
    assert var_0 is False
    smart_ctl_client_0.to_json()

@pytest.mark.xfail(strict=True)
def test_case_42():
    str_0 = '1n'
    dict_0 = {str_0: str_0}
    smart_attribute_0 = module_0.SmartAttribute(dict_0, str_0, dict_0)
    assert f'{type(smart_attribute_0).__module__}.{type(smart_attribute_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartAttribute'
    assert len(smart_attribute_0) == 0
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    smart_ctl_client_0 = module_0.SmartCtlClient(**dict_0)
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SmartCtlClient.parser_name == 'smart'
    smart_ctl_client_0.execute(smart_attribute_0)

@pytest.mark.xfail(strict=True)
def test_case_43():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    str_0 = 'zmore'
    var_0 = smart_ctl_client_0.execute(str_0)
    smart_ctl_config_0 = module_0.SmartCtlConfig(load_system_config=var_0)
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_0, str_0)
    assert f'{type(smart_drive_0).__module__}.{type(smart_drive_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartDrive'
    assert f'{type(smart_drive_0.client).__module__}.{type(smart_drive_0.client).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_drive_0.device == 'zmore'
    assert smart_drive_0.driver is None
    assert smart_drive_0.name == 'zmore'
    assert smart_drive_0.flags == []
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_ctl_config_1 = module_0.SmartCtlConfig()
    var_1 = smart_ctl_config_1.load(var_0)
    var_2 = var_0.__iter__()
    smart_drive_0.__re_line_matches__(var_1, var_1)

@pytest.mark.xfail(strict=True)
def test_case_44():
    smart_ctl_client_0 = module_0.SmartCtlClient()
    assert f'{type(smart_ctl_client_0).__module__}.{type(smart_ctl_client_0).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlClient'
    assert smart_ctl_client_0.drives == []
    assert f'{type(smart_ctl_client_0.config).__module__}.{type(smart_ctl_client_0.config).__qualname__}' == 'systematic.stats.hardware.smart.SmartCtlConfig'
    assert module_0.SYSTEM_CONFIG_PATHS == ('/etc/systematic/smartdevices.conf', '/usr/local/etc/systematic/smartdevices.conf')
    assert module_0.INFO_FIELD_MAP == {'ATA Version is': 'ATA version', 'Device Model': 'Device model', 'Firmware Version': 'Firmware version', 'LU WWN Device Id': 'LU WWN device ID', 'Local Time is': 'Date', 'Model Family': 'Model family', 'Rotation Rate': 'Rotation rate', 'SATA Version is': 'SATA version', 'Sector Sizes': 'Sector sizes', 'Sector Size': 'Sector size', 'Serial Number': 'Serial number', 'User Capacity': 'User capacity', 'SMART support is': 'SMART support status'}
    assert module_0.INFO_COMMON_FIELDS == ('Device model', 'Serial number', 'Firmware version', 'Model family', 'User capacity', 'Sector size', 'Sector sizes')
    assert module_0.ATTRIBUTE_FIELD_NAME_MAP == {'airflow_temperature_cel': 'Airflow temperature', 'calibration_retry_count': 'Calibration retries', 'current_pending_sector': 'Current pending sectors', 'crc_error_count': 'CRC errors', 'ecc_error_rate': 'ECC error rate', 'end-to-end_error': 'End-to-end errors', 'erase_fail_count': 'Erase fail', 'erase_fail_count_total': 'Erase fail total', 'g-sense_error_rate': 'G-sense error rate', 'high_fly_writes': 'High-fly writes', 'load_cycle_count': 'Load cycles', 'multi_zone_error_rate': 'Multi-Zone error rate', 'reallocated_sector_ct': 'Reallocated sectors', 'power_on_hours': 'Power on hours', 'power_cycle_count': 'Power cycles', 'power-off_retract_count': 'Power-off retracts', 'program_fail_count': 'Program failures', 'program_fail_cnt_total': 'Program failures total', 'offline_uncorrectable': 'Offline uncorrectable', 'raw_read_error_rate': 'Raw read error rate', 'reallocated_event_count': 'Reallocated events', 'reported_uncorrect': 'Reported uncorrectable', 'retired_block_count': 'Retired blocks', 'runtime_bad_block': 'Runtibe bad blocks', 'por_recovery_count': 'POR recoveries', 'seek_error_rate': 'Seek error rate', 'spin_retry_count': 'Spin retries', 'spin_up_time': 'Spin up time', 'start_stop_count': 'Start-stop count', 'temperature_celsius': 'Temperature', 'total_lbas_written': 'Total LBAs written', 'total_lbas_read': 'Total LBAs read', 'udma_crc_error_count': 'UDMA CRC errors', 'uncorrectable_error_cnt': 'Uncorrectable errors', 'unexpect_power_loss_ct': 'Unexpected power losses', 'unexpected_power_loss_count': 'Unexpected power losses', 'used_rsvd_blk_cnt_tot': 'Used reserved blocks total', 'wear_leveling_count': 'Wear levelings'}
    assert module_0.ATTRIBUTE_COMMON_FIELDS == ('power_on_hours', 'total_lbas_written', 'total_lbas_read', 'airflow_temperature_cel', 'temperature_celsius', 'raw_read_error_rate', 'seek_error_rate', 'uncorrectable_error_cnt', 'crc_error_count', 'udma_crc_error_count', 'ecc_error_rate')
    assert module_0.SmartCtlClient.parser_name == 'smart'
    str_0 = 'zmore'
    var_0 = smart_ctl_client_0.execute(str_0)
    var_1 = smart_ctl_client_0.find_drive(str_0)
    smart_ctl_client_1 = module_0.SmartCtlClient(*var_0)
    smart_ctl_config_0 = module_0.SmartCtlConfig()
    bytes_0 = b'\xf9\x8f(,\xe7wf\xd6(\xf2\x91\x8a%'
    smart_drive_0 = module_0.SmartDrive(smart_ctl_client_1, bytes_0)
    assert f'{type(module_0.SmartDrive.is_supported).__module__}.{type(module_0.SmartDrive.is_supported).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.SmartDrive.is_healthy).__module__}.{type(module_0.SmartDrive.is_healthy).__qualname__}' == 'builtins.property'
    smart_drive_0.get_attributes()