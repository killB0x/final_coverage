# Automatically generated by Pynguin.
import pytest
import aeneas.globalfunctions as module_0
import aeneas.task as module_1

def test_case_0():
    var_0 = module_0.custom_tmp_dir()
    task_0 = module_1.Task(var_0)
    assert f'{type(task_0).__module__}.{type(task_0).__qualname__}' == 'aeneas.task.Task'
    assert f'{type(task_0.logger).__module__}.{type(task_0.logger).__qualname__}' == 'aeneas.logger.Logger'
    assert len(task_0.logger) == 6
    assert f'{type(task_0.rconf).__module__}.{type(task_0.rconf).__qualname__}' == 'aeneas.runtimeconfiguration.RuntimeConfiguration'
    assert f'{type(task_0.configuration).__module__}.{type(task_0.configuration).__qualname__}' == 'aeneas.task.TaskConfiguration'
    assert task_0.audio_file_path is None
    assert task_0.audio_file is None
    assert task_0.text_file_path is None
    assert task_0.text_file is None
    assert task_0.sync_map_file_path is None
    assert task_0.sync_map is None
    assert module_1.Task.TAG == 'Task'
    assert f'{type(module_1.Task.identifier).__module__}.{type(module_1.Task.identifier).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.audio_file_path_absolute).__module__}.{type(module_1.Task.audio_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.text_file_path_absolute).__module__}.{type(module_1.Task.text_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.sync_map_file_path_absolute).__module__}.{type(module_1.Task.sync_map_file_path_absolute).__qualname__}' == 'builtins.property'

def test_case_1():
    task_0 = module_1.Task()
    assert f'{type(task_0).__module__}.{type(task_0).__qualname__}' == 'aeneas.task.Task'
    assert f'{type(task_0.logger).__module__}.{type(task_0.logger).__qualname__}' == 'aeneas.logger.Logger'
    assert len(task_0.logger) == 6
    assert f'{type(task_0.rconf).__module__}.{type(task_0.rconf).__qualname__}' == 'aeneas.runtimeconfiguration.RuntimeConfiguration'
    assert task_0.configuration is None
    assert task_0.audio_file_path is None
    assert task_0.audio_file is None
    assert task_0.text_file_path is None
    assert task_0.text_file is None
    assert task_0.sync_map_file_path is None
    assert task_0.sync_map is None
    assert module_1.Task.TAG == 'Task'
    assert f'{type(module_1.Task.identifier).__module__}.{type(module_1.Task.identifier).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.audio_file_path_absolute).__module__}.{type(module_1.Task.audio_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.text_file_path_absolute).__module__}.{type(module_1.Task.text_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.sync_map_file_path_absolute).__module__}.{type(module_1.Task.sync_map_file_path_absolute).__qualname__}' == 'builtins.property'

def test_case_2():
    task_configuration_0 = module_1.TaskConfiguration()
    assert task_configuration_0.data == {'task_custom_id': None, 'task_description': None, 'task_language': None, 'task_adjust_boundary_aftercurrent_value': None, 'task_adjust_boundary_algorithm': None, 'task_adjust_boundary_beforenext_value': None, 'task_adjust_boundary_offset_value': None, 'task_adjust_boundary_no_zero': None, 'task_adjust_boundary_percent_value': None, 'task_adjust_boundary_rate_value': None, 'task_adjust_boundary_nonspeech_min': None, 'task_adjust_boundary_nonspeech_string': None, 'is_audio_file_detect_head_max': None, 'is_audio_file_detect_head_min': None, 'is_audio_file_detect_tail_max': None, 'is_audio_file_detect_tail_min': None, 'is_audio_file_head_length': None, 'is_audio_file_process_length': None, 'is_audio_file_tail_length': None, 'is_text_type': None, 'is_text_file_ignore_regex': None, 'is_text_file_transliterate_map': None, 'is_text_mplain_word_separator': None, 'is_text_munparsed_l1_id_regex': None, 'is_text_munparsed_l2_id_regex': None, 'is_text_munparsed_l3_id_regex': None, 'is_text_unparsed_class_regex': None, 'is_text_unparsed_id_regex': None, 'is_text_unparsed_id_sort': None, 'os_task_file_eaf_audio_ref': None, 'os_task_file_format': None, 'os_task_file_head_tail_format': None, 'os_task_file_id_regex': None, 'os_task_file_levels': None, 'os_task_file_name': None, 'os_task_file_smil_audio_ref': None, 'os_task_file_smil_page_ref': None}
    assert f'{type(task_configuration_0.types).__module__}.{type(task_configuration_0.types).__qualname__}' == 'builtins.dict'
    assert len(task_configuration_0.types) == 37
    assert task_configuration_0.aliases == {'custom_id': 'task_custom_id', 'description': 'task_description', 'language': 'task_language', 'aba_aftercurrent_value': 'task_adjust_boundary_aftercurrent_value', 'aba_algorithm': 'task_adjust_boundary_algorithm', 'aba_beforenext_value': 'task_adjust_boundary_beforenext_value', 'aba_offset_value': 'task_adjust_boundary_offset_value', 'aba_no_zero': 'task_adjust_boundary_no_zero', 'aba_percent_value': 'task_adjust_boundary_percent_value', 'aba_rate_value': 'task_adjust_boundary_rate_value', 'aba_nonspeech_min': 'task_adjust_boundary_nonspeech_min', 'aba_nonspeech_string': 'task_adjust_boundary_nonspeech_string', 'i_a_head_max': 'is_audio_file_detect_head_max', 'i_a_head_min': 'is_audio_file_detect_head_min', 'i_a_tail_max': 'is_audio_file_detect_tail_max', 'i_a_tail_min': 'is_audio_file_detect_tail_min', 'i_a_head': 'is_audio_file_head_length', 'i_a_process': 'is_audio_file_process_length', 'i_a_tail': 'is_audio_file_tail_length', 'i_t_format': 'is_text_type', 'i_t_ignore_regex': 'is_text_file_ignore_regex', 'i_t_transliterate_map': 'is_text_file_transliterate_map', 'i_t_mplain_word_separator': 'is_text_mplain_word_separator', 'i_t_munparsed_l1_id_regex': 'is_text_munparsed_l1_id_regex', 'i_t_munparsed_l2_id_regex': 'is_text_munparsed_l2_id_regex', 'i_t_munparsed_l3_id_regex': 'is_text_munparsed_l3_id_regex', 'i_t_unparsed_class_regex': 'is_text_unparsed_class_regex', 'i_t_unparsed_id_regex': 'is_text_unparsed_id_regex', 'i_t_unparsed_id_sort': 'is_text_unparsed_id_sort', 'o_eaf_audio_ref': 'os_task_file_eaf_audio_ref', 'o_format': 'os_task_file_format', 'o_h_t_format': 'os_task_file_head_tail_format', 'o_id_regex': 'os_task_file_id_regex', 'o_levels': 'os_task_file_levels', 'o_name': 'os_task_file_name', 'o_smil_audio_ref': 'os_task_file_smil_audio_ref', 'o_smil_page_ref': 'os_task_file_smil_page_ref'}
    assert task_configuration_0.desc == {'task_custom_id': 'custom ID', 'task_description': 'description', 'task_language': 'language (REQ, *)', 'task_adjust_boundary_aftercurrent_value': 'offset value, in s (aftercurrent)', 'task_adjust_boundary_algorithm': 'algorithm to adjust sync map values (*)', 'task_adjust_boundary_beforenext_value': 'offset value, in s (beforenext)', 'task_adjust_boundary_offset_value': 'offset value, in s (offset)', 'task_adjust_boundary_no_zero': 'if True, do not allow zero-length fragments', 'task_adjust_boundary_percent_value': 'percent value in [0..100] (percent)', 'task_adjust_boundary_rate_value': 'max rate, in chars/s (rate, rateaggressive)', 'task_adjust_boundary_nonspeech_min': 'minimum long nonspeech duration, in s', 'task_adjust_boundary_nonspeech_string': 'replace long nonspeech with this string or specify REMOVE', 'is_audio_file_detect_head_max': 'detect audio head, at most this many seconds', 'is_audio_file_detect_head_min': 'detect audio head, at least this many seconds', 'is_audio_file_detect_tail_max': 'detect audio tail, at most this many seconds', 'is_audio_file_detect_tail_min': 'detect audio tail, at least this many seconds', 'is_audio_file_head_length': 'ignore this many seconds at begin of audio', 'is_audio_file_process_length': 'process this many seconds of audio', 'is_audio_file_tail_length': 'ignore this many seconds at end of audio', 'is_text_type': 'text format (REQ, *)', 'is_text_file_ignore_regex': 'for the alignment, ignore text matched by regex', 'is_text_file_transliterate_map': 'for the alignment, apply this transliteration map to text', 'is_text_mplain_word_separator': 'word separator (mplain)', 'is_text_munparsed_l1_id_regex': 'regex matching level 1 id attributes (munparsed)', 'is_text_munparsed_l2_id_regex': 'regex matching level 2 id attributes (munparsed)', 'is_text_munparsed_l3_id_regex': 'regex matching level 3 id attributes (munparsed)', 'is_text_unparsed_class_regex': 'regex matching class attributes (unparsed)', 'is_text_unparsed_id_regex': 'regex matching id attributes (unparsed)', 'is_text_unparsed_id_sort': 'algorithm to sort matched element (unparsed) (*)', 'os_task_file_eaf_audio_ref': 'audio ref value (eaf)', 'os_task_file_format': 'sync map format (REQ, *)', 'os_task_file_head_tail_format': 'audio head/tail format (*)', 'os_task_file_id_regex': "regex to build sync map id's (subtitles, plain)", 'os_task_file_levels': 'output the specified levels only (mplain, munparserd)', 'os_task_file_name': 'sync map file name (ignored)', 'os_task_file_smil_audio_ref': 'audio ref value (smil, smilh, smilm)', 'os_task_file_smil_page_ref': 'text ref value (smil, smilh, smilm)'}
    assert len(module_1.TaskConfiguration.FIELDS) == 37
    assert module_1.TaskConfiguration.TAG == 'TaskConfiguration'
    var_0 = task_configuration_0.aba_parameters()

def test_case_3():
    task_configuration_0 = module_1.TaskConfiguration()
    assert task_configuration_0.data == {'task_custom_id': None, 'task_description': None, 'task_language': None, 'task_adjust_boundary_aftercurrent_value': None, 'task_adjust_boundary_algorithm': None, 'task_adjust_boundary_beforenext_value': None, 'task_adjust_boundary_offset_value': None, 'task_adjust_boundary_no_zero': None, 'task_adjust_boundary_percent_value': None, 'task_adjust_boundary_rate_value': None, 'task_adjust_boundary_nonspeech_min': None, 'task_adjust_boundary_nonspeech_string': None, 'is_audio_file_detect_head_max': None, 'is_audio_file_detect_head_min': None, 'is_audio_file_detect_tail_max': None, 'is_audio_file_detect_tail_min': None, 'is_audio_file_head_length': None, 'is_audio_file_process_length': None, 'is_audio_file_tail_length': None, 'is_text_type': None, 'is_text_file_ignore_regex': None, 'is_text_file_transliterate_map': None, 'is_text_mplain_word_separator': None, 'is_text_munparsed_l1_id_regex': None, 'is_text_munparsed_l2_id_regex': None, 'is_text_munparsed_l3_id_regex': None, 'is_text_unparsed_class_regex': None, 'is_text_unparsed_id_regex': None, 'is_text_unparsed_id_sort': None, 'os_task_file_eaf_audio_ref': None, 'os_task_file_format': None, 'os_task_file_head_tail_format': None, 'os_task_file_id_regex': None, 'os_task_file_levels': None, 'os_task_file_name': None, 'os_task_file_smil_audio_ref': None, 'os_task_file_smil_page_ref': None}
    assert f'{type(task_configuration_0.types).__module__}.{type(task_configuration_0.types).__qualname__}' == 'builtins.dict'
    assert len(task_configuration_0.types) == 37
    assert task_configuration_0.aliases == {'custom_id': 'task_custom_id', 'description': 'task_description', 'language': 'task_language', 'aba_aftercurrent_value': 'task_adjust_boundary_aftercurrent_value', 'aba_algorithm': 'task_adjust_boundary_algorithm', 'aba_beforenext_value': 'task_adjust_boundary_beforenext_value', 'aba_offset_value': 'task_adjust_boundary_offset_value', 'aba_no_zero': 'task_adjust_boundary_no_zero', 'aba_percent_value': 'task_adjust_boundary_percent_value', 'aba_rate_value': 'task_adjust_boundary_rate_value', 'aba_nonspeech_min': 'task_adjust_boundary_nonspeech_min', 'aba_nonspeech_string': 'task_adjust_boundary_nonspeech_string', 'i_a_head_max': 'is_audio_file_detect_head_max', 'i_a_head_min': 'is_audio_file_detect_head_min', 'i_a_tail_max': 'is_audio_file_detect_tail_max', 'i_a_tail_min': 'is_audio_file_detect_tail_min', 'i_a_head': 'is_audio_file_head_length', 'i_a_process': 'is_audio_file_process_length', 'i_a_tail': 'is_audio_file_tail_length', 'i_t_format': 'is_text_type', 'i_t_ignore_regex': 'is_text_file_ignore_regex', 'i_t_transliterate_map': 'is_text_file_transliterate_map', 'i_t_mplain_word_separator': 'is_text_mplain_word_separator', 'i_t_munparsed_l1_id_regex': 'is_text_munparsed_l1_id_regex', 'i_t_munparsed_l2_id_regex': 'is_text_munparsed_l2_id_regex', 'i_t_munparsed_l3_id_regex': 'is_text_munparsed_l3_id_regex', 'i_t_unparsed_class_regex': 'is_text_unparsed_class_regex', 'i_t_unparsed_id_regex': 'is_text_unparsed_id_regex', 'i_t_unparsed_id_sort': 'is_text_unparsed_id_sort', 'o_eaf_audio_ref': 'os_task_file_eaf_audio_ref', 'o_format': 'os_task_file_format', 'o_h_t_format': 'os_task_file_head_tail_format', 'o_id_regex': 'os_task_file_id_regex', 'o_levels': 'os_task_file_levels', 'o_name': 'os_task_file_name', 'o_smil_audio_ref': 'os_task_file_smil_audio_ref', 'o_smil_page_ref': 'os_task_file_smil_page_ref'}
    assert task_configuration_0.desc == {'task_custom_id': 'custom ID', 'task_description': 'description', 'task_language': 'language (REQ, *)', 'task_adjust_boundary_aftercurrent_value': 'offset value, in s (aftercurrent)', 'task_adjust_boundary_algorithm': 'algorithm to adjust sync map values (*)', 'task_adjust_boundary_beforenext_value': 'offset value, in s (beforenext)', 'task_adjust_boundary_offset_value': 'offset value, in s (offset)', 'task_adjust_boundary_no_zero': 'if True, do not allow zero-length fragments', 'task_adjust_boundary_percent_value': 'percent value in [0..100] (percent)', 'task_adjust_boundary_rate_value': 'max rate, in chars/s (rate, rateaggressive)', 'task_adjust_boundary_nonspeech_min': 'minimum long nonspeech duration, in s', 'task_adjust_boundary_nonspeech_string': 'replace long nonspeech with this string or specify REMOVE', 'is_audio_file_detect_head_max': 'detect audio head, at most this many seconds', 'is_audio_file_detect_head_min': 'detect audio head, at least this many seconds', 'is_audio_file_detect_tail_max': 'detect audio tail, at most this many seconds', 'is_audio_file_detect_tail_min': 'detect audio tail, at least this many seconds', 'is_audio_file_head_length': 'ignore this many seconds at begin of audio', 'is_audio_file_process_length': 'process this many seconds of audio', 'is_audio_file_tail_length': 'ignore this many seconds at end of audio', 'is_text_type': 'text format (REQ, *)', 'is_text_file_ignore_regex': 'for the alignment, ignore text matched by regex', 'is_text_file_transliterate_map': 'for the alignment, apply this transliteration map to text', 'is_text_mplain_word_separator': 'word separator (mplain)', 'is_text_munparsed_l1_id_regex': 'regex matching level 1 id attributes (munparsed)', 'is_text_munparsed_l2_id_regex': 'regex matching level 2 id attributes (munparsed)', 'is_text_munparsed_l3_id_regex': 'regex matching level 3 id attributes (munparsed)', 'is_text_unparsed_class_regex': 'regex matching class attributes (unparsed)', 'is_text_unparsed_id_regex': 'regex matching id attributes (unparsed)', 'is_text_unparsed_id_sort': 'algorithm to sort matched element (unparsed) (*)', 'os_task_file_eaf_audio_ref': 'audio ref value (eaf)', 'os_task_file_format': 'sync map format (REQ, *)', 'os_task_file_head_tail_format': 'audio head/tail format (*)', 'os_task_file_id_regex': "regex to build sync map id's (subtitles, plain)", 'os_task_file_levels': 'output the specified levels only (mplain, munparserd)', 'os_task_file_name': 'sync map file name (ignored)', 'os_task_file_smil_audio_ref': 'audio ref value (smil, smilh, smilm)', 'os_task_file_smil_page_ref': 'text ref value (smil, smilh, smilm)'}
    assert len(module_1.TaskConfiguration.FIELDS) == 37
    assert module_1.TaskConfiguration.TAG == 'TaskConfiguration'

def test_case_4():
    var_0 = module_0.custom_tmp_dir()
    task_0 = module_1.Task(var_0)
    assert f'{type(task_0).__module__}.{type(task_0).__qualname__}' == 'aeneas.task.Task'
    assert f'{type(task_0.logger).__module__}.{type(task_0.logger).__qualname__}' == 'aeneas.logger.Logger'
    assert len(task_0.logger) == 6
    assert f'{type(task_0.rconf).__module__}.{type(task_0.rconf).__qualname__}' == 'aeneas.runtimeconfiguration.RuntimeConfiguration'
    assert f'{type(task_0.configuration).__module__}.{type(task_0.configuration).__qualname__}' == 'aeneas.task.TaskConfiguration'
    assert task_0.audio_file_path is None
    assert task_0.audio_file is None
    assert task_0.text_file_path is None
    assert task_0.text_file is None
    assert task_0.sync_map_file_path is None
    assert task_0.sync_map is None
    assert module_1.Task.TAG == 'Task'
    assert f'{type(module_1.Task.identifier).__module__}.{type(module_1.Task.identifier).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.audio_file_path_absolute).__module__}.{type(module_1.Task.audio_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.text_file_path_absolute).__module__}.{type(module_1.Task.text_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.sync_map_file_path_absolute).__module__}.{type(module_1.Task.sync_map_file_path_absolute).__qualname__}' == 'builtins.property'
    var_1 = task_0.__str__()

@pytest.mark.xfail(strict=True)
def test_case_5():
    task_0 = module_1.Task()
    assert f'{type(task_0).__module__}.{type(task_0).__qualname__}' == 'aeneas.task.Task'
    assert f'{type(task_0.logger).__module__}.{type(task_0.logger).__qualname__}' == 'aeneas.logger.Logger'
    assert len(task_0.logger) == 6
    assert f'{type(task_0.rconf).__module__}.{type(task_0.rconf).__qualname__}' == 'aeneas.runtimeconfiguration.RuntimeConfiguration'
    assert task_0.configuration is None
    assert task_0.audio_file_path is None
    assert task_0.audio_file is None
    assert task_0.text_file_path is None
    assert task_0.text_file is None
    assert task_0.sync_map_file_path is None
    assert task_0.sync_map is None
    assert module_1.Task.TAG == 'Task'
    assert f'{type(module_1.Task.identifier).__module__}.{type(module_1.Task.identifier).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.audio_file_path_absolute).__module__}.{type(module_1.Task.audio_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.text_file_path_absolute).__module__}.{type(module_1.Task.text_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.sync_map_file_path_absolute).__module__}.{type(module_1.Task.sync_map_file_path_absolute).__qualname__}' == 'builtins.property'
    task_0.output_sync_map_file()

def test_case_6():
    task_0 = module_1.Task()
    assert f'{type(task_0).__module__}.{type(task_0).__qualname__}' == 'aeneas.task.Task'
    assert f'{type(task_0.logger).__module__}.{type(task_0.logger).__qualname__}' == 'aeneas.logger.Logger'
    assert len(task_0.logger) == 6
    assert f'{type(task_0.rconf).__module__}.{type(task_0.rconf).__qualname__}' == 'aeneas.runtimeconfiguration.RuntimeConfiguration'
    assert task_0.configuration is None
    assert task_0.audio_file_path is None
    assert task_0.audio_file is None
    assert task_0.text_file_path is None
    assert task_0.text_file is None
    assert task_0.sync_map_file_path is None
    assert task_0.sync_map is None
    assert module_1.Task.TAG == 'Task'
    assert f'{type(module_1.Task.identifier).__module__}.{type(module_1.Task.identifier).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.audio_file_path_absolute).__module__}.{type(module_1.Task.audio_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.text_file_path_absolute).__module__}.{type(module_1.Task.text_file_path_absolute).__qualname__}' == 'builtins.property'
    assert f'{type(module_1.Task.sync_map_file_path_absolute).__module__}.{type(module_1.Task.sync_map_file_path_absolute).__qualname__}' == 'builtins.property'
    var_0 = task_0.sync_map_leaves(task_0)