# Automatically generated by Pynguin.
import pytest
import transitions.extensions.markup as module_0

def test_case_0():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'

def test_case_1():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    str_0 = ' Representation of an asynchronous transition managed by a ``AsyncMachine`` instance.\n\n    Attributes:\n        source (str): Source state of the transition.\n        dest (str): Destination state of the transition.\n        prepare (list): Callbacks executed before conditions checks.\n        conditions (list): Callbacks evaluated to determine if\n            the transition should be executed.\n        before (list): Callbacks executed before the transition is executed\n            but only if condition checks have been successful.\n        after (list): Callbacks executed after the transition is executed\n            but only if condition checks have been successful.\n    '
    var_0 = markup_machine_0.add_states(str_0, on_exit=str_0, ignore_invalid_triggers=markup_machine_0)
    assert len(markup_machine_0.events) == 2
    var_1 = markup_machine_0.get_markup_config()

def test_case_2():
    bytes_0 = b'\x17c\x86x\x12Coq\xf5g\xbd\x92'
    var_0 = module_0.rep(bytes_0)
    assert var_0 == "b'\\x17c\\x86x\\x12Coq\\xf5g\\xbd\\x92'"

@pytest.mark.xfail(strict=True)
def test_case_3():
    bool_0 = True
    var_0 = bool_0.__abs__()
    var_1 = module_0.rep(bool_0)
    assert var_1 == 'True'
    list_0 = [var_0]
    module_0.MarkupMachine(*list_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    bytes_0 = b'[-\x97o\x12F#\x9f'
    var_0 = module_0.rep(bytes_0, bytes_0)
    var_0.__trunc__()

def test_case_5():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    var_0 = markup_machine_0.get_markup_config()

@pytest.mark.xfail(strict=True)
def test_case_6():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    str_0 = ' Representation of an asynchronous transition managed by a ``AsyncMachine`` instance.\n\n    Attributes:\n        source (str): Source state of the transition.\n        dest (str): Destination state of the transition.\n        prepare (list): Callbacks executed before conditions checks.\n        conditions (list): Callbacks evaluated to determine if\n            the transition should be executed.\n        before (list): Callbacks executed before the transition is executed\n            but only if condition checks have been successful.\n        after (list): Callbacks executed after the transition is executed\n            but only if condition checks have been successful.\n    '
    var_0 = markup_machine_0.add_states(str_0, on_exit=str_0, ignore_invalid_triggers=markup_machine_0)
    assert len(markup_machine_0.events) == 2
    var_1 = markup_machine_0.get_markup_config()
    var_2 = markup_machine_0.get_markup_config()
    str_0.remove_transition(var_2, dest=str_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    var_0 = module_0.rep(markup_machine_0)
    var_1 = markup_machine_0.add_transition(var_0, var_0, var_0)
    assert len(markup_machine_0.events) == 2
    var_2 = markup_machine_0.get_markup_config()
    var_0.get_markup_config()

@pytest.mark.xfail(strict=True)
def test_case_8():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    str_0 = ' Representation of an asynchronous transition managed by a ``AsyncMachine`` instance.\n\n    Attributes:\n        source (str): Source state of the transition.\n        dest (str): Destination state of the transition.\n        prepare (list): Callbacks executed before conditions checks.\n        conditions (list): Callbacks evaluated to determine if\n            the transition should be executed.\n        before (list): Callbacks executed before the transition is executed\n            but only if condition checks have been successful.\n        after (lit): Callbacks executed after the transition is executed\n            but only if condition checks have been successful.\n    '
    var_0 = markup_machine_0.add_transition(str_0, str_0, markup_machine_0, unless=markup_machine_0, prepare=markup_machine_0)
    assert len(markup_machine_0.events) == 2
    var_1 = markup_machine_0.get_markup_config()
    module_0.MarkupMachine(*markup_machine_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    var_0 = module_0.rep(markup_machine_0)
    var_1 = markup_machine_0.add_transition(var_0, var_0, var_0, unless=var_0, prepare=var_0)
    assert len(markup_machine_0.events) == 2
    var_2 = markup_machine_0.get_markup_config()
    var_3 = module_0.rep(var_0)
    var_4 = var_1.__eq__(var_0)
    var_0.get_markup_config()

@pytest.mark.xfail(strict=True)
def test_case_10():
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    str_0 = ' Representation of an asynchronous transition managed by a ``AsyncMachine`` instance.\n\n    Attributes:\n        source (str): Source state of the transition.\n        dest (str): Destination state of the transition.\n        prepare (list): Callbacks executed before conditions checks.\n        conditions (list): Callbacks evaluated to determine if\n            the transition should be executed.\n        before (list): Callbacks executed before the transition is executed\n            but only if condition checks have been successful.\n        after (lit): Callbacks executed after the transition is executed\n            but only if condition checks have been successful.\n    '
    var_0 = module_0.rep(markup_machine_0)
    var_1 = markup_machine_0.add_ordered_transitions(str_0, loop_includes_initial=markup_machine_0, conditions=str_0, prepare=str_0)
    assert len(markup_machine_0.events) == 2
    var_2 = markup_machine_0.add_transition(str_0, str_0, var_0, unless=var_0, prepare=var_0)
    assert len(markup_machine_0.events) == 3
    var_3 = markup_machine_0.get_markup_config()
    module_0.MarkupMachine(*markup_machine_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    none_type_0 = None
    str_0 = '>&V+\\E69bTP'
    markup_machine_0 = module_0.MarkupMachine()
    assert f'{type(markup_machine_0).__module__}.{type(markup_machine_0).__qualname__}' == 'transitions.extensions.markup.MarkupMachine'
    assert markup_machine_0.skip_references is True
    assert f'{type(markup_machine_0.states).__module__}.{type(markup_machine_0.states).__qualname__}' == 'collections.OrderedDict'
    assert len(markup_machine_0.states) == 1
    assert f'{type(markup_machine_0.events).__module__}.{type(markup_machine_0.events).__qualname__}' == 'builtins.dict'
    assert len(markup_machine_0.events) == 1
    assert markup_machine_0.send_event is False
    assert markup_machine_0.auto_transitions is True
    assert markup_machine_0.ignore_invalid_triggers is None
    assert markup_machine_0.name == ''
    assert markup_machine_0.model_attribute == 'state'
    assert f'{type(markup_machine_0.models).__module__}.{type(markup_machine_0.models).__qualname__}' == 'builtins.list'
    assert len(markup_machine_0.models) == 1
    assert markup_machine_0.state == 'initial'
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    var_0 = markup_machine_0.add_transition(str_0, markup_machine_0, none_type_0, markup_machine_0, before=none_type_0)
    assert len(markup_machine_0.events) == 2
    var_1 = markup_machine_0.get_markup_config()
    var_0.__rfloordiv__(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    none_type_0 = None
    list_0 = [none_type_0, none_type_0, none_type_0, none_type_0]
    markup_machine_0 = module_0.MarkupMachine(*list_0)
    assert markup_machine_0.skip_references is True
    assert len(markup_machine_0.states) == 0
    assert markup_machine_0.events == {}
    assert module_0.MarkupMachine.state_attributes == ['on_exit', 'on_enter', 'ignore_invalid_triggers', 'timeout', 'on_timeout', 'tags', 'label']
    assert module_0.MarkupMachine.transition_attributes == ['source', 'dest', 'prepare', 'before', 'after', 'label']
    assert f'{type(module_0.MarkupMachine.auto_transitions_markup).__module__}.{type(module_0.MarkupMachine.auto_transitions_markup).__qualname__}' == 'builtins.property'
    assert f'{type(module_0.MarkupMachine.markup).__module__}.{type(module_0.MarkupMachine.markup).__qualname__}' == 'builtins.property'
    var_0 = markup_machine_0.get_markup_config()
    var_0.get_markup_config()