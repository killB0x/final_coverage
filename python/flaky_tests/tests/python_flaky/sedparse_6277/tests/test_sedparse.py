# Automatically generated by Pynguin.
import pytest
import sedparse as module_0
import re as module_1
import codecs as module_2

def test_case_0():
    var_0 = module_0.ignore_trailing_fluff()

def test_case_1():
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_subst_0.to_dict()

def test_case_2():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_sed_cmd_0.__str__()
    assert var_0 == "<unknown address type '1'>,<unknown address type '1'> "

@pytest.mark.xfail(strict=True)
def test_case_3():
    str_0 = 'g '
    module_0.match_slash(str_0, str_0)

def test_case_4():
    var_0 = module_0.in_nonblank()
    var_1 = module_0.match_slash(var_0, var_0)

def test_case_5():
    var_0 = module_0.read_filename()

def test_case_6():
    struct_regex_0 = module_0.in_nonblank()

@pytest.mark.xfail(strict=True)
def test_case_7():
    var_0 = module_0.read_label()

def test_case_8():
    struct_subst_0 = module_0.ignore_trailing_fluff()

def test_case_9():
    var_0 = module_0.read_end_of_cmd()

def test_case_10():
    struct_addr_0 = module_0.read_comment()

def test_case_11():
    struct_addr_0 = module_0.read_comment()

def test_case_12():
    var_0 = module_0.read_filename()

def test_case_13():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = module_0.snarf_char_class(struct_regex_0)

def test_case_14():
    struct_sed_cmd_0 = module_0.check_final_program()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = module_0.snarf_char_class(struct_sed_cmd_0)
    var_1 = module_0.compile_program(var_0)

@pytest.mark.xfail(strict=True)
def test_case_15():
    bool_0 = False
    var_0 = module_0.compile_program(bool_0)

def test_case_16():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = module_0.compile_program(struct_sed_cmd_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    str_0 = '}'
    none_type_0 = None
    module_0.compile_file(none_type_0, str_0)

def test_case_18():
    var_0 = module_0.check_final_program()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.old_text_buf is None
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_19():
    var_0 = module_0.reset_globals()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

@pytest.mark.xfail(strict=True)
def test_case_20():
    module_0.entrypoint()

def test_case_21():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_sed_cmd_0.to_json(struct_sed_cmd_0)
    assert var_0 == '{\n    "a1": {\n        "addr_number": 0,\n        "addr_type": 1\n    },\n    "a2": {\n        "addr_number": 0,\n        "addr_type": 1\n    },\n    "line": 0\n}'

def test_case_22():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_23():
    var_0 = module_0.struct_sed_cmd_x()
    assert f'{type(var_0.cmd_txt).__module__}.{type(var_0.cmd_txt).__qualname__}' == 'sedparse.struct_text_buf'
    assert var_0.int_arg == -1
    assert var_0.fname == ''
    assert f'{type(var_0.cmd_subst).__module__}.{type(var_0.cmd_subst).__qualname__}' == 'sedparse.struct_subst'
    assert var_0.label_name == ''
    assert var_0.comment == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_24():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)
    var_2 = var_0.__str__()
    var_3 = module_0.mark_subst_opts(var_1)

@pytest.mark.xfail(strict=True)
def test_case_25():
    struct_text_buf_0 = module_0.struct_text_buf()
    assert struct_text_buf_0.text == []
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    struct_sed_cmd_x_0 = module_0.struct_sed_cmd_x()
    assert f'{type(struct_sed_cmd_x_0.cmd_txt).__module__}.{type(struct_sed_cmd_x_0.cmd_txt).__qualname__}' == 'sedparse.struct_text_buf'
    assert struct_sed_cmd_x_0.int_arg == -1
    assert struct_sed_cmd_x_0.fname == ''
    assert f'{type(struct_sed_cmd_x_0.cmd_subst).__module__}.{type(struct_sed_cmd_x_0.cmd_subst).__qualname__}' == 'sedparse.struct_subst'
    assert struct_sed_cmd_x_0.label_name == ''
    assert struct_sed_cmd_x_0.comment == ''
    none_type_0 = None
    var_0 = module_0.debug(none_type_0)
    var_1 = struct_text_buf_0.__str__()
    assert var_1 == ''
    var_2 = struct_sed_cmd_x_0.to_json()
    assert var_2 == '{}'
    var_3 = struct_sed_cmd_x_0.to_dict(var_2)
    var_0.__getattr__(none_type_0)

def test_case_26():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_27():
    var_0 = module_0.read_label()
    assert var_0 == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_regex(var_0, var_0)
    assert var_1.slash == ''

def test_case_28():
    struct_sed_cmd_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

@pytest.mark.xfail(strict=True)
def test_case_29():
    str_0 = '__main__'
    module_0.bad_command(str_0)

@pytest.mark.xfail(strict=True)
def test_case_30():
    var_0 = module_0.in_nonblank()
    assert var_0 == '<EOF>'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    module_0.compile_string(var_0, var_0)

def test_case_31():
    var_0 = module_0.get_argparser()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'argparse.ArgumentParser'
    assert var_0.description == 'Parse a sed script and show its JSON representation in STDOUT.'
    assert var_0.argument_default is None
    assert var_0.prefix_chars == '-'
    assert var_0.conflict_handler == 'error'
    assert var_0.prog == 'pynguin'
    assert var_0.usage is None
    assert var_0.epilog is None
    assert var_0.fromfile_prefix_chars is None
    assert var_0.add_help is True
    assert var_0.allow_abbrev is True
    assert var_0.exit_on_error is True
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_32():
    none_type_0 = None
    module_0.savchar(none_type_0)

def test_case_33():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_34():
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_subst_0.__str__()
    assert var_0 == ''

def test_case_35():
    struct_sed_cmd_x_0 = module_0.struct_sed_cmd_x()
    assert f'{type(struct_sed_cmd_x_0.cmd_txt).__module__}.{type(struct_sed_cmd_x_0.cmd_txt).__qualname__}' == 'sedparse.struct_text_buf'
    assert struct_sed_cmd_x_0.int_arg == -1
    assert struct_sed_cmd_x_0.fname == ''
    assert f'{type(struct_sed_cmd_x_0.cmd_subst).__module__}.{type(struct_sed_cmd_x_0.cmd_subst).__qualname__}' == 'sedparse.struct_subst'
    assert struct_sed_cmd_x_0.label_name == ''
    assert struct_sed_cmd_x_0.comment == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = module_0.mark_subst_opts(struct_sed_cmd_x_0)

def test_case_36():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.read_filename()
    var_2 = module_0.compile_string(var_1, var_0)
    var_3 = module_0.mark_subst_opts(var_0)

def test_case_37():
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_subst_0.__str__()
    assert var_0 == ''
    var_1 = struct_subst_0.__repr__()
    assert var_1 == "struct_subst(regx=struct_regex(slash='', pattern='', flags=''), replacement=struct_replacement(text=''), outf=struct_output(name=''))"
    var_2 = module_0.compile_program(var_0)

def test_case_38():
    struct_regex_0 = module_0.read_label()
    assert struct_regex_0 == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

@pytest.mark.xfail(strict=True)
def test_case_39():
    bool_0 = True
    module_0.bad_command(bool_0)

def test_case_40():
    var_0 = module_1.purge()
    var_1 = module_0.compile_program(var_0)
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_41():
    parse_error_0 = module_0.ParseError()
    assert parse_error_0.message == ''
    assert parse_error_0.file == ''
    assert parse_error_0.line == 0
    assert parse_error_0.column == 0
    assert parse_error_0.expression == 0
    assert parse_error_0.exitcode == 1
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_42():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_regex_0.__repr__()
    assert var_0 == "struct_regex(slash='', pattern='', flags='')"
    var_1 = module_0.mark_subst_opts(struct_regex_0)

def test_case_43():
    var_0 = module_0.read_end_of_cmd()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_44():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = module_0.mark_subst_opts(struct_sed_cmd_0)

@pytest.mark.xfail(strict=True)
def test_case_45():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.next_cmd_entry(var_0)
    assert var_1.cmd == '\x00'
    assert f'{type(var_1.x).__module__}.{type(var_1.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert var_1.line == 0
    struct_addr_0 = module_0.struct_addr()
    assert struct_addr_0.addr_type == 1
    assert struct_addr_0.addr_number == 0
    assert struct_addr_0.addr_step == 0
    assert f'{type(struct_addr_0.addr_regex).__module__}.{type(struct_addr_0.addr_regex).__qualname__}' == 'sedparse.struct_regex'
    var_2 = module_0.read_text(struct_addr_0, var_0)
    assert f'{type(struct_addr_0.text).__module__}.{type(struct_addr_0.text).__qualname__}' == 'builtins.list'
    assert len(struct_addr_0.text) == 2
    assert f'{type(module_0.old_text_buf).__module__}.{type(module_0.old_text_buf).__qualname__}' == 'sedparse.struct_addr'
    assert module_0.old_text_buf.addr_type == 1
    assert module_0.old_text_buf.addr_number == 0
    assert module_0.old_text_buf.addr_step == 0
    assert f'{type(module_0.old_text_buf.addr_regex).__module__}.{type(module_0.old_text_buf.addr_regex).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(module_0.old_text_buf.text).__module__}.{type(module_0.old_text_buf.text).__qualname__}' == 'builtins.list'
    assert len(module_0.old_text_buf.text) == 2
    module_0.compile_string(var_1, var_1)

@pytest.mark.xfail(strict=True)
def test_case_46():
    module_0.read_comment()
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_47():
    var_0 = module_0.struct_sed_cmd()
    assert f'{type(var_0.a1).__module__}.{type(var_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(var_0.a2).__module__}.{type(var_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert var_0.addr_bang is False
    assert var_0.cmd == ''
    assert f'{type(var_0.x).__module__}.{type(var_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert var_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.to_json(var_0)
    assert var_1 == '{\n    "a1": {\n        "addr_number": 0,\n        "addr_type": 1\n    },\n    "a2": {\n        "addr_number": 0,\n        "addr_type": 1\n    },\n    "line": 0\n}'

@pytest.mark.xfail(strict=True)
def test_case_48():
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    module_0.savchar(struct_subst_0)

@pytest.mark.xfail(strict=True)
def test_case_49():
    var_0 = module_0.check_final_program()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    var_1 = struct_regex_0.to_json(var_0)
    assert var_1 == '{\n    "flags": "",\n    "pattern": "",\n    "slash": ""\n}'
    module_0.compile_string(var_0, var_0)

@pytest.mark.xfail(strict=True)
def test_case_50():
    module_0.inchar()
    var_1 = module_0.print_program(var_0)

def test_case_51():
    module_0.read_filename()
    var_0 = module_0.print_program(struct_regex_0)

def test_case_52():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_sed_cmd_0.__str__()
    assert var_0 == "<unknown address type '1'>,<unknown address type '1'> "
    none_type_0 = None
    str_0 = '0qo(A46^Y'
    str_1 = "txxRL?\nVsk~w/'*B\x0bTxd"
    var_1 = struct_sed_cmd_0.to_dict(str_0)
    module_0.read_filename()
    var_3 = struct_sed_cmd_0.to_json(var_2)
    complex_0 = (-469.3-2120j)
    var_4 = module_0.read_end_of_cmd()
    dict_0 = {str_0: str_0, str_1: complex_0, str_0: str_0, str_1: str_1}
    var_5 = module_0.snarf_char_class(none_type_0)
    var_6 = module_2.iterdecode(none_type_0, none_type_0, **dict_0)
    var_7 = module_0.read_text(var_6, var_5)

def test_case_53():
    var_0 = module_0.check_final_program()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert f'{type(module_0.old_text_buf).__module__}.{type(module_0.old_text_buf).__qualname__}' == 'sedparse.struct_addr'
    assert module_0.old_text_buf.addr_type == 1
    assert module_0.old_text_buf.addr_number == 0
    assert module_0.old_text_buf.addr_step == 0
    assert f'{type(module_0.old_text_buf.addr_regex).__module__}.{type(module_0.old_text_buf.addr_regex).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(module_0.old_text_buf.text).__module__}.{type(module_0.old_text_buf.text).__qualname__}' == 'builtins.list'
    assert len(module_0.old_text_buf.text) == 2
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

@pytest.mark.xfail(strict=True)
def test_case_54():
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert f'{type(module_0.old_text_buf).__module__}.{type(module_0.old_text_buf).__qualname__}' == 'sedparse.struct_addr'
    assert module_0.old_text_buf.addr_type == 1
    assert module_0.old_text_buf.addr_number == 0
    assert module_0.old_text_buf.addr_step == 0
    assert f'{type(module_0.old_text_buf.addr_regex).__module__}.{type(module_0.old_text_buf.addr_regex).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(module_0.old_text_buf.text).__module__}.{type(module_0.old_text_buf.text).__qualname__}' == 'builtins.list'
    assert len(module_0.old_text_buf.text) == 2
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    struct_output_0 = module_0.struct_output()
    assert struct_output_0.name == ''
    var_0 = struct_sed_cmd_0.__repr__()
    assert var_0 == "struct_sed_cmd(line=0, cmd='', addr_bang=False, a1=struct_addr(addr_type=1, addr_number=0, addr_step=0, addr_regex=struct_regex(slash='', pattern='', flags='')), a2=struct_addr(addr_type=1, addr_number=0, addr_step=0, addr_regex=struct_regex(slash='', pattern='', flags='')), x=struct_sed_cmd_x(int_arg=-1, label_name='', fname='', comment='', cmd_txt=struct_text_buf(text=[]), cmd_subst=struct_subst(regx=struct_regex(slash='', pattern='', flags=''), replacement=struct_replacement(text=''), outf=struct_output(name=''))))"
    var_1 = struct_sed_cmd_0.to_dict()
    var_2 = module_1.purge()
    var_3 = struct_output_0.__str__()
    assert var_3 == ''
    module_0.compile_file(var_0, var_3)

@pytest.mark.xfail(strict=True)
def test_case_55():
    str_0 = 'ya\t0A[\t5E|RFdIY:6'
    module_0.in_integer(str_0)

def test_case_56():
    module_0.read_comment()
    var_1 = module_0.snarf_char_class(var_0)
    var_2 = module_0.to_json(var_1, var_1)
    var_3 = module_0.snarf_char_class(var_2)
    var_4 = module_0.print_program(var_0)

def test_case_57():
    none_type_0 = None
    module_0.compile_program(none_type_0)

def test_case_58():
    module_0.read_filename()

def test_case_59():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    module_0.read_filename()
    var_0 = struct_regex_0.escape()
    var_1 = struct_regex_0.to_json()
    var_2 = module_0.in_integer(var_0)

def test_case_60():
    module_0.read_label()

@pytest.mark.xfail(strict=True)
def test_case_61():
    var_0 = module_0.reset_globals()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_program(var_0)
    var_2 = module_0.ignore_trailing_fluff()
    struct_sed_cmd_0 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_0.a1).__module__}.{type(struct_sed_cmd_0.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_0.a2).__module__}.{type(struct_sed_cmd_0.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_0.addr_bang is False
    assert struct_sed_cmd_0.cmd == ''
    assert f'{type(struct_sed_cmd_0.x).__module__}.{type(struct_sed_cmd_0.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_0.line == 0
    var_3 = module_0.read_filename()
    var_4 = var_2.__str__()
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    struct_sed_cmd_1 = module_0.struct_sed_cmd()
    assert f'{type(struct_sed_cmd_1.a1).__module__}.{type(struct_sed_cmd_1.a1).__qualname__}' == 'sedparse.struct_addr'
    assert f'{type(struct_sed_cmd_1.a2).__module__}.{type(struct_sed_cmd_1.a2).__qualname__}' == 'sedparse.struct_addr'
    assert struct_sed_cmd_1.addr_bang is False
    assert struct_sed_cmd_1.cmd == ''
    assert f'{type(struct_sed_cmd_1.x).__module__}.{type(struct_sed_cmd_1.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert struct_sed_cmd_1.line == 0
    var_5 = var_2.__str__()
    var_6 = var_5.__repr__()
    var_7 = module_0.mark_subst_opts(var_4)
    var_6.to_dict()

@pytest.mark.xfail(strict=True)
def test_case_62():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.snarf_char_class(var_0)
    assert var_1 == '<EOF>'
    var_2 = module_0.ignore_trailing_fluff()
    var_3 = module_0.read_label()
    assert var_3 == ''
    var_4 = module_0.compile_program(var_3)
    var_5 = module_0.read_end_of_cmd()
    var_6 = module_0.add1_buffer(var_0, var_1)
    var_6.decode(var_6, var_6)

@pytest.mark.xfail(strict=True)
def test_case_63():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.next_cmd_entry(var_0)
    assert var_1.cmd == '\x00'
    assert f'{type(var_1.x).__module__}.{type(var_1.x).__qualname__}' == 'sedparse.struct_sed_cmd_x'
    assert var_1.line == 0
    var_2 = module_0.snarf_char_class(var_0)
    assert var_2 == '<EOF>'
    var_3 = module_0.to_json(var_0)
    assert var_3 == '[\n    {\n        "cmd": "\\u0000",\n        "line": 0\n    }\n]'
    module_0.compile_string(var_0, var_0)

def test_case_64():
    var_0 = module_0.read_label()
    assert var_0 == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_program(var_0)

def test_case_65():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.in_nonblank()
    assert var_1 == '<EOF>'
    var_2 = module_0.compile_string(var_0, var_0)

def test_case_66():
    struct_subst_0 = module_0.struct_subst()
    assert f'{type(struct_subst_0.regx).__module__}.{type(struct_subst_0.regx).__qualname__}' == 'sedparse.struct_regex'
    assert f'{type(struct_subst_0.replacement).__module__}.{type(struct_subst_0.replacement).__qualname__}' == 'sedparse.struct_replacement'
    assert f'{type(struct_subst_0.outf).__module__}.{type(struct_subst_0.outf).__qualname__}' == 'sedparse.struct_output'
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_subst_0.__str__()
    assert var_0 == ''
    var_1 = struct_subst_0.__repr__()
    assert var_1 == "struct_subst(regx=struct_regex(slash='', pattern='', flags=''), replacement=struct_replacement(text=''), outf=struct_output(name=''))"
    var_2 = module_0.compile_program(struct_subst_0)
    struct_text_buf_0 = module_0.struct_text_buf()
    assert struct_text_buf_0.text == []
    var_3 = module_0.snarf_char_class(var_0)
    assert var_3 == '<EOF>'
    var_4 = module_0.read_filename()
    var_5 = module_0.read_text(var_4, var_3)
    var_6 = module_0.read_filename()
    var_7 = struct_subst_0.to_json()
    assert var_7 == '{}'
    var_8 = module_0.mark_subst_opts(var_1)

def test_case_67():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.pending_text is None
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    with pytest.raises(module_0.ParseError):
        module_0.bad_prog(struct_regex_0)

def test_case_68():
    var_0 = module_0.struct_replacement()
    assert var_0.text == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    with pytest.raises(module_0.ParseError):
        module_0.bad_prog(var_0)

@pytest.mark.xfail(strict=True)
def test_case_69():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_regex_0.to_dict()
    var_1 = struct_regex_0.__str__()
    assert var_1 == '\\'
    module_0.compile_string(var_1, var_1)
    var_3 = module_0.compile_string(struct_regex_0, var_2)

def test_case_70():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_71():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.read_filename()
    var_2 = module_0.compile_string(var_1, var_0)
    var_3 = module_0.compile_program(var_0)

def test_case_72():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

def test_case_73():
    var_0 = module_0.read_filename()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_74():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_75():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_0 = struct_regex_0.to_dict()
    var_1 = module_0.snarf_char_class(var_0)
    assert var_1 == '<EOF>'

def test_case_76():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_77():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_78():
    var_0 = module_0.read_end_of_cmd()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'

@pytest.mark.xfail(strict=True)
def test_case_79():
    var_0 = module_0.read_comment()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    var_1 = module_0.compile_string(var_0, var_0)
    module_0.compile_string(var_1, var_1)

def test_case_80():
    module_0.read_comment()
    var_1 = module_0.snarf_char_class(var_0)
    var_2 = module_0.mark_subst_opts(var_1)

@pytest.mark.xfail(strict=True)
def test_case_81():
    var_0 = module_1.RegexFlag.DEBUG
    module_0.mark_subst_opts(var_0)

def test_case_82():
    module_0.read_comment()
    var_1 = module_0.compile_string(var_0, var_0)

def test_case_83():
    module_0.read_comment()
    var_1 = module_0.snarf_char_class(var_0)
    var_2 = module_0.compile_string(var_0, var_0)

def test_case_84():
    module_0.read_filename()
    var_1 = module_0.snarf_char_class(var_0)
    var_2 = module_0.compile_regex(var_1, var_1)
    var_3 = var_2.__str__()
    var_4 = module_0.compile_string(var_0, var_3)

def test_case_85():
    module_0.read_comment()
    var_1 = module_0.snarf_char_class(var_0)
    none_type_0 = None
    var_2 = module_0.compile_string(none_type_0, var_1)

@pytest.mark.xfail(strict=True)
def test_case_86():
    module_0.read_label()
    struct_addr_0 = module_0.struct_addr()
    struct_regex_0 = module_0.struct_regex()
    var_0 = module_0.read_filename()
    var_1 = struct_regex_0.to_json()
    var_2 = module_0.compile_string(var_0, var_0)
    tuple_0 = (var_1,)
    var_3 = module_0.mark_subst_opts(tuple_0)

def test_case_87():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    module_0.read_filename()
    var_0 = struct_regex_0.to_json()
    var_2 = module_0.compile_string(var_1, var_1)

def test_case_88():
    struct_regex_0 = module_0.struct_regex()
    assert struct_regex_0.pattern == ''
    assert struct_regex_0.flags == ''
    assert struct_regex_0.slash == ''
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'
    module_0.snarf_char_class(struct_regex_0)

def test_case_89():
    var_0 = module_0.check_final_program()
    assert module_0.EOF == '<EOF>'
    assert module_0.JSON_OPTS == {'indent': 4, 'sort_keys': True, 'separators': (',', ': ')}
    assert module_0.program_name == 'sedparse'
    assert module_0.ADDR_IS_NULL == 1
    assert module_0.ADDR_IS_REGEX == 2
    assert module_0.ADDR_IS_NUM == 3
    assert module_0.ADDR_IS_NUM_MOD == 4
    assert module_0.ADDR_IS_STEP == 5
    assert module_0.ADDR_IS_STEP_MOD == 6
    assert module_0.ADDR_IS_LAST == 7
    assert module_0.EXIT_SUCCESS == 0
    assert module_0.EXIT_BAD_USAGE == 1
    assert module_0.EXIT_PANIC == 4
    assert module_0.OPEN_BRACKET == '['
    assert module_0.CLOSE_BRACKET == ']'
    assert module_0.CLOSE_BRACE == '}'
    assert module_0.blocks == 0
    assert module_0.BAD_BANG == "multiple `!'s"
    assert module_0.BAD_COMMA == "unexpected `,'"
    assert module_0.BAD_STEP == 'invalid usage of +N or ~N as first address'
    assert module_0.EXCESS_OPEN_BRACE == "unmatched `{'"
    assert module_0.EXCESS_CLOSE_BRACE == "unexpected `}'"
    assert module_0.EXCESS_JUNK == 'extra characters after command'
    assert module_0.EXPECTED_SLASH == "expected \\ after `a', `c' or `i'"
    assert module_0.NO_CLOSE_BRACE_ADDR == "`}' doesn't want any addresses"
    assert module_0.NO_COMMAND == 'missing command'
    assert module_0.UNTERM_ADDR_RE == 'unterminated address regex'
    assert module_0.UNTERM_S_CMD == "unterminated `s' command"
    assert module_0.UNTERM_Y_CMD == "unterminated `y' command"
    assert module_0.UNKNOWN_S_OPT == "unknown option to `s'"
    assert module_0.EXCESS_P_OPT == "multiple `p' options to `s' command"
    assert module_0.EXCESS_G_OPT == "multiple `g' options to `s' command"
    assert module_0.EXCESS_N_OPT == "multiple number options to `s' command"
    assert module_0.ZERO_N_OPT == "number option to `s' command may not be zero"
    assert module_0.BAD_DELIM == 'delimiter character is not a single-byte character'
    assert module_0.INVALID_LINE_0 == 'invalid usage of line address 0'
    assert module_0.UNKNOWN_CMD == "unknown command: `%c'"
    assert module_0.COLON_LACKS_LABEL == '":" lacks a label'
    assert module_0.MISSING_FILENAME == 'missing filename in r/R/w/W commands'