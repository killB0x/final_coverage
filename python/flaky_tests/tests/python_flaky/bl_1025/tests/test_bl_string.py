# Automatically generated by Pynguin.
import pytest
import bl.string as module_0
import urllib.parse as module_1

def test_case_0():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}

def test_case_1():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    none_type_0 = None
    var_2 = string_0.titleify(none_type_0)
    var_3 = string_0.rematch(string_0)
    var_4 = var_1.format_map(string_0)
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'

@pytest.mark.xfail(strict=True)
def test_case_2():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.titleify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = var_0.strip()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = string_0.__add__(var_1)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 1
    var_2.center()

@pytest.mark.xfail(strict=True)
def test_case_3():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.__contains__(var_0)
    var_3 = var_0.split(var_0)
    var_4 = var_3.__repr__()
    var_5 = var_0.__gt__(var_3)
    var_6 = var_0.__lt__(var_2)
    var_0.find(var_3, *var_0)

def test_case_4():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.titleify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1

@pytest.mark.xfail(strict=True)
def test_case_5():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.rfind(string_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = string_0.rindex(string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = module_1.splitvalue(var_0)
    var_3 = string_0.hyphenify(var_2)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 0
    var_4 = var_3.format()
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'
    assert len(var_4) == 0
    var_2.casefold()

@pytest.mark.xfail(strict=True)
def test_case_6():
    float_0 = -963.7
    list_0 = [float_0]
    string_0 = module_0.String(*list_0)
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.camelsplit()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 6
    string_0.rindex(float_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = string_0.camelify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.titleify()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    string_0.rjust(var_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    none_type_0 = None
    var_2 = var_0.__contains__(var_0)
    var_3 = string_0.titleify(none_type_0)
    var_4 = string_0.rematch(string_0)
    var_5 = var_0.rstrip()
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'
    var_4.titleify()

@pytest.mark.xfail(strict=True)
def test_case_9():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    none_type_0 = None
    var_0 = string_0.title()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.translate(none_type_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    var_2 = string_0.title()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    var_2.scan(string_0)

def test_case_10():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    none_type_0 = None
    var_2 = var_0.__contains__(var_0)
    var_3 = string_0.titleify(none_type_0)
    var_4 = string_0.rematch(string_0)
    var_5 = var_0.zfill(var_2)
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'

def test_case_11():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.rsplit()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 2
    var_1 = var_0.titleify(lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 2

def test_case_12():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.__contains__(var_0)
    var_3 = string_0.titleify(var_0)
    var_4 = var_3.format_map(var_2)
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'

def test_case_13():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.lower()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'

@pytest.mark.xfail(strict=True)
def test_case_14():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.rfind(string_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = string_0.rindex(string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = var_0.base64()
    assert var_2 == b'MA=='
    var_3 = module_1.splitvalue(var_0)
    var_3.casefold()

@pytest.mark.xfail(strict=True)
def test_case_15():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = var_0.__contains__(var_0)
    none_type_0 = None
    var_2 = var_0.__contains__(var_0)
    var_3 = string_0.titleify(none_type_0)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 0
    var_4 = string_0.capitalize()
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'
    var_5 = var_2.__rmod__(var_2)
    var_6 = var_3.hyphenify()
    assert f'{type(var_6).__module__}.{type(var_6).__qualname__}' == 'bl.string.String'
    assert len(var_6) == 0
    var_1.rematch(string_0)

@pytest.mark.xfail(strict=True)
def test_case_16():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.swapcase()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_0.pop()

def test_case_17():
    float_0 = -963.7
    list_0 = [float_0]
    string_0 = module_0.String(*list_0)
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.camelsplit()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 6

@pytest.mark.xfail(strict=True)
def test_case_18():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_1.resplit(var_1)
    var_1.partition(var_1)

@pytest.mark.xfail(strict=True)
def test_case_19():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.__contains__(var_0)
    var_3 = var_0.split(var_0)
    var_0.rematch(var_0, var_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.titleify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = string_0.camelify()
    var_3 = var_2.strip()
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    var_3.remove(string_0)

@pytest.mark.xfail(strict=True)
def test_case_21():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.resub(string_0, string_0)
    var_1 = var_0.splitlines()
    var_2 = string_0.digest()
    assert var_2 == '47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU'
    var_3 = var_0.base64()
    assert var_3 == b''
    var_4 = string_0.upper()
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'
    var_5 = string_0.identifier(var_0)
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'
    assert len(var_5) == 1
    var_6 = var_2.upper()
    assert var_6 == '47DEQPJ8HBSA-_TIMW-5JCEUQERKM5NMPJWZG3HSUFU'
    var_7 = var_5.__iter__()
    var_1.__missing__(var_7)

@pytest.mark.xfail(strict=True)
def test_case_22():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.rindex(var_0, *var_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = module_1.unquote(var_1)
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = var_2.base64()
    assert var_3 == b'MA=='
    var_4 = module_1.splitvalue(string_0)
    var_5 = var_2.casefold()
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'
    string_0.resplit(string_0, string_0)

@pytest.mark.xfail(strict=True)
def test_case_23():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.camelsplit()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = string_0.digest()
    assert var_2 == '47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU'
    var_3 = var_0.encode()
    assert var_3 == b'_'
    var_4 = var_0.titleify(lastword=var_0)
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'
    assert len(var_4) == 1
    var_5 = var_3.swapcase()
    assert var_5 == b'_'
    module_1.splitnport(var_5)

@pytest.mark.xfail(strict=True)
def test_case_24():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    none_type_0 = None
    var_2 = var_0.__contains__(var_0)
    var_3 = string_0.titleify(none_type_0)
    var_4 = string_0.rematch(string_0)
    var_5 = var_0.zfill(var_2)
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'
    var_5.index(var_2)

@pytest.mark.xfail(strict=True)
def test_case_25():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    none_type_0 = None
    string_0.join(none_type_0)

def test_case_26():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.titleify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = var_0.strip()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1

@pytest.mark.xfail(strict=True)
def test_case_27():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.upper()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    var_1 = string_0.titleify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = string_0.titleify(var_0, lastword=string_0)
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 0
    var_3 = var_0.__contains__(string_0)
    string_0.titleify(asis=var_3)

@pytest.mark.xfail(strict=True)
def test_case_28():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.camelify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 0
    var_1 = string_0.hyphenify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_1.lstrip()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 0
    string_0.zfill(var_2)

@pytest.mark.xfail(strict=True)
def test_case_29():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.splitlines()
    var_2 = string_0.camelify()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 0
    var_3 = string_0.hyphenify()
    assert len(var_3) == 0
    string_0.zfill(var_3)

@pytest.mark.xfail(strict=True)
def test_case_30():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    string_0.ljust(string_0)

@pytest.mark.xfail(strict=True)
def test_case_31():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.words()
    var_1 = string_0.rsplit()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 2
    var_2 = var_1.tagify()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = var_1.titleify(lastword=var_2)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 2
    var_0.strip()

@pytest.mark.xfail(strict=True)
def test_case_32():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = string_0.camelify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.titleify()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    none_type_0 = None
    module_1.parse_qs(var_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_33():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    set_0 = {var_0, var_0}
    string_0.research(var_0, set_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.camelify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = string_0.titleify(allwords=var_1, asis=var_1)
    var_0.rjust(string_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = string_0.camelify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 0
    var_2 = var_0.expandtabs()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = var_1.encode()
    string_0.rjust(var_0)

@pytest.mark.xfail(strict=True)
def test_case_36():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.tagify()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.camelsplit()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 1
    var_2 = var_1.nameify(var_0)
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = string_0.camelify()
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 0
    var_4 = var_0.__repr__()
    assert var_4 == "'_'"
    var_5 = var_1.swapcase()
    assert f'{type(var_5).__module__}.{type(var_5).__qualname__}' == 'bl.string.String'
    assert len(var_5) == 1
    var_6 = module_1.splitnport(var_2)
    var_1.__getitem__(var_5)

@pytest.mark.xfail(strict=True)
def test_case_37():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.words()
    var_1 = string_0.refindall(string_0)
    var_1.camelsplit()

@pytest.mark.xfail(strict=True)
def test_case_38():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.words()
    var_1 = string_0.rsplit()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 2
    var_2 = var_1.camelsplit()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 2
    var_3 = var_2.nameify(var_0)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 1
    string_1 = module_0.String(*var_3)
    assert f'{type(string_1).__module__}.{type(string_1).__qualname__}' == 'bl.string.String'
    assert len(string_1) == 1
    var_4 = string_1.digest(strip=string_1)
    assert var_4 == '0uKt9xd7eor928EtFjTPI-oacQIPahMIBwoWQA-2j94='
    var_5 = string_0.splitlines()
    var_6 = string_0.camelify()
    assert f'{type(var_6).__module__}.{type(var_6).__qualname__}' == 'bl.string.String'
    assert len(var_6) == 0
    var_7 = var_1.encode()
    var_8 = var_1.titleify(lastword=var_1)
    assert f'{type(var_8).__module__}.{type(var_8).__qualname__}' == 'bl.string.String'
    assert len(var_8) == 2
    var_9 = var_8.__lt__(var_7)
    var_7.camelify()

@pytest.mark.xfail(strict=True)
def test_case_39():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.rfind(string_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.tagify()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bl.string.String'
    assert len(var_1) == 2
    var_2 = var_1.camelsplit()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 2
    var_3 = var_0.camelify()
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 1
    var_4 = var_0.encode()
    var_0.clear()

@pytest.mark.xfail(strict=True)
def test_case_40():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    string_0.resubn(string_0, string_0, string_0, string_0)

def test_case_41():
    float_0 = -963.7
    list_0 = [float_0]
    string_0 = module_0.String(*list_0)
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.camelsplit()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 6
    var_1 = var_0.digest(b64=float_0)
    assert var_1 == 'ba2c3628f92345e4411c611589688275efebf28be8dd79c10c4022ff8757f68e'

@pytest.mark.xfail(strict=True)
def test_case_42():
    string_0 = module_0.String()
    assert module_0.LOWERCASE_WORDS == {'en': ['a', 'an', 'the', 'and', 'or', 'nor', 'for', 'but', 'than', 'because', 'vs', 'to', 'in', 'on', 'off', 'from', 'at', 'of', 'by', 'under', 'over', 'through', 'with', 'against', 'about', 'across', 'aboard', 'above', 'according', 'after', 'along', 'alongside', 'amid', 'among', 'apart', 'around', 'beneath', 'beyond', 'below', 'beside', 'behind', 'before', 'between', 'concerning', 'despite', 'during', 'into', 'near', 'onto', 'throughout', 'toward', 'until', 'unto', 'upon', 'versus', 'via', 'within', 'without', 's', 'amp', 'n', 'v', 'adj', 'adv', 'prep', 'ed', 'ing', 'eth', 'th']}
    var_0 = string_0.rfind(string_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bl.string.String'
    assert len(var_0) == 1
    var_1 = var_0.__contains__(var_0)
    assert var_1 is True
    var_2 = string_0.tagify()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bl.string.String'
    assert len(var_2) == 1
    var_3 = var_2.camelsplit()
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bl.string.String'
    assert len(var_3) == 1
    var_4 = var_3.nameify(var_1)
    assert f'{type(var_4).__module__}.{type(var_4).__qualname__}' == 'bl.string.String'
    assert len(var_4) == 1
    var_5 = string_0.splitlines()
    var_6 = string_0.camelify()
    assert f'{type(var_6).__module__}.{type(var_6).__qualname__}' == 'bl.string.String'
    assert len(var_6) == 0
    var_7 = var_2.encode()
    assert var_7 == b'_'
    var_8 = var_2.titleify(lastword=var_2)
    assert f'{type(var_8).__module__}.{type(var_8).__qualname__}' == 'bl.string.String'
    assert len(var_8) == 1
    none_type_0 = None
    var_1.split(none_type_0)