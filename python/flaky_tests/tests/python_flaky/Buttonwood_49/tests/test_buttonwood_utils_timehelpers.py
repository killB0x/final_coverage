# Automatically generated by Pynguin.
import pytest
import buttonwood.utils.timehelpers as module_0
import builtins as module_1
import datetime as module_2

def test_case_0():
    int_0 = 473
    with pytest.raises(AssertionError):
        module_0.timestamp_to_epoch(int_0)

def test_case_1():
    int_0 = -3703
    with pytest.raises(AssertionError):
        module_0.datetime_to_epoch(int_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    str_0 = '9up'
    module_0.timestamp_to_epoch(str_0)

def test_case_3():
    list_0 = []
    with pytest.raises(AssertionError):
        module_0.timestamp_to_datetime(list_0)

def test_case_4():
    float_0 = 0.0
    var_0 = module_0.epoch_to_datetime(float_0)
    assert module_0.DATE_TEMPLATE == '%Y%m%d'
    assert module_0.TIME_TEMPLATE == '%H:%M:%S.%f'
    assert module_0.DATETIME_TEMPLATE == '%Y%m%d-%H:%M:%S.%f'
    bool_0 = True
    with pytest.raises(AssertionError):
        module_0.epoch_to_timestamp(bool_0)

def test_case_5():
    none_type_0 = None
    with pytest.raises(AssertionError):
        module_0.epoch_to_datetime(none_type_0)

def test_case_6():
    str_0 = "\n        The initializer of the base OrderEvent class.\n\n        While it seems like one wouldn't need product, it is great to have here\n         for filtering, comparisons, etc.\n\n        `other_key_values` is used for keeping key/value pairs around that don't\n         fit the defined arguments. This is an quick and easy way to track meta\n         data that a particular matching venue uses/keeps without having to\n         create custom versions of the OrderEvent just to keep this data.\n\n        :param event_id: unique identifier of the event\n        :param timestamp: float. microsecond time stamp of event. Expecting format of seconds.microseconds (ex: 1234.001123)\n        :param chain_id: str or int. the unique identifier fo the orderchain\n        :param user_id: str or int. unique identifier of the user who sent the command\n        :param market: MarketObjects.Market\n        :param other_key_values: dict\n        "
    with pytest.raises(AssertionError):
        module_0.epoch_to_timestamp(str_0)

def test_case_7():
    int_0 = -3703
    var_0 = module_0.millis_string(int_0)
    assert var_0 == '-3703.000'
    assert module_0.DATE_TEMPLATE == '%Y%m%d'
    assert module_0.TIME_TEMPLATE == '%H:%M:%S.%f'
    assert module_0.DATETIME_TEMPLATE == '%Y%m%d-%H:%M:%S.%f'
    with pytest.raises(AssertionError):
        module_0.epoch_to_timestamp(var_0)

def test_case_8():
    bool_0 = False
    var_0 = module_0.mics_string(bool_0)
    assert var_0 == '0.000000'
    assert module_0.DATE_TEMPLATE == '%Y%m%d'
    assert module_0.TIME_TEMPLATE == '%H:%M:%S.%f'
    assert module_0.DATETIME_TEMPLATE == '%Y%m%d-%H:%M:%S.%f'
    with pytest.raises(AssertionError):
        module_0.timestamp_to_datetime(bool_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    float_0 = -337.5436
    var_0 = module_0.epoch_to_timestamp(float_0)
    assert var_0 == '19691231-23:54:22.456400'
    assert module_0.DATE_TEMPLATE == '%Y%m%d'
    assert module_0.TIME_TEMPLATE == '%H:%M:%S.%f'
    assert module_0.DATETIME_TEMPLATE == '%Y%m%d-%H:%M:%S.%f'
    object_0 = module_1.object()
    bool_0 = True
    var_1 = module_0.millis_string(bool_0)
    assert var_1 == '1.000'
    module_2.datetime()

def test_case_10():
    bool_0 = False
    float_0 = -2691.8
    var_0 = module_0.epoch_to_timestamp(float_0)
    assert var_0 == '19691231-23:15:08.200000'
    assert module_0.DATE_TEMPLATE == '%Y%m%d'
    assert module_0.TIME_TEMPLATE == '%H:%M:%S.%f'
    assert module_0.DATETIME_TEMPLATE == '%Y%m%d-%H:%M:%S.%f'
    var_1 = module_0.timestamp_to_epoch(var_0)
    assert var_1 == pytest.approx(-2691.8, abs=0.01, rel=0.01)
    with pytest.raises(AssertionError):
        module_0.datetime_to_epoch(bool_0)