# Automatically generated by Pynguin.
import pytest
import authnzerver.actions.loginlogout as module_0
import platform as module_1

@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    module_0.auth_user_login(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_1():
    none_type_0 = None
    module_0.auth_user_logout(none_type_0, raiseonfail=none_type_0)

def test_case_2():
    var_0 = module_1.python_revision()
    var_1 = module_0.auth_user_login(var_0)

def test_case_3():
    str_0 = 'e"\\\x0bQPgG`\'\'WQ kj0J'
    var_0 = module_0.auth_user_logout(str_0, config=str_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    str_0 = '^#FyCM+'
    str_1 = "Makes a new user.\n\n    Parameters\n    ----------\n\n    payload : dict\n        This is a dict with the following required keys:\n\n        - full_name: str. Full name for the user\n\n        - email: str. User's email address\n\n        - password: str. User's password.\n\n        - extra_info: dict or None. optional dict to add any extra info for this\n          user, will be stored as JSON in the DB\n\n        In addition to these items received from an authnzerver client, the\n        payload must also include the following keys (usually added in by a\n        wrapping function):\n\n        - reqid: int or str\n        - pii_salt: str\n\n    override_authdb_path : str or None\n        If given as a str, is the alternative path to the auth DB.\n\n    raiseonfail : bool\n        If True, will raise an Exception if something goes wrong.\n\n    min_pass_length : int\n        The minimum required character length of the password.\n\n    max_unsafe_similarity : int\n        The maximum ratio required to fuzzy-match the input password against\n        the server's domain name, the user's email, or their name.\n\n    config : SimpleNamespace object or None\n        An object containing systemwide config variables as attributes. This is\n        useful when the wrapping function needs to pass in some settings\n        directly from environment variables.\n\n    Returns\n    -------\n\n    dict\n        Returns a dict with the user's user_id and user_email, and a boolean for\n        send_verification.\n\n    Notes\n    -----\n\n    If the email address already exists in the database, then either the user\n    has forgotten that they have an account or someone else is being\n    annoying. In this case, if is_active is True, we'll tell the user that we've\n    sent an email but won't do anything. If is_active is False and\n    emailverify_sent_datetime is at least 24 hours in the past, we'll send a new\n    email verification email and update the emailverify_sent_datetime. In this\n    case, we'll just tell the user that we've sent the email but won't tell them\n    if their account exists.\n\n    Only after the user verifies their email, is_active will be set to True and\n    user_role will be set to 'authenticated'.\n\n    "
    module_0.auth_user_logout(str_1, config=str_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    str_0 = '/6xY39zGYje93,v/P\\m'
    var_0 = module_0.auth_user_logout(str_0, str_0, config=str_0)
    str_1 = 'e"\\\x0bQPgG`\'\'WQ kj0J'
    var_1 = var_0.__repr__()
    assert var_1 == '{\'success\': False, \'failure_reason\': "invalid request: missing \'reqid\' in request", \'user_id\': None, \'messages\': [\'Invalid user logout request.\']}'
    var_2 = module_0.auth_user_login(var_1, var_1)
    var_2.itermonthdays2(var_0, str_1)

@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = '/6xY39zGYje93,v/P\\m'
    var_0 = module_0.auth_user_logout(str_0, str_0)
    str_1 = "Makes a new user.\n\n    Parameters\n    ----------\n\n    payload : dict\n        This is a dict with the following required keys:\n\n        - full_name: str. Full name for the user\n\n        - email: str. User's email address\n\n        - password: str. User's password.\n\n        - extra_info: dict or None. optional dict to add any extra info for this\n          user, will be stored as JSON in the DB\n\n        In addition to these items received from an authnzerver client, the\n        payload must also include the following keys (usually added in by a\n        wrapping function):\n\n        - reqid: int or str\n        - pii_salt: str\n\n    override_authdb_path : str or None\n        If given as a str, is the alternative path to the auth DB.\n\n    raiseonfail : bool\n        If True, will raise an Exception if something goes wrong.\n\n    min_pass_length : int\n        The minimum required character length of the password.\n\n    max_unsafe_similarity : int\n        The maximum ratio required to fuzzy-match the input password against\n        the server's domain name, the user's email, or their name.\n\n    config : SimpleNamespace object or None\n        An object containing systemwide config variables as attributes. This is\n        useful when the wrapping function needs to pass in some settings\n        directly from environment variables.\n\n    Returns\n    -------\n\n    dict\n        Returns a dict with the user's user_id and user_email, and a boolean for\n        send_verification.\n\n    Notes\n    -----\n\n    If the email address already exists in the database, then either the user\n    has forgotten that they have an account or someone else is being\n    annoying. In this case, if is_active is True, we'll tell the user that we've\n    sent an email but won't do anything. If is_active is False and\n    emailverify_sent_datetime is at least 24 hours in the past, we'll send a new\n    email verification email and update the emailverify_sent_datetime. In this\n    case, we'll just tell the user that we've sent the email but won't tell them\n    if their account exists.\n\n    Only after the user verifies their email, is_active will be set to True and\n    user_role will be set to 'authenticated'.\n\n    "
    module_0.auth_user_login(str_1, raiseonfail=var_0)