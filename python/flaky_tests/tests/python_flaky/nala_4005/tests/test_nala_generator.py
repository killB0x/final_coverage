# Automatically generated by Pynguin.
import pytest
import nala.generator as module_0
import nala.inspect as module_1
import re as module_2

@pytest.mark.xfail(strict=True)
def test_case_0():
    str_0 = ''
    module_0.rename_return_type(str_0, str_0)

def test_case_1():
    str_0 = "41';m)SxjLU<\x0cL"
    var_0 = module_0.create_implementation_params(str_0)

def test_case_2():
    file_generator_0 = module_0.FileGenerator()
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None

def test_case_3():
    var_0 = module_0.read_nala_c()
    assert var_0 == '#include <execinfo.h>\n\n#define MODE_REAL            0\n#define MODE_MOCK_ONCE       1\n#define MODE_IMPLEMENTATION  2\n#define MODE_MOCK            3\n#define MODE_NONE            4\n\n#define INSTANCE_MODE_NORMAL  0\n#define INSTANCE_MODE_REAL    1\n\nconst char *nala_mock_func_p = NULL;\nconst char *nala_mock_param_p = NULL;\nstruct nala_traceback_t *nala_mock_traceback_p = NULL;\n\n#define NALA_INSTANCE_NEW(instance_p, mode_in)          \\\n    do {                                                \\\n        instance_p = nala_alloc(sizeof(*instance_p)); \\\n        instance_p->mode = mode_in;                     \\\n        instance_p->handle = nala_next_handle++;        \\\n        instance_p->next_p = NULL;                      \\\n        nala_traceback(&instance_p->data.traceback);    \\\n    } while (0);\n\n#define NALA_INSTANCES_APPEND(list, item_p)     \\\n    do {                                        \\\n        if ((list).head_p == NULL) {            \\\n            (list).head_p = item_p;             \\\n        } else {                                \\\n            (list).tail_p->next_p = item_p;     \\\n        }                                       \\\n                                                \\\n        if ((list).next_p == NULL) {            \\\n            (list).next_p = item_p;             \\\n        }                                       \\\n                                                \\\n        (list).tail_p = item_p;                 \\\n        (list).length++;                        \\\n    } while (0);\n\n#define NALA_INSTANCES_POP(list, instance_pp)           \\\n    do {                                                \\\n        *(instance_pp) = (list).next_p;                 \\\n                                                        \\\n        if (*(instance_pp) != NULL) {                   \\\n            (list).next_p = (*(instance_pp))->next_p;   \\\n                                                        \\\n            if ((*(instance_pp))->next_p == NULL) {     \\\n                (list).next_p = NULL;                   \\\n            }                                           \\\n                                                        \\\n            (list).length--;                            \\\n        }                                               \\\n    } while (0);\n\n#define NALA_INSTANCES_DESTROY(list)            \\\n    do {                                        \\\n        (list).head_p = NULL;                   \\\n        (list).next_p = NULL;                   \\\n        (list).tail_p = NULL;                   \\\n        (list).length = 0;                      \\\n    } while (0);\n\n#define NALA_INSTANCES_FIND_USED(list, instance_pp, handle_in)  \\\n    do {                                                        \\\n        *(instance_pp) = (list).head_p;                         \\\n                                                                \\\n        while (*(instance_pp) != NULL) {                        \\\n            if (*(instance_pp) == (list).next_p) {              \\\n                *(instance_pp) = NULL;                          \\\n                break;                                          \\\n            }                                                   \\\n                                                                \\\n            if ((*(instance_pp))->handle == handle_in) {        \\\n                break;                                          \\\n            }                                                   \\\n                                                                \\\n            *(instance_pp) = (*(instance_pp))->next_p;          \\\n        }                                                       \\\n    } while (0);\n\n#define CHECK_NO_INSTANCES(state)                                       \\\n    if ((state).instances.next_p != NULL) {                             \\\n        nala_test_failure(                                              \\\n            nala_format(                                                \\\n                "Cannot change mock mode with mock instances enqueued.\\n")); \\\n    }\n\n#define NALA_STATE_RESET(_state)                \\\n    (_state).state.mode = MODE_REAL;            \\\n    (_state).state.suspended.count = 0;         \\\n    NALA_INSTANCES_DESTROY((_state).instances)\n\nstruct nala_set_param {\n    void *buf_p;\n    size_t size;\n};\n\nchar *nala_format_mock_traceback(const char *message_p,\n                                 struct nala_traceback_t *traceback_p)\n{\n    FILE *file_p;\n    char *buf_p;\n    size_t file_size;\n    char *formatted_traceback_p;\n\n    nala_suspend_all_mocks();\n\n    if (traceback_p != NULL) {\n        formatted_traceback_p = nala_mock_traceback_format(\n            &traceback_p->addresses[0],\n            traceback_p->depth);\n    } else {\n        formatted_traceback_p = strdup("  Traceback missing.\\n");\n    }\n\n    file_p = open_memstream(&buf_p, &file_size);\n    fprintf(file_p, "%s%s", message_p, formatted_traceback_p);\n    fputc(\'\\0\', file_p);\n    fclose(file_p);\n    free((void *)message_p);\n    free(formatted_traceback_p);\n\n    nala_resume_all_mocks();\n\n    return (buf_p);\n}\n\n#define NALA_MOCK_ASSERT_IN_EQ_FUNC(value)                      \\\n    _Generic((value),                                           \\\n             char: nala_mock_assert_in_eq_char,                 \\\n             signed char: nala_mock_assert_in_eq_schar,         \\\n             unsigned char: nala_mock_assert_in_eq_uchar,       \\\n             short: nala_mock_assert_in_eq_short,               \\\n             unsigned short: nala_mock_assert_in_eq_ushort,     \\\n             int: nala_mock_assert_in_eq_int,                   \\\n             unsigned int: nala_mock_assert_in_eq_uint,         \\\n             long: nala_mock_assert_in_eq_long,                 \\\n             unsigned long: nala_mock_assert_in_eq_ulong,       \\\n             long long: nala_mock_assert_in_eq_llong,           \\\n             unsigned long long: nala_mock_assert_in_eq_ullong, \\\n             float: nala_mock_assert_in_eq_float,               \\\n             double: nala_mock_assert_in_eq_double,             \\\n             long double: nala_mock_assert_in_eq_ldouble,       \\\n             bool: nala_mock_assert_in_eq_bool,                 \\\n             default: nala_mock_assert_in_eq_ptr)\n\n#define PRINT_FORMAT(value)                             \\\n    _Generic((value),                                   \\\n             char: "%c",                                \\\n             signed char: "%hhd",                       \\\n             unsigned char: "%hhu",                     \\\n             signed short: "%hd",                       \\\n             unsigned short: "%hu",                     \\\n             signed int: "%d",                          \\\n             unsigned int: "%u",                        \\\n             long int: "%ld",                           \\\n             unsigned long int: "%lu",                  \\\n             long long int: "%lld",                     \\\n             unsigned long long int: "%llu",            \\\n             float: "%f",                               \\\n             double: "%f",                              \\\n             long double: "%Lf",                        \\\n             bool: "%d",                                \\\n             default: "%p")\n\n#define PRINT_FORMAT_HEX(value)                 \\\n    _Generic((value),                           \\\n             signed char: "%hhx",               \\\n             unsigned char: "%hhx",             \\\n             signed short: "%hx",               \\\n             unsigned short: "%hx",             \\\n             signed int: "%x",                  \\\n             unsigned int: "%x",                \\\n             long int: "%lx",                   \\\n             unsigned long int: "%lx",          \\\n             long long int: "%llx",             \\\n             unsigned long long int: "%llx")\n\n#define MOCK_BINARY_ASSERTION(traceback_p,                              \\\n                              func_p,                                   \\\n                              param_p,                                  \\\n                              ignore_in,                                \\\n                              actual,                                   \\\n                              expecetd)                                 \\\n    if (!(ignore_in)) {                                                 \\\n        if ((actual) != (expecetd)) {                                   \\\n            char assert_format[512];                                    \\\n            nala_suspend_all_mocks();                                   \\\n            snprintf(&assert_format[0],                                 \\\n                     sizeof(assert_format),                             \\\n                     "Mocked %s(%s): %s is not equal to %s\\n\\n",        \\\n                     func_p,                                            \\\n                     param_p,                                           \\\n                     PRINT_FORMAT(actual),                              \\\n                     PRINT_FORMAT(expecetd));                           \\\n            nala_test_failure(                                          \\\n                nala_format_mock_traceback(                             \\\n                    nala_format(&assert_format[0],                      \\\n                                (actual),                               \\\n                                (expecetd)),                            \\\n                    traceback_p));                                      \\\n        }                                                               \\\n    }\n\n#define MOCK_BINARY_ASSERTION_HEX(traceback_p,                          \\\n                                  func_p,                               \\\n                                  param_p,                              \\\n                                  ignore_in,                            \\\n                                  actual,                               \\\n                                  expecetd)                             \\\n    if (!(ignore_in)) {                                                 \\\n        if ((actual) != (expecetd)) {                                   \\\n            char assert_format[512];                                    \\\n            nala_suspend_all_mocks();                                   \\\n            snprintf(&assert_format[0],                                 \\\n                     sizeof(assert_format),                             \\\n                     "Mocked %s(%s): %s is not equal to %s (0x%s, 0x%s)\\n\\n", \\\n                     func_p,                                            \\\n                     param_p,                                           \\\n                     PRINT_FORMAT(actual),                              \\\n                     PRINT_FORMAT(expecetd),                            \\\n                     PRINT_FORMAT_HEX(actual),                          \\\n                     PRINT_FORMAT_HEX(expecetd));                       \\\n            nala_test_failure(                                          \\\n                nala_format_mock_traceback(                             \\\n                    nala_format(&assert_format[0],                      \\\n                                (actual),                               \\\n                                (expecetd),                             \\\n                                (actual),                               \\\n                                (expecetd)),                            \\\n                    traceback_p));                                      \\\n        }                                                               \\\n    }\n\n#define MOCK_ASSERT_IN_EQ(data_p, func, param)          \\\n    NALA_MOCK_ASSERT_IN_EQ_FUNC(param)(                 \\\n        &(data_p)->traceback,                           \\\n        #func,                                          \\\n        #param,                                         \\\n        (data_p)->params.ignore_ ## param ## _in,       \\\n        param,                                          \\\n        (data_p)->params.param)\n\n#define MOCK_ASSERT_POINTERS_IN_EQ(data_p, func, param)         \\\n    nala_mock_assert_in_eq_ptr(                                 \\\n        &(data_p)->traceback,                                   \\\n        #func,                                                  \\\n        #param,                                                 \\\n        (data_p)->params.ignore_ ## param ## _in,               \\\n        (const void *)(uintptr_t)param,                         \\\n        (const void *)(uintptr_t)(data_p)->params.param)\n\nvoid nala_mock_assert_memory(struct nala_traceback_t *traceback_p,\n                             const char *func_p,\n                             const char *param_p,\n                             const void *left_p,\n                             const void *right_p,\n                             size_t size)\n{\n    char assert_format[512];\n\n    if (!nala_check_memory(left_p, right_p, size)) {\n        nala_suspend_all_mocks();\n        snprintf(&assert_format[0],\n                 sizeof(assert_format),\n                 "Mocked %s(%s): ",\n                 func_p,\n                 param_p);\n        nala_test_failure(\n            nala_format_mock_traceback(\n                nala_format_memory(\n                    &assert_format[0],\n                    left_p,\n                    right_p,\n                    size),\n                traceback_p));\n    }\n}\n\nvoid nala_mock_assert_string(struct nala_traceback_t *traceback_p,\n                             const char *func_p,\n                             const char *param_p,\n                             const char *acutal_p,\n                             const char *expected_p,\n                             size_t size)\n{\n    (void)size;\n\n    char assert_format[512];\n\n    if (!nala_check_string_equal(acutal_p, expected_p)) {\n        nala_suspend_all_mocks();\n        snprintf(&assert_format[0],\n                 sizeof(assert_format),\n                 "Mocked %s(%s):",\n                 func_p,\n                 param_p);\n        nala_test_failure(\n            nala_format_mock_traceback(\n                nala_format_string(&assert_format[0],\n                                   acutal_p,\n                                   expected_p),\n                traceback_p));\n    }\n}\n\nvoid nala_mock_assert_in_string(void *acutal_p, void *expected_p, size_t size)\n{\n    nala_assert_string_or_memory(acutal_p, expected_p, size);\n}\n\nvoid nala_mock_assert_pointer(void **acutal_pp, void **expected_pp, size_t size)\n{\n    ASSERT_EQ(size, sizeof(*acutal_pp));\n    ASSERT_NE(acutal_pp, NULL);\n    ASSERT_NE(expected_pp, NULL);\n    ASSERT_EQ(*acutal_pp, *expected_pp);\n}\n\nvoid nala_mock_assert_in_eq_char(struct nala_traceback_t *traceback_p,\n                                 const char *func_p,\n                                 const char *param_p,\n                                 bool ignore_in,\n                                 char actual,\n                                 char expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_schar(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  signed char actual,\n                                  signed char expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_uchar(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  unsigned char actual,\n                                  unsigned char expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_short(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  short actual,\n                                  short expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_ushort(struct nala_traceback_t *traceback_p,\n                                   const char *func_p,\n                                   const char *param_p,\n                                   bool ignore_in,\n                                   unsigned short actual,\n                                   unsigned short expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_int(struct nala_traceback_t *traceback_p,\n                                const char *func_p,\n                                const char *param_p,\n                                bool ignore_in,\n                                int actual,\n                                int expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_uint(struct nala_traceback_t *traceback_p,\n                                 const char *func_p,\n                                 const char *param_p,\n                                 bool ignore_in,\n                                 unsigned int actual,\n                                 unsigned int expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_long(struct nala_traceback_t *traceback_p,\n                                 const char *func_p,\n                                 const char *param_p,\n                                 bool ignore_in,\n                                 long actual,\n                                 long expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_ulong(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  unsigned long actual,\n                                  unsigned long expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_llong(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  long long actual,\n                                  long long expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_ullong(struct nala_traceback_t *traceback_p,\n                                   const char *func_p,\n                                   const char *param_p,\n                                   bool ignore_in,\n                                   unsigned long long actual,\n                                   unsigned long long expected)\n{\n    MOCK_BINARY_ASSERTION_HEX(traceback_p,\n                              func_p,\n                              param_p,\n                              ignore_in,\n                              actual,\n                              expected);\n}\n\nvoid nala_mock_assert_in_eq_float(struct nala_traceback_t *traceback_p,\n                                  const char *func_p,\n                                  const char *param_p,\n                                  bool ignore_in,\n                                  float actual,\n                                  float expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_double(struct nala_traceback_t *traceback_p,\n                                   const char *func_p,\n                                   const char *param_p,\n                                   bool ignore_in,\n                                   double actual,\n                                   double expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_ldouble(struct nala_traceback_t *traceback_p,\n                                    const char *func_p,\n                                    const char *param_p,\n                                    bool ignore_in,\n                                    long double actual,\n                                    long double expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_bool(struct nala_traceback_t *traceback_p,\n                                 const char *func_p,\n                                 const char *param_p,\n                                 bool ignore_in,\n                                 bool actual,\n                                 bool expected)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual,\n                          expected);\n}\n\nvoid nala_mock_assert_in_eq_ptr(struct nala_traceback_t *traceback_p,\n                                const char *func_p,\n                                const char *param_p,\n                                bool ignore_in,\n                                const void *actual_p,\n                                const void *expected_p)\n{\n    MOCK_BINARY_ASSERTION(traceback_p,\n                          func_p,\n                          param_p,\n                          ignore_in,\n                          actual_p,\n                          expected_p);\n}\n\nvoid nala_mock_assert_in_eq_string(struct nala_traceback_t *traceback_p,\n                                   const char *func_p,\n                                   const char *param_p,\n                                   bool ignore_in,\n                                   const char *acutal_p,\n                                   const char *expected_p)\n{\n    if (!ignore_in) {\n        nala_mock_assert_string(traceback_p,\n                                func_p,\n                                param_p,\n                                acutal_p,\n                                expected_p,\n                                0);\n    }\n}\n\nvoid nala_mock_current_set(const char *func_p,\n                           const char *param_p,\n                           struct nala_traceback_t *traceback_p)\n{\n    nala_mock_func_p = func_p;\n    nala_mock_param_p = param_p;\n    nala_mock_traceback_p = traceback_p;\n}\n\nvoid nala_mock_current_clear(void)\n{\n    nala_mock_func_p = NULL;\n}\n\nbool nala_mock_current_is_set(void)\n{\n    return (nala_mock_func_p != NULL);\n}\n\nenum nala_va_arg_item_type_t {\n    nala_va_arg_item_type_d_t = 0,\n    nala_va_arg_item_type_u_t,\n    nala_va_arg_item_type_ld_t,\n    nala_va_arg_item_type_lu_t,\n    nala_va_arg_item_type_p_t,\n    nala_va_arg_item_type_s_t\n};\n\nstruct nala_va_arg_item_t {\n    enum nala_va_arg_item_type_t type;\n    bool ignore_in;\n    union {\n        int d;\n        unsigned int u;\n        long ld;\n        unsigned long lu;\n        const void *p_p;\n        const char *s_p;\n    };\n    struct nala_set_param in;\n    struct nala_set_param out;\n    nala_mock_in_assert_t in_assert;\n    nala_mock_out_copy_t out_copy;\n    struct nala_va_arg_item_t *next_p;\n};\n\nstruct nala_va_arg_list_t {\n    struct nala_va_arg_item_t *head_p;\n    struct nala_va_arg_item_t *tail_p;\n    unsigned int length;\n    struct nala_traceback_t *traceback_p;\n    const char *func_p;\n};\n\nstruct nala_suspended_t {\n    int count;\n    int mode;\n};\n\nstruct nala_state_t {\n    int mode;\n    struct nala_suspended_t suspended;\n};\n\nvoid nala_set_param_init(struct nala_set_param *self_p)\n{\n    self_p->buf_p = NULL;\n    self_p->size = 0;\n}\n\nvoid nala_set_param_buf(struct nala_set_param *self_p,\n                        const void *buf_p,\n                        size_t size)\n{\n    if (buf_p != NULL) {\n        self_p->buf_p = nala_alloc(size);\n        self_p->size = size;\n        memcpy(self_p->buf_p, buf_p, size);\n    } else {\n        self_p->buf_p = NULL;\n        self_p->size = 0;\n    }\n}\n\nvoid nala_set_param_string(struct nala_set_param *self_p, const char *string_p)\n{\n    nala_set_param_buf(self_p, string_p, strlen(string_p) + 1);\n}\n\nconst char *va_arg_type_specifier_string(enum nala_va_arg_item_type_t type)\n{\n    const char *res_p;\n\n    switch (type) {\n\n    case nala_va_arg_item_type_d_t:\n        res_p = "d";\n        break;\n\n    case nala_va_arg_item_type_u_t:\n        res_p = "u";\n        break;\n\n    case nala_va_arg_item_type_ld_t:\n        res_p = "ld";\n        break;\n\n    case nala_va_arg_item_type_lu_t:\n        res_p = "lu";\n        break;\n\n    case nala_va_arg_item_type_p_t:\n        res_p = "p";\n        break;\n\n    case nala_va_arg_item_type_s_t:\n        res_p = "s";\n        break;\n\n    default:\n        nala_test_failure(nala_format("Nala internal failure.\\n"));\n        exit(1);\n        break;\n    }\n\n    return (res_p);\n}\n\nvoid nala_va_arg_list_init(struct nala_va_arg_list_t *self_p,\n                           struct nala_traceback_t *traceback_p,\n                           const char *func_p)\n{\n    self_p->head_p = NULL;\n    self_p->tail_p = NULL;\n    self_p->length = 0;\n    self_p->traceback_p = traceback_p;\n    self_p->func_p = func_p;\n}\n\nvoid nala_va_arg_list_append(struct nala_va_arg_list_t *self_p,\n                             struct nala_va_arg_item_t *item_p)\n{\n    self_p->length++;\n\n    if (self_p->head_p == NULL) {\n        self_p->head_p = item_p;\n    } else {\n        self_p->tail_p->next_p = item_p;\n    }\n\n    item_p->next_p = NULL;\n    self_p->tail_p = item_p;\n}\n\nstruct nala_va_arg_item_t *nala_va_arg_list_get(\n    struct nala_va_arg_list_t *self_p,\n    unsigned int index)\n{\n    unsigned int i;\n    struct nala_va_arg_item_t *item_p;\n\n    if (index >= self_p->length) {\n        nala_test_failure(\n            nala_format(\n                "Trying to access variable argument at index %u when only %u "\n                "exists.\\n",\n                index,\n                self_p->length));\n    }\n\n    item_p = self_p->head_p;\n\n    for (i = 0; (i < index) && (item_p != NULL); i++) {\n        item_p = item_p->next_p;\n    }\n\n    return (item_p);\n}\n\nvoid nala_parse_va_arg_long(const char **format_pp,\n                            va_list *vl_p,\n                            struct nala_va_arg_item_t *item_p)\n{\n    switch (**format_pp) {\n\n    case \'d\':\n        item_p->type = nala_va_arg_item_type_ld_t;\n\n        if (vl_p != NULL) {\n            item_p->ignore_in = false;\n            item_p->ld = va_arg(*vl_p, long);\n        } else {\n            item_p->ignore_in = true;\n            item_p->ld = 0;\n        }\n\n        break;\n\n    case \'u\':\n        item_p->type = nala_va_arg_item_type_lu_t;\n\n        if (vl_p != NULL) {\n            item_p->ignore_in = false;\n            item_p->lu = va_arg(*vl_p, unsigned long);\n        } else {\n            item_p->ignore_in = true;\n            item_p->lu = 0;\n        }\n\n        break;\n\n    default:\n        nala_test_failure(\n            nala_format("Unsupported type specifier %%l%c.\\n", **format_pp));\n        exit(1);\n        break;\n    }\n\n    (*format_pp)++;\n}\n\nvoid nala_parse_va_arg_non_long(const char **format_pp,\n                                va_list *vl_p,\n                                struct nala_va_arg_item_t *item_p)\n{\n    const char *string_p;\n\n    switch (**format_pp) {\n\n    case \'d\':\n        item_p->type = nala_va_arg_item_type_d_t;\n\n        if (vl_p != NULL) {\n            item_p->ignore_in = false;\n            item_p->d = va_arg(*vl_p, int);\n        } else {\n            item_p->ignore_in = true;\n            item_p->d = 0;\n        }\n\n        break;\n\n    case \'u\':\n        item_p->type = nala_va_arg_item_type_u_t;\n\n        if (vl_p != NULL) {\n            item_p->ignore_in = false;\n            item_p->u = va_arg(*vl_p, unsigned int);\n        } else {\n            item_p->ignore_in = true;\n            item_p->u = 0;\n        }\n\n        break;\n\n    case \'p\':\n        item_p->type = nala_va_arg_item_type_p_t;\n        item_p->ignore_in = true;\n        item_p->p_p = NULL;\n        break;\n\n    case \'s\':\n        item_p->type = nala_va_arg_item_type_s_t;\n        item_p->s_p = NULL;\n\n        if (vl_p != NULL) {\n            string_p = va_arg(*vl_p, char *);\n\n            if (string_p != NULL) {\n                item_p->ignore_in = true;\n                nala_set_param_string(&item_p->in, string_p);\n            } else {\n                item_p->ignore_in = false;\n            }\n        } else {\n            item_p->ignore_in = true;\n        }\n\n        break;\n\n    default:\n        nala_test_failure(\n            nala_format("Unsupported type specifier %%%c.\\n", **format_pp));\n        exit(1);\n        break;\n    }\n\n    (*format_pp)++;\n}\n\nstruct nala_va_arg_item_t *nala_parse_va_arg(const char **format_pp,\n                                             va_list *vl_p)\n{\n    struct nala_va_arg_item_t *item_p;\n\n    item_p = nala_alloc(sizeof(*item_p));\n    item_p->in.buf_p = NULL;\n    item_p->out.buf_p = NULL;\n    item_p->in_assert = NULL;\n    item_p->out_copy = NULL;\n\n    if (**format_pp == \'l\') {\n        (*format_pp)++;\n        nala_parse_va_arg_long(format_pp, vl_p, item_p);\n    } else {\n        nala_parse_va_arg_non_long(format_pp, vl_p, item_p);\n    }\n\n    return (item_p);\n}\n\nvoid nala_va_arg_copy_out(void *dst_p, struct nala_va_arg_item_t *self_p)\n{\n    if (self_p->out.buf_p != NULL) {\n        if (self_p->out_copy != NULL) {\n            self_p->out_copy(dst_p, self_p->out.buf_p, self_p->out.size);\n        } else {\n            memcpy(dst_p, self_p->out.buf_p, self_p->out.size);\n        }\n    }\n}\n\nvoid nala_parse_va_list(struct nala_va_arg_list_t *list_p,\n                        const char *format_p,\n                        va_list *vl_p)\n{\n    struct nala_va_arg_item_t *item_p;\n\n    if (format_p == NULL) {\n        nala_test_failure(\n            nala_format(\n                "Mocked variadic function format must be a string, not NULL.\\n"));\n    }\n\n    while (true) {\n        if (*format_p == \'\\0\') {\n            break;\n        } else if (*format_p == \'%\') {\n            format_p++;\n            item_p = nala_parse_va_arg(&format_p, vl_p);\n            nala_va_arg_list_append(list_p, item_p);\n        } else {\n            nala_test_failure(\n                nala_format("Bad format string \'%s\'.\\n", format_p));\n        }\n    }\n}\n\nvoid nala_va_arg_list_assert_d(struct nala_va_arg_list_t *self_p,\n                               struct nala_va_arg_item_t *item_p,\n                               int value)\n{\n    nala_mock_assert_in_eq_int(self_p->traceback_p,\n                               self_p->func_p,\n                               "...",\n                               item_p->ignore_in,\n                               value,\n                               item_p->d);\n}\n\nvoid nala_va_arg_list_assert_u(struct nala_va_arg_list_t *self_p,\n                               struct nala_va_arg_item_t *item_p,\n                               unsigned int value)\n{\n    nala_mock_assert_in_eq_ulong(self_p->traceback_p,\n                                 self_p->func_p,\n                                 "...",\n                                 item_p->ignore_in,\n                                 value,\n                                 item_p->u);\n}\n\nvoid nala_va_arg_list_assert_ld(struct nala_va_arg_list_t *self_p,\n                                struct nala_va_arg_item_t *item_p,\n                                long value)\n{\n    nala_mock_assert_in_eq_long(self_p->traceback_p,\n                                self_p->func_p,\n                                "...",\n                                item_p->ignore_in,\n                                value,\n                                item_p->ld);\n}\n\nvoid nala_va_arg_list_assert_lu(struct nala_va_arg_list_t *self_p,\n                                struct nala_va_arg_item_t *item_p,\n                                unsigned long value)\n{\n    nala_mock_assert_in_eq_ulong(self_p->traceback_p,\n                                 self_p->func_p,\n                                 "...",\n                                 item_p->ignore_in,\n                                 value,\n                                 item_p->lu);\n}\n\nvoid nala_va_arg_list_assert_p(struct nala_va_arg_list_t *self_p,\n                               struct nala_va_arg_item_t *item_p,\n                               void *value_p)\n{\n    nala_mock_assert_in_eq_ptr(self_p->traceback_p,\n                               self_p->func_p,\n                               "...",\n                               item_p->ignore_in,\n                               value_p,\n                               item_p->p_p);\n\n    if (item_p->in.buf_p != NULL) {\n        if (item_p->in_assert != NULL) {\n            nala_mock_current_set(self_p->func_p, "...", self_p->traceback_p);\n            item_p->in_assert(value_p, item_p->in.buf_p, item_p->in.size);\n            nala_mock_current_clear();\n        } else {\n            nala_mock_assert_memory(self_p->traceback_p,\n                                    self_p->func_p,\n                                    "...",\n                                    value_p,\n                                    item_p->in.buf_p,\n                                    item_p->in.size);\n        }\n    }\n\n    nala_va_arg_copy_out(value_p, item_p);\n}\n\nvoid nala_va_arg_list_assert_s(struct nala_va_arg_list_t *self_p,\n                               struct nala_va_arg_item_t *item_p,\n                               char *value_p)\n{\n    nala_mock_assert_in_eq_ptr(self_p->traceback_p,\n                               self_p->func_p,\n                               "...",\n                               item_p->ignore_in,\n                               value_p,\n                               item_p->s_p);\n\n    if (item_p->in.buf_p != NULL) {\n        if (item_p->in_assert != NULL) {\n            nala_mock_current_set(self_p->func_p, "...", self_p->traceback_p);\n            item_p->in_assert(value_p, item_p->in.buf_p, item_p->in.size);\n            nala_mock_current_clear();\n        } else {\n            nala_mock_assert_string(self_p->traceback_p,\n                                    self_p->func_p,\n                                    "...",\n                                    value_p,\n                                    item_p->in.buf_p,\n                                    0);\n        }\n    }\n\n    nala_va_arg_copy_out(value_p, item_p);\n}\n\nvoid nala_va_arg_list_set_param_buf_in_at(struct nala_va_arg_list_t *self_p,\n                                          unsigned int index,\n                                          const void *buf_p,\n                                          size_t size)\n{\n    struct nala_va_arg_item_t *item_p;\n\n    item_p = nala_va_arg_list_get(self_p, index);\n\n    switch (item_p->type) {\n\n    case nala_va_arg_item_type_p_t:\n        nala_set_param_buf(&item_p->in, buf_p, size);\n        break;\n\n    default:\n        nala_test_failure(\n            nala_format(\n                "Cannot set input for \'%%%s\' at index %u. Only \'%%p\' can be set.\\n",\n                va_arg_type_specifier_string(item_p->type),\n                index));\n        exit(1);\n        break;\n    }\n}\n\nvoid nala_va_arg_list_set_param_buf_out_at(struct nala_va_arg_list_t *self_p,\n                                           unsigned int index,\n                                           const void *buf_p,\n                                           size_t size)\n{\n    struct nala_va_arg_item_t *item_p;\n\n    item_p = nala_va_arg_list_get(self_p, index);\n\n    switch (item_p->type) {\n\n    case nala_va_arg_item_type_p_t:\n    case nala_va_arg_item_type_s_t:\n        nala_set_param_buf(&item_p->out, buf_p, size);\n        break;\n\n    default:\n        nala_test_failure(\n            nala_format(\n                "Cannot set output for \'%%%s\' at index %u. Only \'%%p\' and \'%%s\' "\n                "can be set.\\n",\n                va_arg_type_specifier_string(item_p->type),\n                index));\n        exit(1);\n        break;\n    }\n}\n\nvoid nala_va_arg_list_assert(struct nala_va_arg_list_t *self_p,\n                             va_list vl)\n{\n    unsigned int i;\n    struct nala_va_arg_item_t *item_p;\n\n    item_p = self_p->head_p;\n\n    for (i = 0; i < self_p->length; i++) {\n        switch (item_p->type) {\n\n        case nala_va_arg_item_type_d_t:\n            nala_va_arg_list_assert_d(self_p, item_p, va_arg(vl, int));\n            break;\n\n        case nala_va_arg_item_type_u_t:\n            nala_va_arg_list_assert_u(self_p, item_p, va_arg(vl, unsigned int));\n            break;\n\n        case nala_va_arg_item_type_ld_t:\n            nala_va_arg_list_assert_ld(self_p, item_p, va_arg(vl, long));\n            break;\n\n        case nala_va_arg_item_type_lu_t:\n            nala_va_arg_list_assert_lu(self_p, item_p, va_arg(vl, unsigned long));\n            break;\n\n        case nala_va_arg_item_type_p_t:\n            nala_va_arg_list_assert_p(self_p, item_p, va_arg(vl, void *));\n            break;\n\n        case nala_va_arg_item_type_s_t:\n            nala_va_arg_list_assert_s(self_p, item_p, va_arg(vl, char *));\n            break;\n\n        default:\n            nala_test_failure(nala_format("Nala internal failure.\\n"));\n            exit(1);\n            break;\n        }\n\n        item_p = item_p->next_p;\n    }\n}\n\nvoid nala_traceback(struct nala_traceback_t *traceback_p)\n{\n    traceback_p->depth = backtrace(&traceback_p->addresses[0], 32);\n}\n\n#define MOCK_ASSERT_PARAM_IN_EQ(traceback_p,            \\\n                                format_p,               \\\n                                member_p,               \\\n                                left,                   \\\n                                right)                  \\\n    if ((left) != (right)) {                            \\\n        char _nala_assert_format[512];                  \\\n        nala_suspend_all_mocks();                       \\\n        snprintf(&_nala_assert_format[0],               \\\n                 sizeof(_nala_assert_format),           \\\n                 format_p,                              \\\n                 member_p,                              \\\n                 PRINT_FORMAT(left),                    \\\n                 PRINT_FORMAT(right));                  \\\n        nala_test_failure(                              \\\n            nala_format_mock_traceback(                 \\\n                nala_format(&_nala_assert_format[0],    \\\n                            left,                       \\\n                            right),                     \\\n                traceback_p));                          \\\n    }\n\n#define MOCK_ASSERT_PARAM_IN(data_p, func, name)                \\\n    nala_mock_current_set(#func, #name, &(data_p)->traceback);  \\\n    (data_p)->params.name ## _in_assert(                        \\\n        name,                                                   \\\n        (__typeof__((data_p)->params.name))(uintptr_t)(data_p)  \\\n        ->params.name ## _in.buf_p,                             \\\n        (data_p)->params.name ## _in.size);                     \\\n    nala_mock_current_clear();\n\n#define MOCK_COPY_PARAM_OUT(params_p, name)             \\\n    if ((params_p)->name ## _out_copy == NULL) {        \\\n        memcpy((void *)(uintptr_t)name,                 \\\n               (params_p)->name ## _out.buf_p,          \\\n               (params_p)->name ## _out.size);          \\\n    } else {                                            \\\n        (params_p)->name ## _out_copy(                  \\\n            name,                                       \\\n            (__typeof__((params_p)->name))(uintptr_t)   \\\n            (params_p)->name ## _out.buf_p,             \\\n            (params_p)->name ## _out.size);             \\\n    }\n\n#define MOCK_ASSERT_COPY_SET_PARAM(instance_p, data_p, func, name)      \\\n    if ((data_p)->params.name ## _in.buf_p != NULL) {                   \\\n        MOCK_ASSERT_PARAM_IN(data_p, func, name);                       \\\n    }                                                                   \\\n                                                                        \\\n    if ((data_p)->params.name ## _out.buf_p != NULL) {                  \\\n        MOCK_COPY_PARAM_OUT(&(data_p)->params, name);                   \\\n    }\n\nvoid nala_state_suspend(struct nala_state_t *state_p)\n{\n    if (state_p->suspended.count == 0) {\n        state_p->suspended.mode = state_p->mode;\n        state_p->mode = MODE_REAL;\n    }\n\n    state_p->suspended.count++;\n}\n\nvoid nala_state_resume(struct nala_state_t *state_p)\n{\n    state_p->suspended.count--;\n\n    if (state_p->suspended.count == 0) {\n        state_p->mode = state_p->suspended.mode;\n    }\n}\n\nvoid nala_mock_none_fail(struct nala_traceback_t *traceback_p,\n                         const char *func_p)\n{\n    nala_test_failure(\n        nala_format_mock_traceback(\n            nala_format("Mocked %s() called unexpectedly.\\n\\n",\n                        func_p),\n            traceback_p));\n}\n\nint nala_print_call_mask = 0;\n\nvoid nala_print_call(const char *function_name_p, struct nala_state_t *state_p)\n{\n    const char *mode_p;\n\n    if (state_p->suspended.count != 0) {\n        return;\n    }\n\n    if (((1 << state_p->mode) & nala_print_call_mask) == 0) {\n        return;\n    }\n\n    switch (state_p->mode) {\n\n    case MODE_REAL:\n        mode_p = "real";\n        break;\n\n    case MODE_MOCK_ONCE:\n        mode_p = "once";\n        break;\n\n    case MODE_IMPLEMENTATION:\n        mode_p = "impl";\n        break;\n\n    case MODE_MOCK:\n        mode_p = "mock";\n        break;\n\n    case MODE_NONE:\n        mode_p = "none";\n        break;\n\n    default:\n        mode_p = "unknown";\n        break;\n    }\n\n    fprintf(nala_get_stdout(), "%s: %s()\\n", mode_p, function_name_p);\n}\n\nint nala_next_handle = 1;\n'

@pytest.mark.xfail(strict=True)
def test_case_4():
    bool_0 = False
    var_0 = module_1.is_char_pointer(bool_0)
    module_0.decl(var_0, var_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    none_type_0 = None
    module_0.function_ptr_decl(none_type_0, none_type_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_6():
    file_generator_0 = module_0.FileGenerator()
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None
    module_0.bool_param(file_generator_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    file_generator_0 = module_0.FileGenerator()
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None
    module_0.set_member(file_generator_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    int_0 = -764
    module_0.out_copy_member(int_0, int_0, int_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = "!('Q*^2he"
    var_0 = module_0.create_implementation_params(str_0)
    var_1 = var_0.__iter__()
    var_2 = var_0.__iter__()
    module_0.va_list_param(var_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    file_generator_0 = module_0.FileGenerator()
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None
    module_0.int_type(file_generator_0)

def test_case_11():
    str_0 = 'd-3f/=L'
    none_type_0 = None
    struct_assert_0 = module_0.StructAssert(str_0, none_type_0, none_type_0)
    assert f'{type(struct_assert_0).__module__}.{type(struct_assert_0).__qualname__}' == 'nala.generator.StructAssert'
    assert struct_assert_0.name == 'd'
    assert struct_assert_0.assert_eq_members == []
    assert struct_assert_0.assert_eq_cast_members == []
    assert struct_assert_0.assert_array_eq_members == []
    assert struct_assert_0.assert_struct_members == []
    file_generator_0 = module_0.FileGenerator(none_type_0)
    var_0 = module_2.finditer(str_0, str_0)
    var_1 = file_generator_0.write_to_directory(str_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    file_generator_0 = module_0.FileGenerator()
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None
    file_generator_0.add_mock(file_generator_0, file_generator_0, file_generator_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    none_type_0 = None
    file_generator_0 = module_0.FileGenerator(none_type_0)
    assert f'{type(file_generator_0).__module__}.{type(file_generator_0).__qualname__}' == 'nala.generator.FileGenerator'
    assert f'{type(file_generator_0.code_generator).__module__}.{type(file_generator_0.code_generator).__qualname__}' == 'pycparser.c_generator.CGenerator'
    assert f'{type(file_generator_0.jinja_env).__module__}.{type(file_generator_0.jinja_env).__qualname__}' == 'jinja2.environment.Environment'
    assert f'{type(file_generator_0.header_template).__module__}.{type(file_generator_0.header_template).__qualname__}' == 'jinja2.environment.Template'
    assert f'{type(file_generator_0.source_template).__module__}.{type(file_generator_0.source_template).__qualname__}' == 'jinja2.environment.Template'
    assert file_generator_0.mocks == []
    assert file_generator_0.includes == []
    assert file_generator_0.structs == []
    assert file_generator_0.struct_typedefs == []
    assert file_generator_0.struct_names == {*()}
    assert file_generator_0.struct_typedef_names == {*()}
    assert file_generator_0.parser is None
    file_generator_1 = module_0.FileGenerator(file_generator_0)
    file_generator_1.write_to_directory(file_generator_1)

@pytest.mark.xfail(strict=True)
def test_case_14():
    none_type_0 = None
    module_0.in_assert_member(none_type_0, none_type_0, none_type_0)

def test_case_15():
    str_0 = '"`jQl_)F8x7o'
    struct_typedef_assert_0 = module_0.StructTypedefAssert(str_0, str_0, str_0)
    assert f'{type(struct_typedef_assert_0).__module__}.{type(struct_typedef_assert_0).__qualname__}' == 'nala.generator.StructTypedefAssert'
    assert struct_typedef_assert_0.name == '"'
    assert struct_typedef_assert_0.assert_eq_members == []
    assert struct_typedef_assert_0.assert_eq_cast_members == []
    assert struct_typedef_assert_0.assert_array_eq_members == []
    assert struct_typedef_assert_0.assert_struct_members == []

def test_case_16():
    str_0 = 'd-3f/=L'
    none_type_0 = None
    struct_assert_0 = module_0.StructAssert(str_0, none_type_0, none_type_0)
    assert f'{type(struct_assert_0).__module__}.{type(struct_assert_0).__qualname__}' == 'nala.generator.StructAssert'
    assert struct_assert_0.name == 'd'
    assert struct_assert_0.assert_eq_members == []
    assert struct_assert_0.assert_eq_cast_members == []
    assert struct_assert_0.assert_array_eq_members == []
    assert struct_assert_0.assert_struct_members == []
    file_generator_0 = module_0.FileGenerator(none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    str_0 = 'd-3f/=L'
    none_type_0 = None
    struct_typedef_assert_0 = module_0.does_generated_files_exist(str_0)
    assert struct_typedef_assert_0 is True
    file_generator_0 = module_0.FileGenerator(none_type_0)
    var_0 = module_2.finditer(str_0, str_0)
    var_1 = module_0.create_implementation_params(str_0)
    module_0.in_assert_member(none_type_0, file_generator_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_18():
    str_0 = 'd-3f/=L'
    var_0 = module_0.does_generated_files_exist(str_0)
    assert var_0 is True
    var_0.visit_FuncDef(str_0)