# Automatically generated by Pynguin.
import pytest
import nala.inspect as module_0
import pycparser.c_ast as module_1
import re as module_2

@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    var_0 = module_0.is_struct_or_union(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    str_0 = 'b~hj+7\\,pe:_\ne;\x0b?'
    var_1 = module_0.is_va_list(str_0)
    assert var_1 is False
    var_2 = module_0.is_primitive_type_pointer(var_1)
    assert var_2 is False
    var_3 = module_0.is_pointer_to_pointer(var_1)
    assert var_3 is False
    var_4 = module_0.is_struct_or_union(none_type_0)
    assert var_4 is False
    module_0.ForgivingDeclarationParser(var_1, str_0, var_4)

@pytest.mark.xfail(strict=True)
def test_case_1():
    module_0.PrimitiveType()

def test_case_2():
    str_0 = 'utf-8'
    var_0 = module_0.is_struct(str_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_3():
    none_type_0 = None
    var_0 = module_0.is_pointer_to_pointer(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_4():
    none_type_0 = None
    var_0 = module_0.is_fixed_array(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_5():
    int_0 = 24
    var_0 = module_0.is_primitive_type_pointer_type(int_0, int_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_6():
    str_0 = 'utf-8'
    var_0 = module_0.is_primitive_type_pointer(str_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

@pytest.mark.xfail(strict=True)
def test_case_7():
    none_type_0 = None
    str_0 = 'ib~"j+C\\,Je:_#e6;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"j+C\\,Je:_#e6;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.lookup_typedef(str_0)
    var_1 = module_0.is_primitive_type_pointer(var_0, str_0)
    assert var_1 is False
    var_1.parse_typedef()

def test_case_8():
    bytes_0 = b'\x95\x08\xb4i`V-\xc0?\x90'
    var_0 = module_0.is_char_pointer(bytes_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = 'ib~"j+C\\rJe:_#e6;\x0b?'
    module_0.ForgivingDeclarationParser(str_0, str_0)

def test_case_10():
    none_type_0 = None
    var_0 = module_0.is_struct_or_union(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_11():
    bool_0 = True
    var_0 = module_0.is_pointer_or_array(bool_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_12():
    none_type_0 = None
    var_0 = module_0.is_pointer(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_13():
    none_type_0 = None
    var_0 = module_0.is_array(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

@pytest.mark.xfail(strict=True)
def test_case_14():
    bool_0 = True
    module_0.load_param_names(bool_0)

def test_case_15():
    none_type_0 = None
    var_0 = module_0.is_va_list(none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

@pytest.mark.xfail(strict=True)
def test_case_16():
    none_type_0 = None
    str_0 = 'ib~"j+C\\,Je:_#e6;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"j+C\\,Je:_#e6;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.lookup_typedef(str_0)
    set_0 = {str_0}
    module_0.ForgivingDeclarationParser(str_0, var_0, set_0)

def test_case_17():
    none_type_0 = None
    str_0 = '(0jZ7\\Vpe0_\ne;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == '(0jZ7\\Vpe0_\ne;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == [')']
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'

@pytest.mark.xfail(strict=True)
def test_case_18():
    none_type_0 = None
    str_0 = '(0jZ7\\Vpe0_\ne;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == '(0jZ7\\Vpe0_\ne;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == [')']
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    forgiving_declaration_parser_0.parse_function_declaration_or_struct()

def test_case_19():
    none_type_0 = None
    str_0 = '(~j+7\\,pe0_\ne;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == '(~j+7\\,pe0_\ne;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == [')']
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = module_1.Goto(none_type_0)

def test_case_20():
    none_type_0 = None
    str_0 = 'b~hj+7\\,pe:_\ne;\x0b\r'
    with pytest.raises(Exception):
        module_0.ForgivingDeclarationParser(str_0, str_0, none_type_0)

def test_case_21():
    str_0 = ''
    none_type_0 = None
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == ''
    assert forgiving_declaration_parser_0.functions == ''
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert forgiving_declaration_parser_0.previous is None
    assert forgiving_declaration_parser_0.current is None
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    with pytest.raises(Exception):
        forgiving_declaration_parser_0.expand_type(none_type_0)

def test_case_22():
    none_type_0 = None
    str_0 = 'ib~"j+C\\,Je:_#e6;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"j+C\\,Je:_#e6;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'

@pytest.mark.xfail(strict=True)
def test_case_23():
    none_type_0 = None
    str_0 = 'struct nala_set_param'
    module_0.ForgivingDeclarationParser(str_0, none_type_0)

def test_case_24():
    none_type_0 = None
    str_0 = 'ib~"j+C\\,Je:_#e6;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"j+C\\,Je:_#e6;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.parse_typedef()
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;', ';']

def test_case_25():
    none_type_0 = None
    str_0 = 'ib~"+C\\,Je_#e6;\x0bx?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"+C\\,Je_#e6;\x0bx?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.parse_struct(none_type_0, forgiving_declaration_parser_0)

@pytest.mark.xfail(strict=True)
def test_case_26():
    str_0 = '{S+v,C\x0b?Ovu^AQ'
    var_0 = module_1.IdentifierType(str_0)
    var_1 = module_0.is_primitive_type_pointer(str_0, str_0)
    assert var_1 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    var_2 = module_0.is_struct_or_union(str_0)
    assert var_2 is False
    var_3 = module_0.is_fixed_array(str_0)
    assert var_3 is False
    none_type_0 = None
    var_4 = module_0.is_pointer_to_pointer(none_type_0)
    assert var_4 is False
    var_5 = module_0.is_primitive_type_pointer_type(str_0, str_0)
    assert var_5 is False
    if_0 = module_1.If(var_3, var_3, none_type_0)
    var_6 = module_0.is_va_list(var_0)
    assert var_6 is False
    module_0.ForgivingDeclarationParser(str_0, str_0, none_type_0)

def test_case_27():
    none_type_0 = None
    str_0 = 'ib~;"+C\\,Je_#e6;\x0bx?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~;"+C\\,Je_#e6;\x0bx?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    with pytest.raises(Exception):
        forgiving_declaration_parser_0.expand_type(forgiving_declaration_parser_0)

@pytest.mark.xfail(strict=True)
def test_case_28():
    str_0 = '-Wl,--wrap=(.*)'
    var_0 = module_0.is_va_list(str_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    module_0.ForgivingDeclarationParser(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_29():
    none_type_0 = None
    str_0 = 'b~hj7\\,pe:_\ne;?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b~hj7\\,pe:_\ne;?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.mark_for_erase(forgiving_declaration_parser_0, none_type_0)
    assert len(forgiving_declaration_parser_0.chunks_to_erase) == 1
    forgiving_declaration_parser_0.parse_typedef()

def test_case_30():
    none_type_0 = None
    str_0 = 'b~hj7\\,pe:_\ne;?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b~hj7\\,pe:_\ne;?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.lookup_typedef(str_0)

@pytest.mark.xfail(strict=True)
def test_case_31():
    none_type_0 = None
    str_0 = 'b~hj+7\\,pe:_\ne;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b~hj+7\\,pe:_\ne;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.next()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'nala.inspect.Token'
    assert len(var_0) == 3
    forgiving_declaration_parser_0.parse_typedef()

@pytest.mark.xfail(strict=True)
def test_case_32():
    none_type_0 = None
    str_0 = 'irZHA(f|-tY |\n~z'
    module_0.ForgivingDeclarationParser(str_0, none_type_0)

def test_case_33():
    none_type_0 = None
    str_0 = 'ib~;"+C\\,Je_#e6;\x0bx?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~;"+C\\,Je_#e6;\x0bx?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    with pytest.raises(Exception):
        forgiving_declaration_parser_0.resolve_type(forgiving_declaration_parser_0)

@pytest.mark.xfail(strict=True)
def test_case_34():
    none_type_0 = None
    str_0 = '-azR,p4nN?E\\w=>\nx('
    module_0.ForgivingDeclarationParser(str_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_35():
    none_type_0 = None
    str_0 = 'ib~"+C,\\,Je_#6;\x0bx?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'ib~"+C,\\,Je_#6;\x0bx?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = forgiving_declaration_parser_0.next()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'nala.inspect.Token'
    assert len(var_0) == 3
    forgiving_declaration_parser_0.parse_typedef()

def test_case_36():
    str_0 = 'Vu{5lZ&h^(?wtf'
    var_0 = module_1.TypeDecl(str_0, str_0, str_0, str_0, str_0)
    var_1 = module_0.is_pointer_to_pointer(var_0)
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}

def test_case_37():
    none_type_0 = None
    var_0 = module_0.is_primitive_type_pointer_type(none_type_0, none_type_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    str_0 = 'b~j+7\\,pe:_\ne;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b~j+7\\,pe:_\ne;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_1 = forgiving_declaration_parser_0.mark_for_erase(str_0, var_0)
    assert forgiving_declaration_parser_0.chunks_to_erase == [('b~j+7\\,pe:_\ne;\x0b?', False)]
    var_2 = module_0.is_fixed_array(str_0)
    assert var_2 is False
    var_3 = forgiving_declaration_parser_0.parse_typedef()
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;', ';']

@pytest.mark.xfail(strict=True)
def test_case_38():
    none_type_0 = None
    str_0 = 'b"~"+C\\,Je_#e6;\x0bx?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b"~"+C\\,Je_#e6;\x0bx?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_0 = module_1.ArrayDecl(str_0, none_type_0, none_type_0, none_type_0)
    var_1 = module_0.is_pointer_or_array(var_0)
    forgiving_declaration_parser_0.parse_struct(var_0, var_0)

@pytest.mark.xfail(strict=True)
def test_case_39():
    bool_0 = False
    var_0 = module_1.PtrDecl(bool_0, bool_0)
    var_1 = module_0.is_primitive_type_pointer(var_0)
    assert var_1 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    var_2 = module_0.is_pointer_to_pointer(var_0)
    assert var_2 is False
    var_3 = module_0.is_struct_or_union(var_0)
    assert var_3 is False
    module_0.ForgivingDeclarationParser(var_3, var_3)

@pytest.mark.xfail(strict=True)
def test_case_40():
    none_type_0 = None
    var_0 = module_2.RegexFlag.DOTALL
    str_0 = 'b~j+\\\x0be:_\n:;\x0b?'
    forgiving_declaration_parser_0 = module_0.ForgivingDeclarationParser(str_0, none_type_0)
    assert f'{type(forgiving_declaration_parser_0).__module__}.{type(forgiving_declaration_parser_0).__qualname__}' == 'nala.inspect.ForgivingDeclarationParser'
    assert forgiving_declaration_parser_0.source_code == 'b~j+\\\x0be:_\n:;\x0b?'
    assert forgiving_declaration_parser_0.functions is None
    assert f'{type(forgiving_declaration_parser_0.token_stream).__module__}.{type(forgiving_declaration_parser_0.token_stream).__qualname__}' == 'builtins.generator'
    assert f'{type(forgiving_declaration_parser_0.previous).__module__}.{type(forgiving_declaration_parser_0.previous).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.previous) == 3
    assert f'{type(forgiving_declaration_parser_0.current).__module__}.{type(forgiving_declaration_parser_0.current).__qualname__}' == 'nala.inspect.Token'
    assert len(forgiving_declaration_parser_0.current) == 3
    assert forgiving_declaration_parser_0.current_file is None
    assert forgiving_declaration_parser_0.chunks_to_erase == []
    assert forgiving_declaration_parser_0.bracket_stack == []
    assert forgiving_declaration_parser_0.source_context == []
    assert forgiving_declaration_parser_0.typedefs_code == ['typedef int __builtin_va_list;']
    assert f'{type(forgiving_declaration_parser_0.typedefs).__module__}.{type(forgiving_declaration_parser_0.typedefs).__qualname__}' == 'builtins.dict'
    assert len(forgiving_declaration_parser_0.typedefs) == 1
    assert forgiving_declaration_parser_0.structs_code == []
    assert forgiving_declaration_parser_0.structs == []
    assert forgiving_declaration_parser_0.struct_typedefs == []
    assert forgiving_declaration_parser_0.includes == []
    assert f'{type(forgiving_declaration_parser_0.cparser).__module__}.{type(forgiving_declaration_parser_0.cparser).__qualname__}' == 'pycparser.c_parser.CParser'
    assert forgiving_declaration_parser_0.param_names is None
    assert forgiving_declaration_parser_0.func_names == []
    assert forgiving_declaration_parser_0.func_signatures == []
    assert f'{type(forgiving_declaration_parser_0.file_ast).__module__}.{type(forgiving_declaration_parser_0.file_ast).__qualname__}' == 'pycparser.c_ast.FileAST'
    assert forgiving_declaration_parser_0.mocked_functions == []
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    assert f'{type(module_0.ForgivingDeclarationParser.tokenize).__module__}.{type(module_0.ForgivingDeclarationParser.tokenize).__qualname__}' == 'builtins.method'
    var_1 = module_0.is_char_pointer(none_type_0)
    assert var_1 is False
    var_2 = forgiving_declaration_parser_0.mark_for_erase(str_0, var_0)
    assert forgiving_declaration_parser_0.chunks_to_erase == [('b~j+\\\x0be:_\n:;\x0b?', module_2.RegexFlag.DOTALL)]
    var_3 = module_0.is_fixed_array(str_0)
    assert var_3 is False
    forgiving_declaration_parser_0.parse_typedef()

@pytest.mark.xfail(strict=True)
def test_case_41():
    str_0 = 'Wl,-_wra=(*)'
    var_0 = module_0.is_fixed_array(str_0)
    assert var_0 is False
    assert module_0.PRIMITIVE_TYPES == ['char', 'signed char', 'unsigned char', 'short', 'short int', 'signed short', 'signed short int', 'unsigned short', 'unsigned short int', 'int', 'signed', 'signed int', 'unsigned', 'unsigned int', 'long', 'long int', 'signed long', 'signed long int', 'unsigned long', 'unsigned long int', 'long unsigned int', 'long long', 'long long int', 'signed long long', 'signed long long int', 'unsigned long long', 'unsigned long long int', 'long long unsigned int', 'float', 'double', 'long double']
    assert module_0.TOKENS == {'LINEMARKER': '^# \\d+ .*$', 'PRAGMA': '^#pragma.*$', 'KEYWORD': '\\b(?:auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|__extension__|__attribute__|__restrict|__signed__|__signed|_Nullable)\\b', 'IDENTIFIER': '\\b[a-zA-Z_](?:[a-zA-Z_0-9])*\\b', 'CHARACTER': "L?'(?:\\\\.|[^\\\\'])+'", 'STRING': 'L?"(\\\\"|\\\\\\\\|.)*?"', 'INTEGER': '(?:0[xX][a-fA-F0-9]+|[0-9]+)[uUlL]*', 'FLOAT': '(?:[0-9]+[Ee][+-]?[0-9]+|[0-9]*\\.[0-9]+(?:[Ee][+-]?[0-9]+)?|[0-9]+\\.[0-9]*(?:[Ee][+-]?[0-9]+)?)[fFlL]?', 'PUNCTUATION': '\\.\\.\\.|>>=|<<=|\\+=|-=|\\*=|/=|%=|&=|\\^=|\\|=|>>|<<|\\+\\+|--|->|&&|\\|\\||<=|>=|==|!=|;|\\{|\\}|,|:|=|\\(|\\)|\\[|\\]|\\.|&|!|~|-|\\+|\\*|/|%|<|>|\\^|\\||\\?', 'SPACE': '[ \\t\\v\\n\\f]*', 'IGNORE': '.+?'}
    assert module_0.IGNORED_TOKENS == {'IGNORE', 'SPACE'}
    var_1 = module_0.is_va_list(str_0)
    assert var_1 is False
    module_0.ForgivingDeclarationParser(str_0, str_0)