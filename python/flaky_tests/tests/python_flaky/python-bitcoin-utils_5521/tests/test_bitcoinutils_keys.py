# Automatically generated by Pynguin.
import pytest
import bitcoinutils.keys as module_0
import ecdsa.numbertheory as module_1
import ecdsa.util as module_2
import base58check as module_3

@pytest.mark.xfail(strict=True)
def test_case_0():
    module_0.P2pkhAddress()

def test_case_1():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'

@pytest.mark.xfail(strict=True)
def test_case_2():
    module_0.P2wpkhAddress()

@pytest.mark.xfail(strict=True)
def test_case_3():
    module_0.P2wshAddress()

def test_case_4():
    bytes_0 = b'\xcc'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0)

@pytest.mark.xfail(strict=True)
def test_case_5():
    module_0.P2shAddress()

@pytest.mark.xfail(strict=True)
def test_case_6():
    bool_0 = False
    none_type_0 = None
    module_0.P2wpkhAddress(bool_0, bool_0, none_type_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    bytes_0 = b'\xcc'
    module_0.P2shAddress(script=bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    bytes_0 = b'\xcc'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0, bytes_0)
    module_0.P2shAddress(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_9():
    bytes_0 = b'\xcc'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(private_key_0)
    var_1 = private_key_0.sign_message(var_0)
    module_0.P2shAddress(hash160=bytes_0, script=bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    bytes_0 = b'\xc2'
    private_key_1 = module_0.PrivateKey()
    assert f'{type(private_key_1.key).__module__}.{type(private_key_1.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    p2wpkh_address_0 = module_0.P2wpkhAddress(witness_hash=bytes_0, version=private_key_1)
    assert f'{type(p2wpkh_address_0).__module__}.{type(p2wpkh_address_0).__qualname__}' == 'bitcoinutils.keys.P2wpkhAddress'
    assert f'{type(p2wpkh_address_0.version).__module__}.{type(p2wpkh_address_0.version).__qualname__}' == 'bitcoinutils.keys.PrivateKey'
    assert p2wpkh_address_0.witness_hash == b'\xc2'
    module_1.polynomial_exp_mod(private_key_1, private_key_1, private_key_1, bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_11():
    bytes_0 = b'\xcc'
    module_0.PrivateKey(secret_exponent=bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_12():
    bytes_0 = b'\xc2\xcc\xaa'
    module_0.PrivateKey(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif()
    var_0.__repr__(private_key_0)

@pytest.mark.xfail(strict=True)
def test_case_14():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.to_hash160()
    bool_0 = False
    module_2.sigencode_string(bool_0, var_1, var_1)

@pytest.mark.xfail(strict=True)
def test_case_15():
    bytes_0 = b'\xc2\xcc\xaa'
    module_0.P2wshAddress(witness_hash=bytes_0, script=bytes_0)

def test_case_16():
    bytes_0 = b'\xcc'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0)

@pytest.mark.xfail(strict=True)
def test_case_17():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.get_address()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bitcoinutils.keys.P2pkhAddress'
    var_2 = var_1.get_type()
    var_3 = var_0.get_segwit_address()
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'bitcoinutils.keys.P2wpkhAddress'
    assert var_3.version == 'p2wpkhv0'
    assert var_3.segwit_num_version == 0
    private_key_0.sign_input(var_2, private_key_0, private_key_0)

@pytest.mark.xfail(strict=True)
def test_case_18():
    bytes_0 = b'\xc2\xcc\xaa'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.to_bytes()
    module_0.P2shAddress(script=bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_19():
    bytes_0 = b'\xc2\xcc\xaa'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    private_key_0.sign_segwit_input(bytes_0, private_key_0, private_key_0, private_key_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    bytes_0 = b'\xc2\xcc\xaa'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    module_0.P2wpkhAddress(bytes_0, version=private_key_0)

@pytest.mark.xfail(strict=True)
def test_case_21():
    bytes_0 = b'\xcc'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0)
    module_0.P2shAddress(var_0, script=private_key_0)

@pytest.mark.xfail(strict=True)
def test_case_22():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.get_address()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bitcoinutils.keys.P2pkhAddress'
    var_2 = var_1.get_type()
    module_0.P2shAddress(var_2)

@pytest.mark.xfail(strict=True)
def test_case_23():
    bytes_0 = b'!5.\xa7\x187\xd4\xa5\xeeH\xd0\xc3\xda\xe0\xa7\x0f\x8f'
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.get_address()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bitcoinutils.keys.P2pkhAddress'
    var_2 = var_1.to_script_pub_key()
    assert f'{type(var_2).__module__}.{type(var_2).__qualname__}' == 'bitcoinutils.script.Script'
    module_0.P2shAddress(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_24():
    bytes_0 = b''
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0, bytes_0)
    var_2 = private_key_0.sign_message(var_1, var_0)
    module_0.P2pkhAddress(var_2)

@pytest.mark.xfail(strict=True)
def test_case_25():
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.get_public_key()
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'bitcoinutils.keys.PublicKey'
    assert f'{type(var_0.key).__module__}.{type(var_0.key).__qualname__}' == 'ecdsa.keys.VerifyingKey'
    assert f'{type(module_0.PublicKey.from_hex).__module__}.{type(module_0.PublicKey.from_hex).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.from_message_signature).__module__}.{type(module_0.PublicKey.from_message_signature).__qualname__}' == 'builtins.method'
    assert f'{type(module_0.PublicKey.verify_message).__module__}.{type(module_0.PublicKey.verify_message).__qualname__}' == 'builtins.method'
    var_1 = var_0.get_address()
    assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'bitcoinutils.keys.P2pkhAddress'
    var_2 = var_1.to_string()
    module_0.P2shAddress(var_2)

@pytest.mark.xfail(strict=True)
def test_case_26():
    bytes_0 = b''
    private_key_0 = module_0.PrivateKey()
    assert f'{type(private_key_0.key).__module__}.{type(private_key_0.key).__qualname__}' == 'ecdsa.keys.SigningKey'
    assert f'{type(module_0.PrivateKey.from_wif).__module__}.{type(module_0.PrivateKey.from_wif).__qualname__}' == 'builtins.method'
    var_0 = private_key_0.to_wif(bytes_0)
    var_1 = private_key_0.sign_message(var_0, bytes_0)
    var_2 = private_key_0.sign_message(var_0)
    module_0.P2pkhAddress(bytes_0)

@pytest.mark.xfail(strict=True)
def test_case_27():
    bytes_0 = b''
    private_key_0 = module_3.b58decode(bytes_0)
    module_0.PublicKey(bytes_0)