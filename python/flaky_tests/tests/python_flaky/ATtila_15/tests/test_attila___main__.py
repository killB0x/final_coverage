# Automatically generated by Pynguin.
import pytest
import attila.__main__ as module_0
import attila.exceptions as module_1

def test_case_0():
    getch_unix_0 = module_0._GetchUnix()
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True

def test_case_1():
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True

def test_case_2():
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    var_0 = module_0.sigterm_handler(getch_0, getch_0)

def test_case_3():
    bool_0 = True
    var_0 = module_0.get_log_level_from_option(bool_0)
    assert var_0 == 40
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    var_1 = var_0.__repr__()
    assert var_1 == '40'

@pytest.mark.xfail(strict=True)
def test_case_4():
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    getch_0.__call__()

@pytest.mark.xfail(strict=True)
def test_case_5():
    module_0._GetchWindows()

@pytest.mark.xfail(strict=True)
def test_case_6():
    int_0 = 127
    dict_0 = {int_0: int_0, int_0: int_0}
    module_0.opt_error(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_7():
    bool_0 = False
    var_0 = module_0.get_log_level_from_option(bool_0)
    assert var_0 == 50
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    var_1 = var_0.__repr__()
    assert var_1 == '50'
    var_2 = var_1.__repr__()
    assert var_2 == "'50'"
    var_2.__call__()

@pytest.mark.xfail(strict=True)
def test_case_8():
    getch_unix_0 = module_0._GetchUnix()
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    int_0 = -755
    var_0 = module_0.get_log_level_from_option(int_0)
    assert var_0 == 20
    var_1 = var_0.__str__()
    assert var_1 == '20'
    var_2 = var_1.__str__()
    assert var_2 == '20'
    var_3 = var_2.__str__()
    assert var_3 == '20'
    var_3.__call__()

@pytest.mark.xfail(strict=True)
def test_case_9():
    int_0 = 941
    var_0 = module_0.get_log_level_from_option(int_0)
    assert var_0 == 20
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    bool_0 = True
    var_1 = module_0.sigterm_handler(bool_0, bool_0)
    var_2 = module_0.get_log_level_from_option(var_1)
    assert var_2 == 20
    var_3 = var_0.__repr__()
    assert var_3 == '20'
    getch_1 = module_0._Getch()
    int_1 = 4
    var_4 = module_0.get_log_level_from_option(int_1)
    assert var_4 == 10
    int_2 = -1311
    var_5 = module_0.get_log_level_from_option(int_2)
    assert var_5 == 20
    var_6 = var_5.__str__()
    assert var_6 == '20'
    var_7 = var_2.__repr__()
    assert var_7 == '20'
    var_8 = var_7.__repr__()
    assert var_8 == "'20'"
    var_9 = var_2.__str__()
    assert var_9 == '20'
    tuple_0 = (var_9, var_4, var_5)
    var_10 = module_0.sigterm_handler(var_8, tuple_0)
    var_11 = var_2.__str__()
    assert var_11 == '20'
    str_0 = 'gq>\tI,g"1bXW3N9:GdTB'
    module_0.opt_error(str_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    int_0 = 941
    var_0 = module_0.get_log_level_from_option(int_0)
    assert var_0 == 20
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    str_0 = "wyJK|'qJwl"
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    int_1 = -693
    bool_0 = True
    var_1 = module_1.ATSerialPortError(getch_0)
    var_2 = module_0.get_log_level_from_option(var_0)
    assert var_2 == 20
    a_t_script_syntax_error_0 = module_1.ATScriptSyntaxError(str_0)
    getch_1 = module_0._Getch()
    int_2 = 3
    var_3 = module_0.get_log_level_from_option(int_2)
    assert var_3 == 20
    var_4 = var_1.__str__()
    var_5 = var_4.__repr__()
    var_6 = bool_0.__repr__()
    var_7 = module_0.sigterm_handler(var_4, int_1)
    var_8 = var_1.__str__()
    module_0.opt_error(var_8)

@pytest.mark.xfail(strict=True)
def test_case_11():
    int_0 = 941
    var_0 = module_0.get_log_level_from_option(int_0)
    assert var_0 == 20
    assert module_0.PROGRAM_NAME == 'attila'
    assert module_0.USAGE == 'Usage: attila [OPTION]... [FILE]\n  \n  With no FILE, run in interactive mode\n  \n  \t-p <device path>\tUse this device to communicate\n  \t-b <baud rate>\t\tUse the specified baudrate to communicate\n  \t-T <default timeout>\tUse the specified timeout as default to communicate\n  \t-B <break>\t\tUse the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  \t-A <True/False>\t\tAbort on failure (Default: True)\n  \t-L <logfile>\t\tEnable log and log to the specified log file (stdout is supported)\n  \t-l <loglevel>\t\tSpecify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO\n  \t-R <True/False>\t\tSpecify value for rtscts (Default: True)\n  \t-D <True/False>\t\tSpecify value for dsrdtr (Default: True)\n  \t-v\t\t\tBe more verbose\n  \t-q\t\t\tBe quiet (print only PRINT ESKs and ERRORS)\n  \t-h\t\t\tShow this page\n  '
    assert module_0.LOG_LEVEL_DEBUG == 4
    assert module_0.LOG_LEVEL_INFO == 3
    assert module_0.LOG_LEVEL_WARN == 2
    assert module_0.LOG_LEVEL_ERROR == 1
    assert module_0.LOG_LEVEL_CRITICAL == 0
    assert module_0.sigterm_called is True
    getch_0 = module_0._Getch()
    assert f'{type(getch_0).__module__}.{type(getch_0).__qualname__}' == 'attila.__main__._Getch'
    bool_0 = True
    var_1 = module_0.sigterm_handler(int_0, var_0)
    bool_1 = True
    int_1 = 2
    var_2 = module_0.get_log_level_from_option(int_1)
    assert var_2 == 30
    var_3 = var_2.__repr__()
    assert var_3 == '30'
    getch_1 = module_0._Getch()
    var_4 = module_0.get_log_level_from_option(var_1)
    assert var_4 == 20
    var_5 = var_1.__str__()
    var_6 = var_0.__repr__()
    assert var_6 == '20'
    var_7 = var_4.__repr__()
    assert var_7 == '20'
    var_8 = module_0.sigterm_handler(bool_0, bool_1)
    var_9 = var_6.__str__()
    assert var_9 == '20'
    module_0.opt_error(var_0)