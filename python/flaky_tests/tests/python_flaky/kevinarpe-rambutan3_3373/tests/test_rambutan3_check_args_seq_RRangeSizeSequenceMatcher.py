# Automatically generated by Pynguin.
import pytest
import rambutan3.check_args.seq.RSequenceEnum as module_0
import rambutan3.check_args.seq.RRangeSizeSequenceMatcher as module_1

@pytest.mark.xfail(strict=True)
def test_case_0():
    r_sequence_enum_0 = module_0.RSequenceEnum.TUPLE
    module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0)

def test_case_1():
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_0 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_0)
    assert bool_0 is True
    str_0 = r_range_size_sequence_matcher_0.__str__()
    assert str_0 == 'tuple | Sequence | list | MutableSequence where size <= 4'

def test_case_2():
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_0 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_0)
    assert bool_0 is True
    bool_1 = r_range_size_sequence_matcher_0.matches(r_sequence_enum_0)
    assert bool_1 is False

def test_case_3():
    r_sequence_enum_0 = module_0.RSequenceEnum.LIST
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_0 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_0)
    assert bool_0 is True

def test_case_4():
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    bool_0 = False
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=bool_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_1 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_0)
    assert bool_1 is True
    var_0 = r_range_size_sequence_matcher_0.__or__(r_range_size_sequence_matcher_0)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'rambutan3.check_args.base.RAbstractTypeMatcher.RLogicalOrTypeMatcher'
    str_0 = r_range_size_sequence_matcher_0.__str__()
    assert str_0 == 'tuple | Sequence | list | MutableSequence where size <= False'

@pytest.mark.xfail(strict=True)
def test_case_5():
    none_type_0 = None
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    bool_0 = False
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    str_0 = r_range_size_sequence_matcher_0.__str__()
    assert str_0 == 'tuple | Sequence | list | MutableSequence where size <= 4'
    tuple_0 = ()
    str_1 = '\n    Subclass of {@link str} that guarantees its value is not empty (length > 0).\n\n    This class is fully tested.\n\n    @author Kevin Connor ARPE (kevinarpe@gmail.com)\n    '
    var_0 = r_range_size_sequence_matcher_0.check_arg(tuple_0, str_1)
    var_0.add_failed_match(bool_0, none_type_0)

def test_case_6():
    none_type_0 = None
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_0 = r_range_size_sequence_matcher_0.__eq__(none_type_0)
    assert bool_0 is False
    str_0 = r_range_size_sequence_matcher_0.__str__()
    assert str_0 == 'tuple | Sequence | list | MutableSequence where size <= 4'

@pytest.mark.xfail(strict=True)
def test_case_7():
    none_type_0 = None
    r_sequence_enum_0 = module_0.RSequenceEnum.SEQUENCE
    bool_0 = False
    int_0 = 4
    r_range_size_sequence_matcher_0 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_0, max_size=int_0)
    assert f'{type(r_range_size_sequence_matcher_0).__module__}.{type(r_range_size_sequence_matcher_0).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_1 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_0)
    assert bool_1 is True
    r_sequence_enum_1 = module_0.RSequenceEnum.LIST
    r_range_size_sequence_matcher_1 = module_1.RRangeSizeSequenceMatcher(r_sequence_enum_1, max_size=bool_0)
    assert f'{type(r_range_size_sequence_matcher_1).__module__}.{type(r_range_size_sequence_matcher_1).__qualname__}' == 'rambutan3.check_args.seq.RRangeSizeSequenceMatcher.RRangeSizeSequenceMatcher'
    bool_2 = r_range_size_sequence_matcher_0.__eq__(r_range_size_sequence_matcher_1)
    r_range_size_sequence_matcher_1.__or__(none_type_0)