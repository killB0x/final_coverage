# Automatically generated by Pynguin.
import pytest
import compyle.transpiler as module_0
import compyle.config as module_1

def test_case_0():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}

@pytest.mark.xfail(strict=True)
def test_case_1():
    str_0 = 'cuda'
    var_0 = module_0.filter_calls(str_0)
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    module_0.Transpiler(str_0, str_0)

@pytest.mark.xfail(strict=True)
def test_case_2():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    transpiler_0.add(transpiler_0)

@pytest.mark.xfail(strict=True)
def test_case_3():
    transpiler_0 = module_1.get_config()
    module_0.get_external_symbols_and_calls(transpiler_0, transpiler_0)

@pytest.mark.xfail(strict=True)
def test_case_4():
    none_type_0 = None
    module_0.convert_to_float_if_needed(none_type_0)

def test_case_5():
    none_type_0 = None
    code_block_0 = module_0.CodeBlock(none_type_0, none_type_0)
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    var_0 = code_block_0.__eq__(code_block_0)
    assert var_0 is True

def test_case_6():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    var_0 = transpiler_0.add_code(transpiler_0)
    var_1 = transpiler_0.add(transpiler_0)

def test_case_7():
    complex_0 = (2472.4389761933057-2097j)
    transpiler_0 = module_0.Transpiler(complex_0)
    assert f'{type(transpiler_0).__module__}.{type(transpiler_0).__qualname__}' == 'compyle.transpiler.Transpiler'
    assert transpiler_0.backend == (2472.4389761933057-2097j)
    assert transpiler_0.blocks == []
    assert transpiler_0.mod is None
    assert transpiler_0.source == ''
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}

@pytest.mark.xfail(strict=True)
def test_case_8():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    transpiler_0.compile()

@pytest.mark.xfail(strict=True)
def test_case_9():
    bool_0 = False
    module_0.filter_calls(bool_0)

@pytest.mark.xfail(strict=True)
def test_case_10():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    var_0 = transpiler_0.get_code()
    assert var_0 == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    var_1 = transpiler_0.add_code(transpiler_0)
    var_2 = transpiler_0.add(transpiler_0)
    transpiler_0.compile()

def test_case_11():
    str_0 = 'k\n)&'
    transpiler_0 = module_0.Transpiler(str_0)
    assert f'{type(transpiler_0).__module__}.{type(transpiler_0).__qualname__}' == 'compyle.transpiler.Transpiler'
    assert transpiler_0.backend == 'k\n)&'
    assert transpiler_0.blocks == []
    assert transpiler_0.mod is None
    assert transpiler_0.source == ''
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    var_0 = transpiler_0.compile()

@pytest.mark.xfail(strict=True)
def test_case_12():
    transpiler_0 = module_0.Transpiler()
    assert transpiler_0.backend == 'cython'
    assert transpiler_0.source == ''
    assert transpiler_0.header == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    assert module_0.BUILTINS == {'erf', 'lgamma', 'comb', 'gamma', 'modf', 'local_barrier', 'cosh', 'nextafter', 'atan2', 'atan', 'atanh', 'fabs', 'copysign', 'nan', 'acosh', 'erfc', 'frexp', 'range', 'isfinite', 'declare', 'abs', 'tau', 'min', 'log1p', 'cos', 'asinh', 'hypot', 'isnan', 'printf', 'sin', 'remainder', 'sinh', 'inf', 'log10', 'degrees', 'exp', 'dist', 'isinf', 'fsum', 'fmod', 'gcd', 'annotate', 'sqrt', 'pow', 'e', 'tan', 'ceil', 'asin', 'acos', 'factorial', 'pi', 'expm1', 'tanh', 'isclose', 'floor', 'perm', 'trunc', 'prod', 'ldexp', 'isqrt', 'radians', 'log', 'ulp', 'max', 'lcm', 'log2'}
    assert module_0.BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'GID_2', 'GDIM_2', 'M_LOG10E', 'HUGE_VALF', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'M_E', 'LDIM_2', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.CY_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'HUGE_VAL', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'HUGE_VALL', 'M_LN2', 'M_1_PI', 'e', 'LDIM_2', 'M_E', 'pi', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'M_2_SQRTPI', 'LID_0'}
    assert module_0.OCL_BUILTIN_SYMBOLS == {'GDIM_1', 'LID_2', 'INFINITY', 'M_LOG2E', 'GID_0', 'LDIM_1', 'GDIM_0', 'GID_1', 'M_2_PI', 'M_PI_4', 'M_SQRT2', 'M_LOG10E', 'GID_2', 'HUGE_VALF', 'GDIM_2', 'M_LN10', 'M_PI', 'M_LN2', 'M_1_PI', 'LDIM_2', 'M_E', 'NAN', 'LDIM_0', 'M_PI_2', 'LID_1', 'M_SQRT1_2', 'MAXFLOAT', 'M_2_SQRTPI', 'LID_0'}
    var_0 = transpiler_0.get_code()
    assert var_0 == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    var_1 = module_0.filter_calls(var_0)
    var_2 = transpiler_0.add_code(var_0)
    str_0 = '\twW}OTLI&Wk<TN_'
    var_3 = var_1.__eq__(var_1)
    transpiler_1 = module_0.Transpiler(str_0)
    assert f'{type(transpiler_1).__module__}.{type(transpiler_1).__qualname__}' == 'compyle.transpiler.Transpiler'
    assert transpiler_1.backend == '\twW}OTLI&Wk<TN_'
    assert transpiler_1.blocks == []
    assert transpiler_1.mod is None
    assert transpiler_1.source == ''
    var_4 = transpiler_0.add(var_0)
    var_5 = transpiler_0.get_code()
    assert var_5 == '\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n\n\n# cython: language_level=3\nfrom libc.stdio cimport printf\nfrom libc.math cimport *\nfrom libc.math cimport fabs as abs\nfrom cython.parallel import parallel, prange\n'
    transpiler_0.add(transpiler_0)

@pytest.mark.xfail(strict=True)
def test_case_13():
    str_0 = 'cuda'
    module_0.Transpiler(str_0, str_0)