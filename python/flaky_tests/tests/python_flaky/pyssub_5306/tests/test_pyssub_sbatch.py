# Automatically generated by Pynguin.
import pytest
import pyssub.sbatch as module_0
import json.decoder as module_1
import codecs as module_2

def test_case_0():
    s_batch_script_encoder_0 = module_0.SBatchScriptEncoder()
    with pytest.raises(TypeError):
        s_batch_script_encoder_0.default(s_batch_script_encoder_0)

def test_case_1():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()

def test_case_2():
    str_0 = "{49^'?aX:qe"
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''

def test_case_3():
    str_0 = 'urph'
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    dict_0 = {str_0: str_0}
    s_batch_script_macro_0 = module_0.SBatchScriptMacro(s_batch_script_0, s_batch_script_decoder_0)
    var_0 = s_batch_script_decoder_0.__call__(dict_0)
    bool_0 = s_batch_script_0.__eq__(s_batch_script_0)
    assert bool_0 is True

def test_case_4():
    str_0 = "{49^'?aX:qe"
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    str_1 = s_batch_script_0.__str__()
    assert str_1 == '#!/usr/bin/env bash\n\n\n\necho "Working on node `hostname`."\necho "Current directory: `pwd`"\n\nif [ -z $SLURM_JOB_ID ]\nthen\n    workdir="slurm"\nelse\n    workdir="slurm_$SLURM_JOB_ID"\nfi\n\necho \'Create working directory:\'\nmkdir -v $workdir\n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    exit $status\nfi\n\nfunction cleanup() {\n    echo \'Remove working directory:\'\n    cd ..\n    rm -rv $workdir\n}\n\ncd $workdir\n\nexecutable={49^\'?aX:qe\ntransfer_executable=false\n\nif [ "$transfer_executable" = "true" ]\nthen\n    echo \'Transfer executable to node:\'\n    cp -v $executable .\n\n    status=$?\n    if [ $status -ne 0 ]\n    then\n        cleanup\n        exit $status\n    fi\n\n    executable=./`basename $executable`\nfi\n\ninputfiles=()\n\necho \'Transfer input files to node:\'\nstatus=0\nfor inputfile in ${inputfiles[*]}\ndo\n    cp -v $inputfile .\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\necho \'Execute...\'\n$executable \n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\noutputfiles=()\n\necho \'Transfer output files:\'\nstatus=0\nfor outputfile in ${outputfiles[*]}\ndo\n    mv -v `basename $outputfile` $outputfile\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\ncleanup'

def test_case_5():
    str_0 = 'urph'
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    dict_0 = {str_0: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_0)

def test_case_6():
    str_0 = '<pyssub.sbatch.SBatchScriptDecoder object at 0x7f4eff62eec0>'
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    bool_0 = s_batch_script_0.__eq__(s_batch_script_0)
    assert bool_0 is True

def test_case_7():
    str_0 = 'urph'
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    dict_0 = {str_0: str_0}
    s_batch_script_macro_0 = module_0.SBatchScriptMacro(s_batch_script_0, s_batch_script_decoder_0)
    str_1 = s_batch_script_macro_0.__str__()
    assert str_1 == '#!/usr/bin/env bash\n\n\n\necho "Working on node `hostname`."\necho "Current directory: `pwd`"\n\nif [ -z $SLURM_JOB_ID ]\nthen\n    workdir="slurm"\nelse\n    workdir="slurm_$SLURM_JOB_ID"\nfi\n\necho \'Create working directory:\'\nmkdir -v $workdir\n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    exit $status\nfi\n\nfunction cleanup() {\n    echo \'Remove working directory:\'\n    cd ..\n    rm -rv $workdir\n}\n\ncd $workdir\n\nexecutable=urph\ntransfer_executable=false\n\nif [ "$transfer_executable" = "true" ]\nthen\n    echo \'Transfer executable to node:\'\n    cp -v $executable .\n\n    status=$?\n    if [ $status -ne 0 ]\n    then\n        cleanup\n        exit $status\n    fi\n\n    executable=./`basename $executable`\nfi\n\ninputfiles=()\n\necho \'Transfer input files to node:\'\nstatus=0\nfor inputfile in ${inputfiles[*]}\ndo\n    cp -v $inputfile .\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\necho \'Execute...\'\n$executable \n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\noutputfiles=()\n\necho \'Transfer output files:\'\nstatus=0\nfor outputfile in ${outputfiles[*]}\ndo\n    mv -v `basename $outputfile` $outputfile\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\ncleanup'
    var_0 = s_batch_script_decoder_0.__call__(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = '2rph'
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    dict_0 = {str_0: str_0}
    s_batch_script_macro_0 = module_0.SBatchScriptMacro(s_batch_script_0, s_batch_script_decoder_0)
    str_1 = s_batch_script_macro_0.__str__()
    assert str_1 == '#!/usr/bin/env bash\n\n\n\necho "Working on node `hostname`."\necho "Current directory: `pwd`"\n\nif [ -z $SLURM_JOB_ID ]\nthen\n    workdir="slurm"\nelse\n    workdir="slurm_$SLURM_JOB_ID"\nfi\n\necho \'Create working directory:\'\nmkdir -v $workdir\n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    exit $status\nfi\n\nfunction cleanup() {\n    echo \'Remove working directory:\'\n    cd ..\n    rm -rv $workdir\n}\n\ncd $workdir\n\nexecutable=2rph\ntransfer_executable=false\n\nif [ "$transfer_executable" = "true" ]\nthen\n    echo \'Transfer executable to node:\'\n    cp -v $executable .\n\n    status=$?\n    if [ $status -ne 0 ]\n    then\n        cleanup\n        exit $status\n    fi\n\n    executable=./`basename $executable`\nfi\n\ninputfiles=()\n\necho \'Transfer input files to node:\'\nstatus=0\nfor inputfile in ${inputfiles[*]}\ndo\n    cp -v $inputfile .\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\necho \'Execute...\'\n$executable \n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\noutputfiles=()\n\necho \'Transfer output files:\'\nstatus=0\nfor outputfile in ${outputfiles[*]}\ndo\n    mv -v `basename $outputfile` $outputfile\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\ncleanup'
    s_batch_script_macro_1 = module_0.SBatchScriptMacro(s_batch_script_0, dict_0)
    str_2 = s_batch_script_macro_0.__str__()
    assert str_2 == '#!/usr/bin/env bash\n\n\n\necho "Working on node `hostname`."\necho "Current directory: `pwd`"\n\nif [ -z $SLURM_JOB_ID ]\nthen\n    workdir="slurm"\nelse\n    workdir="slurm_$SLURM_JOB_ID"\nfi\n\necho \'Create working directory:\'\nmkdir -v $workdir\n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    exit $status\nfi\n\nfunction cleanup() {\n    echo \'Remove working directory:\'\n    cd ..\n    rm -rv $workdir\n}\n\ncd $workdir\n\nexecutable=2rph\ntransfer_executable=false\n\nif [ "$transfer_executable" = "true" ]\nthen\n    echo \'Transfer executable to node:\'\n    cp -v $executable .\n\n    status=$?\n    if [ $status -ne 0 ]\n    then\n        cleanup\n        exit $status\n    fi\n\n    executable=./`basename $executable`\nfi\n\ninputfiles=()\n\necho \'Transfer input files to node:\'\nstatus=0\nfor inputfile in ${inputfiles[*]}\ndo\n    cp -v $inputfile .\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\necho \'Execute...\'\n$executable \n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\noutputfiles=()\n\necho \'Transfer output files:\'\nstatus=0\nfor outputfile in ${outputfiles[*]}\ndo\n    mv -v `basename $outputfile` $outputfile\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\ncleanup'
    var_0 = s_batch_script_decoder_0.__call__(dict_0)
    bool_0 = s_batch_script_macro_1.__eq__(s_batch_script_macro_0)
    assert bool_0 is True
    module_1.py_scanstring(var_0, str_0, s_batch_script_macro_0)

def test_case_9():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = 'executable'
    dict_0 = {}
    str_1 = 'transfer_input_files'
    dict_1 = {str_0: dict_0, str_1: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert var_0.executable == {}
    assert var_0.arguments == ''
    assert var_0.options == {}
    assert var_0.transfer_executable is False
    assert var_0.transfer_input_files == ['e', 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l', 'e']
    assert var_0.transfer_output_files == []

def test_case_10():
    str_0 = '54lMNFEYLqm1uzj'
    none_type_0 = None
    s_batch_script_encoder_0 = module_0.SBatchScriptEncoder(allow_nan=str_0, sort_keys=none_type_0, default=none_type_0)
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    var_0 = s_batch_script_encoder_0.encode(s_batch_script_0)
    assert var_0 == '{"executable": "54lMNFEYLqm1uzj", "transfer_executable": false}'

@pytest.mark.xfail(strict=True)
def test_case_11():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = '5lMNFEYLqm1uzj'
    none_type_0 = None
    dict_0 = {none_type_0: s_batch_script_decoder_0, str_0: none_type_0}
    str_1 = ':J'
    dict_1 = {str_0: dict_0, str_1: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    s_batch_script_encoder_0 = module_0.SBatchScriptEncoder(allow_nan=str_0, sort_keys=none_type_0, default=none_type_0)
    none_type_1 = None
    s_batch_script_0 = module_0.SBatchScript(none_type_1, str_0)
    dict_2 = {}
    bool_0 = s_batch_script_0.__eq__(none_type_0)
    assert bool_0 is False
    none_type_2 = None
    var_1 = s_batch_script_encoder_0.encode(s_batch_script_0)
    assert var_1 == '{"executable": null, "arguments": "5lMNFEYLqm1uzj", "transfer_executable": false}'
    s_batch_script_encoder_1 = module_0.SBatchScriptEncoder(ensure_ascii=none_type_0, check_circular=str_0, allow_nan=s_batch_script_encoder_0, sort_keys=none_type_2)
    module_2.open(s_batch_script_0, s_batch_script_decoder_0, errors=dict_2)

def test_case_12():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = 'Q9LgcVVSM'
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''
    str_1 = ''
    none_type_0 = None
    dict_0 = {}
    str_2 = '*Pyun[DTpI'
    dict_1 = {str_1: dict_0, str_2: str_1}
    str_3 = s_batch_script_0.__str__()
    assert str_3 == '#!/usr/bin/env bash\n\n\n\necho "Working on node `hostname`."\necho "Current directory: `pwd`"\n\nif [ -z $SLURM_JOB_ID ]\nthen\n    workdir="slurm"\nelse\n    workdir="slurm_$SLURM_JOB_ID"\nfi\n\necho \'Create working directory:\'\nmkdir -v $workdir\n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    exit $status\nfi\n\nfunction cleanup() {\n    echo \'Remove working directory:\'\n    cd ..\n    rm -rv $workdir\n}\n\ncd $workdir\n\nexecutable=Q9LgcVVSM\ntransfer_executable=false\n\nif [ "$transfer_executable" = "true" ]\nthen\n    echo \'Transfer executable to node:\'\n    cp -v $executable .\n\n    status=$?\n    if [ $status -ne 0 ]\n    then\n        cleanup\n        exit $status\n    fi\n\n    executable=./`basename $executable`\nfi\n\ninputfiles=()\n\necho \'Transfer input files to node:\'\nstatus=0\nfor inputfile in ${inputfiles[*]}\ndo\n    cp -v $inputfile .\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\necho \'Execute...\'\n$executable \n\nstatus=$?\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\noutputfiles=()\n\necho \'Transfer output files:\'\nstatus=0\nfor outputfile in ${outputfiles[*]}\ndo\n    mv -v `basename $outputfile` $outputfile\n    status+=$?\ndone\n\nif [ $status -ne 0 ]\nthen\n    cleanup\n    exit $status\nfi\n\ncleanup'
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    bool_0 = var_0.__eq__(none_type_0)
    s_batch_script_macro_0 = module_0.SBatchScriptMacro(s_batch_script_0, dict_0)
    s_batch_script_encoder_0 = module_0.SBatchScriptEncoder(allow_nan=str_1, sort_keys=none_type_0, default=none_type_0)
    s_batch_script_1 = module_0.SBatchScript(str_1)
    assert s_batch_script_1.arguments == ''
    bool_1 = s_batch_script_1.__eq__(none_type_0)
    assert bool_1 is False
    var_1 = s_batch_script_encoder_0.encode(s_batch_script_macro_0)
    assert var_1 == '{"script": {"executable": "Q9LgcVVSM", "transfer_executable": false}, "macros": {}}'

@pytest.mark.xfail(strict=True)
def test_case_13():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = "Submit Slurm batch script.\n\n    Parameters\n    ----------\n    script : SBatchScript\n        Slurm batch script\n    partition : str, optional\n        Partition for resource allocation\n\n    Returns\n    -------\n    int\n        Job ID\n\n    Raises\n    ------\n    RuntimeError\n        If job ID cannot be matched from `sbatch`'s output.\n\n    "
    s_batch_script_decoder_0.__call__(str_0)

def test_case_14():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = 'executable'
    dict_0 = {}
    dict_1 = {str_0: dict_0, str_0: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert var_0.executable == 'executable'
    assert var_0.arguments == ''
    assert var_0.options == {}
    assert var_0.transfer_executable is False
    assert var_0.transfer_input_files == []
    assert var_0.transfer_output_files == []
    s_batch_script_0 = module_0.SBatchScript(str_0)
    assert s_batch_script_0.arguments == ''

def test_case_15():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = 'executable'
    dict_0 = {}
    str_1 = 'transfer_input_files'
    dict_1 = {str_0: dict_0, str_1: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert var_0.executable == {}
    assert var_0.arguments == ''
    assert var_0.options == {}
    assert var_0.transfer_executable is False
    assert var_0.transfer_input_files == ['e', 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l', 'e']
    assert var_0.transfer_output_files == []
    bool_0 = var_0.__eq__(str_0)
    assert bool_0 is False
    s_batch_script_decoder_1 = module_0.SBatchScriptDecoder()

def test_case_16():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = 'executable'
    none_type_0 = None
    dict_0 = {}
    str_1 = 'transfer_input_files'
    dict_1 = {str_0: dict_0, str_1: str_0}
    var_0 = s_batch_script_decoder_0.__call__(dict_1)
    assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert var_0.executable == {}
    assert var_0.arguments == ''
    assert var_0.options == {}
    assert var_0.transfer_executable is False
    assert var_0.transfer_input_files == ['e', 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l', 'e']
    assert var_0.transfer_output_files == []
    bool_0 = var_0.__eq__(none_type_0)
    assert bool_0 is False
    s_batch_script_encoder_0 = module_0.SBatchScriptEncoder(allow_nan=str_0, sort_keys=none_type_0, default=none_type_0)
    s_batch_script_decoder_1 = module_0.SBatchScriptDecoder()
    s_batch_script_decoder_2 = module_0.SBatchScriptDecoder()
    var_1 = s_batch_script_encoder_0.encode(var_0)
    assert var_1 == '{"executable": {}, "transfer_executable": false, "transfer_input_files": ["e", "x", "e", "c", "u", "t", "a", "b", "l", "e"]}'
    s_batch_script_0 = module_0.SBatchScript(var_0)
    assert f'{type(s_batch_script_0.executable).__module__}.{type(s_batch_script_0.executable).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert s_batch_script_0.arguments == ''

@pytest.mark.xfail(strict=True)
def test_case_17():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = "Submit Slurm batch script.\n\n    Parameters\n    ----------\n    script : SBatchScript\n        Slurm batch script\n    partition : str, optional\n        Partition for resource allocation\n\n    Returns\n    -------\n    int\n        Job ID\n\n    Raises\n    ------\n    RuntimeError\n        If job ID cannot be matched from `sbatch`'s output.\n\n    "
    var_0 = module_2.make_identity_dict(str_0)
    str_1 = 'executable'
    var_1 = s_batch_script_decoder_0.__call__(var_0)
    dict_0 = {}
    str_2 = 'options'
    var_2 = var_0.__iter__()
    dict_1 = {str_1: dict_0, str_2: str_1}
    str_3 = 'Q9LgcVV'
    s_batch_script_0 = module_0.SBatchScript(str_3)
    assert s_batch_script_0.arguments == ''
    s_batch_script_decoder_0.__call__(dict_1)

@pytest.mark.xfail(strict=True)
def test_case_18():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    none_type_0 = None
    str_0 = 'script'
    dict_0 = {str_0: str_0, str_0: none_type_0}
    s_batch_script_decoder_0.decode_macro(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_19():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    none_type_0 = None
    str_0 = 'script'
    str_1 = "f! 3#'s"
    dict_0 = {str_0: str_0, str_1: none_type_0}
    s_batch_script_decoder_0.decode_macro(dict_0)

@pytest.mark.xfail(strict=True)
def test_case_20():
    s_batch_script_decoder_0 = module_0.SBatchScriptDecoder()
    str_0 = "Submit Slurm batch script.\n\n    Parameters\n    ----------\n    script : SBatchScript\n        Slurm batch script\n    partition : str, optional\n        Partition for resource allocation\n\n    Returns\n    -------\n    int\n        Job ID\n\n    Raises\n    ------\n    RuntimeError\n        If job ID cannot be matched from `sbatch`'s output.\n\n    "
    var_0 = module_2.make_identity_dict(str_0)
    str_1 = 'executable'
    none_type_0 = None
    var_1 = s_batch_script_decoder_0.__call__(var_0)
    dict_0 = {}
    str_2 = 'options'
    var_2 = var_0.__iter__()
    dict_1 = {str_1: dict_0, str_2: var_1}
    str_3 = 'Q9LgcVV'
    s_batch_script_0 = module_0.SBatchScript(str_3)
    assert s_batch_script_0.arguments == ''
    var_3 = s_batch_script_decoder_0.__call__(dict_1)
    assert f'{type(var_3).__module__}.{type(var_3).__qualname__}' == 'pyssub.sbatch.SBatchScript'
    assert var_3.executable == {}
    assert var_3.arguments == ''
    assert var_3.options == {'S': 'S', 'u': 'u', 'b': 'b', 'm': 'm', 'i': 'i', 't': 't', ' ': ' ', 'l': 'l', 'r': 'r', 'a': 'a', 'c': 'c', 'h': 'h', 's': 's', 'p': 'p', '.': '.', '\n': '\n', 'P': 'P', 'e': 'e', '-': '-', ':': ':', 'B': 'B', 'o': 'o', 'n': 'n', ',': ',', 'f': 'f', 'R': 'R', 'J': 'J', 'I': 'I', 'D': 'D', 'E': 'E', 'j': 'j', 'd': 'd', '`': '`', "'": "'"}
    assert var_3.transfer_executable is False
    assert var_3.transfer_input_files == []
    assert var_3.transfer_output_files == []
    bool_0 = var_3.__eq__(none_type_0)
    assert bool_0 is False
    var_1.__enter__()