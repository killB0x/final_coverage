# Automatically generated by Pynguin.
import string_utils.manipulation as module_0
import _frozen_importlib as module_1


def test_case_0():
    string_compressor_0 = module_0.__StringCompressor()


def test_case_1():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    bool_0 = module_0.booleanize(str_0)
    str_1 = "e`Fs;_sjoxm]]C<"
    roman_numbers_0 = module_0.__RomanNumbers()
    str_2 = module_0.compress(str_1)


def test_case_2():
    str_0 = '\x0b/"/p4h&U'
    module_0.roman_encode(str_0)


def test_case_3():
    str_0 = "_"
    module_0.roman_decode(str_0)


def test_case_4():
    none_type_0 = None
    module_0.roman_decode(none_type_0)


def test_case_5():
    str_0 = "ZC"
    module_0.decompress(str_0)


def test_case_6():
    str_0 = "yC9\x0cRc\r%]%"
    str_1 = module_0.strip_html(str_0)
    none_type_0 = None
    str_2 = "Hi7BsN5D M"
    int_0 = 11
    module_0.compress(none_type_0, str_2, int_0)


def test_case_7():
    str_0 = "jI"
    str_1 = module_0.prettify(str_0)


def test_case_8():
    str_0 = "DN424!Y?\x0c8"
    str_1 = module_0.snake_case_to_camel(str_0)
    str_2 = "y26*ef<"
    bool_0 = module_0.booleanize(str_2)
    module_0.__StringFormatter(bool_0)


def test_case_9():
    none_type_0 = None
    module_0.reverse(none_type_0)


def test_case_10():
    str_0 = "egk"
    str_1 = module_0.strip_margin(str_0)
    str_2 = module_0.camel_case_to_snake(str_0)


def test_case_11():
    str_0 = "contains_html"
    str_1 = module_0.snake_case_to_camel(str_0)


def test_case_12():
    str_0 = "2usS0V+4"
    str_1 = module_0.shuffle(str_0)


def test_case_13():
    none_type_0 = None
    module_0.shuffle(none_type_0)


def test_case_14():
    str_0 = "M#chhR\rJ!PN6"
    str_1 = module_0.shuffle(str_0)
    str_2 = module_0.reverse(str_0)
    str_3 = "[SJvj"
    bool_0 = False
    str_4 = module_0.asciify(str_0)
    str_5 = module_0.strip_html(str_3, bool_0)
    roman_numbers_0 = module_0.__RomanNumbers()


def test_case_15():
    none_type_0 = None
    module_0.strip_html(none_type_0)


def test_case_16():
    str_0 = "7J`m]m_Dx:JD7z"
    bool_0 = module_0.booleanize(str_0)
    str_1 = module_0.asciify(str_0)


def test_case_17():
    str_0 = "@"
    str_1 = module_0.slugify(str_0)
    string_formatter_0 = module_0.__StringFormatter(str_1)
    str_2 = string_formatter_0.format()
    str_3 = "?V"
    string_compressor_0 = module_0.__StringCompressor()
    str_4 = module_0.shuffle(str_3)


def test_case_18():
    none_type_0 = None
    string_compressor_0 = module_0.__StringCompressor()
    module_0.slugify(none_type_0)


def test_case_19():
    str_0 = "7J`m]m_Dx:JD7z"
    bool_0 = module_0.booleanize(str_0)


def test_case_20():
    none_type_0 = None
    module_0.booleanize(none_type_0)


def test_case_21():
    str_0 = "4\t-u_lrS2z[u#Ax%e("
    str_1 = module_0.strip_margin(str_0)


def test_case_22():
    str_0 = ""
    string_formatter_0 = module_0.__StringFormatter(str_0)
    str_1 = string_formatter_0.format()
    str_2 = string_formatter_0.format()
    bool_0 = module_0.booleanize(str_0)
    str_3 = "R>iMKRhug"
    str_4 = module_0.prettify(str_3)
    none_type_0 = None
    module_0.strip_margin(none_type_0)


def test_case_23():
    str_0 = "\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    "
    str_1 = module_0.prettify(str_0)


def test_case_24():
    str_0 = "is_decimal"
    str_1 = "\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    "
    str_2 = module_0.prettify(str_1)
    str_3 = module_0.camel_case_to_snake(str_0)
    str_3.__getitem__(str_3, str_3)


def test_case_25():
    str_0 = "7J`m]m_Dx:JD7z"
    str_1 = module_0.prettify(str_0)


def test_case_26():
    str_0 = "]-h4J&b&&~l(%L{\tT"
    str_1 = module_0.prettify(str_0)


def test_case_27():
    int_0 = -767
    module_0.roman_encode(int_0)


def test_case_28():
    str_0 = "_2}W$<(^"
    int_0 = -2483
    module_0.compress(str_0, compression_level=int_0)


def test_case_29():
    str_0 = "conta(ns_hml"
    str_1 = module_0.snake_case_to_camel(str_0)


def test_case_30():
    str_0 = "Li@"
    int_0 = 14
    str_1 = ",>\rB5waz"
    bool_0 = module_0.booleanize(str_1)
    str_2 = "\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded    into the compressed string in order to be able to restore it later on)\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    "
    str_3 = "e`Fs;_sjoxm]]C<"
    roman_numbers_0 = module_0.__RomanNumbers()
    str_4 = module_0.snake_case_to_camel(str_2, separator=str_3)
    module_0.compress(str_0, compression_level=int_0)


def test_case_31():
    string_compressor_0 = module_0.__StringCompressor()
    str_0 = "is_pangram"
    bool_0 = False
    str_1 = module_0.snake_case_to_camel(str_0, bool_0)
    string_compressor_1 = module_0.__StringCompressor()
    str_2 = "(_)([a-z\\d])"
    str_3 = module_0.slugify(str_2)
    str_4 = module_0.snake_case_to_camel(str_3)
    str_5 = module_0.camel_case_to_snake(str_2)
    string_formatter_0 = module_0.__StringFormatter(str_5)
    str_6 = "JCMzdC(5{cXIK\x0ctEX"
    str_7 = module_0.shuffle(str_6)
    bytes_0 = b"\x80U \xfb"
    module_0.__StringFormatter(bytes_0)


def test_case_32():
    str_0 = "t@YQ+:(G\\"
    str_1 = module_0.prettify(str_0)
    bytes_0 = b"-\xf5\xc4\xe4\xf5\xdc\x0b"
    str_2 = "\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    "
    str_3 = module_0.asciify(str_2)
    module_0.camel_case_to_snake(bytes_0)


def test_case_33():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = ",>\rB5waz"
    bool_0 = module_0.booleanize(str_2)
    str_3 = "\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded    into the compressed string in order to be able to restore it later on)\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    "
    str_4 = "e`Fs;_sjoxm]]C<"
    str_5 = module_0.prettify(str_4)
    roman_numbers_0 = module_0.__RomanNumbers()
    str_6 = module_0.snake_case_to_camel(str_3)
    module_0.compress(str_5, compression_level=int_0)


def test_case_34():
    none_type_0 = None
    module_0.asciify(none_type_0)


def test_case_35():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = ",>\rB5waz"
    bool_0 = module_0.booleanize(str_2)
    str_3 = "e`Fs;_sjoxm]]C<"
    str_4 = module_0.prettify(str_3)
    none_type_0 = None
    module_0.snake_case_to_camel(none_type_0)


def test_case_36():
    string_compressor_0 = module_0.__StringCompressor()
    str_0 = "~,,hXFmg#}O"
    str_1 = module_0.prettify(str_0)
    string_formatter_0 = module_0.__StringFormatter(str_1)
    str_2 = "isu_pangra"
    str_3 = module_0.camel_case_to_snake(str_0, string_formatter_0)
    bool_0 = False
    str_4 = module_0.snake_case_to_camel(str_2, bool_0)
    str_5 = "qkqCs{>>"
    str_6 = module_0.reverse(str_5)
    string_compressor_1 = module_0.__StringCompressor()
    str_7 = "(_)([a-z\\d])"
    str_8 = module_0.slugify(str_7)
    builtin_importer_0 = module_1.BuiltinImporter()
    none_type_0 = builtin_importer_0.exec_module(str_5)
    str_9 = module_0.snake_case_to_camel(str_5, none_type_0)
    str_10 = module_0.slugify(str_2, str_6)
    str_11 = "%DkQ[hqC("
    str_12 = module_0.shuffle(str_11)
    str_13 = '"{}" must be an integer in the range 1-3999'
    int_0 = 3065
    module_0.compress(str_13, none_type_0, int_0)


def test_case_37():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    str_2 = "Li@"
    str_3 = module_0.strip_margin(str_0)
    int_1 = 14
    str_4 = ",>\rB5waz"
    bool_0 = True
    str_5 = module_0.strip_html(str_1, bool_0)
    bool_1 = module_0.booleanize(str_4)
    str_6 = "\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded    into the compressed string in order to be able to restore it later on)\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    "
    str_7 = "e`Fs;_sjoxm]]C<"
    str_8 = "@{8NUP"
    str_9 = module_0.prettify(str_8)
    roman_numbers_0 = module_0.__RomanNumbers()
    str_10 = module_0.snake_case_to_camel(str_6, separator=str_7)
    module_0.compress(str_2, compression_level=int_1)


def test_case_38():
    int_0 = 320
    str_0 = module_0.roman_encode(int_0)
    str_1 = '"{}" must be an integer in the range 1-3999'
    str_2 = "d"
    str_3 = "*%|EO{5_[D[+G]Ve|/Fh"
    str_4 = module_0.prettify(str_3)
    module_0.compress(str_1, str_2)


def test_case_39():
    int_0 = 1904
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    bool_0 = module_0.booleanize(str_1)
    str_2 = "Ip~mt"
    str_3 = module_0.prettify(str_2)
    str_4 = "e`Fs;_sjoxm]]C<"
    str_5 = module_0.prettify(str_2)
    str_6 = module_0.camel_case_to_snake(str_4)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_7 = module_0.snake_case_to_camel(str_2)
    str_8 = "M|yPuq@`/*o9x"
    roman_numbers_1 = module_0.__RomanNumbers()
    str_9 = module_0.snake_case_to_camel(str_8, bool_0)
    str_10 = "\n5"
    str_11 = module_0.compress(str_10)


def test_case_40():
    int_0 = 1954
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    bool_0 = module_0.booleanize(str_1)
    str_2 = "Ip~mt"
    str_3 = module_0.prettify(str_2)
    str_4 = "e`Fs;_sjoxm]]C<"
    str_5 = module_0.prettify(str_2)
    str_6 = module_0.camel_case_to_snake(str_4)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_7 = "\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    "
    bool_1 = module_0.booleanize(str_7)
    str_8 = ".c\x0bT\x0b1YH*S&<[f,Rt)8>"
    str_9 = '6\x0cmP{"RUz\tQ'
    str_10 = module_0.snake_case_to_camel(str_8, separator=str_9)
    str_11 = "\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    "
    str_12 = module_0.compress(str_11)
    str_13 = "Sf `I;&cx6MF[7T\x0b+?\nw"
    str_14 = "([a-z]+\\d*-[a-z\\d-]*|-+[a-z\\d]+[a-z\\d-]*)$"
    module_0.compress(str_13, str_14)


def test_case_41():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    bool_0 = module_0.booleanize(str_1)
    str_2 = "Ip~mt"
    str_3 = module_0.prettify(str_2)
    str_4 = "e`Fs;_sjoxm]]C<"
    str_5 = module_0.prettify(str_2)
    str_6 = module_0.camel_case_to_snake(str_4)
    str_7 = module_0.snake_case_to_camel(str_2)
    str_8 = "is_credit_card"
    roman_numbers_0 = module_0.__RomanNumbers()
    str_9 = module_0.snake_case_to_camel(str_8, bool_0)
    str_10 = ""
    module_0.compress(str_10)


def test_case_42():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = 'Lp\x0bZQAX,HO&\t\x0b"1'
    bool_0 = module_0.booleanize(str_2)
    str_3 = "\n    Compress the given string by returning a shorter one that can be safely used in any context (like URL) and\n    restored back to its original state using `decompress()`.\n\n    **Bear in mind:**\n    Besides the provided `compression_level`, the compression result (how much the string is actually compressed\n    by resulting into a shorter string) depends on 2 factors:\n\n    1. The amount of data (string size): short strings might not provide a significant compression result    or even be longer than the given input string (this is due to the fact that some bytes have to be embedded    into the compressed string in order to be able to restore it later on)\n    2. The content type: random sequences of chars are very unlikely to be successfully compressed, while the best    compression result is obtained when the string contains several recurring char sequences (like in the example).\n\n    Behind the scenes this method makes use of the standard Python's zlib and base64 libraries.\n\n    *Examples:*\n\n    >>> n = 0 # <- ignore this, it's a fix for Pycharm (not fixable using ignore comments)\n    >>> # \"original\" will be a string with 169 chars:\n    >>> original = ' '.join(['word n{}'.format(n) for n in range(20)])\n    >>> # \"compressed\" will be a string of 88 chars\n    >>> compressed = compress(original)\n\n    :param input_string: String to compress (must be not empty or a ValueError will be raised).\n    :type input_string: str\n    :param encoding: String encoding (default to \"utf-8\").\n    :type encoding: str\n    :param compression_level: A value between 0 (no compression) and 9 (best compression), default to 9.\n    :type compression_level: int\n    :return: Compressed string.\n    "
    str_4 = "e`Fs;_sjoxm]]C<"
    str_5 = module_0.camel_case_to_snake(str_0, str_3)
    str_6 = module_0.prettify(str_4)
    str_7 = "#3c$WX"
    str_8 = module_0.snake_case_to_camel(str_7)
    none_type_0 = None
    module_0.compress(str_1, str_4, none_type_0)


def test_case_43():
    int_0 = 5115
    module_0.roman_encode(int_0)


def test_case_44():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = "f{d$dno_!eO5r"
    str_3 = module_0.strip_margin(str_2)
    bool_0 = module_0.booleanize(str_1)
    str_4 = "Ip~mt"
    str_5 = "aPHxgo"
    str_6 = module_0.prettify(str_4)
    str_7 = module_0.camel_case_to_snake(str_5)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_8 = module_0.snake_case_to_camel(str_4)
    str_9 = "is_credit_card"
    roman_numbers_1 = module_0.__RomanNumbers()
    str_10 = module_0.snake_case_to_camel(str_9, bool_0)
    str_11 = "utf-8"
    module_0.compress(str_11, str_0, int_1)


def test_case_45():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = "f{d$dno_!eO5r"
    str_3 = module_0.strip_margin(str_2)
    bool_0 = module_0.booleanize(str_1)
    str_4 = "Ip~mt"
    str_5 = module_0.prettify(str_4)
    str_6 = "e`Fs;_sjoxm]]C<"
    str_7 = module_0.prettify(str_4)
    str_8 = module_0.camel_case_to_snake(str_6)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_9 = module_0.snake_case_to_camel(str_4)
    str_10 = "is_credit_card"
    roman_numbers_1 = module_0.__RomanNumbers()
    str_11 = module_0.snake_case_to_camel(str_10, bool_0)
    str_12 = "dk_"
    bool_1 = False
    str_13 = module_0.snake_case_to_camel(str_12, bool_1)
    str_14 = "\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    "
    module_0.compress(str_14, str_13)


def test_case_46():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = "f{d$dno_!eO5r"
    str_3 = module_0.strip_margin(str_2)
    bool_0 = module_0.booleanize(str_1)
    str_4 = '\n    Reformat a string by applying the following basic grammar and formatting rules:\n\n    - String cannot start or end with spaces\n    - The first letter in the string and the ones after a dot, an exclamation or a question mark must be uppercase\n    - String cannot have multiple sequential spaces, empty lines or punctuation (except for "?", "!" and ".")\n    - Arithmetic operators (+, -, /, \\*, =) must have one, and only one space before and after themselves\n    - One, and only one space should follow a dot, a comma, an exclamation or a question mark\n    - Text inside double quotes cannot start or end with spaces, but one, and only one space must come first and     after quotes (foo" bar"baz -> foo "bar" baz)\n    - Text inside round brackets cannot start or end with spaces, but one, and only one space must come first and     after brackets ("foo(bar )baz" -> "foo (bar) baz")\n    - Percentage sign ("%") cannot be preceded by a space if there is a number before ("100 %" -> "100%")\n    - Saxon genitive is correct ("Dave\' s dog" -> "Dave\'s dog")\n\n    *Examples:*\n\n    >>> prettify(\' unprettified string ,, like this one,will be"prettified" .it\\\' s awesome! \')\n    >>> # -> \'Unprettified string, like this one, will be "prettified". It\'s awesome!\'\n\n    :param input_string: String to manipulate\n    :return: Prettified string.\n    '
    str_5 = module_0.prettify(str_4)
    str_6 = "e`Fs;_sjoxm]]C<"
    str_7 = module_0.prettify(str_4)
    str_8 = module_0.camel_case_to_snake(str_6)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_9 = module_0.snake_case_to_camel(str_4)
    bool_1 = False
    str_10 = module_0.strip_html(str_0, bool_1)
    str_11 = "is_credit_card"
    roman_numbers_1 = module_0.__RomanNumbers()
    str_12 = module_0.snake_case_to_camel(str_11, bool_0)
    str_13 = "dk_"
    bool_2 = False
    str_14 = module_0.snake_case_to_camel(str_13, bool_2)
    str_15 = "\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    "
    str_16 = module_0.compress(str_15, compression_level=bool_0)


def test_case_47():
    int_0 = 1917
    str_0 = module_0.roman_encode(int_0)
    str_1 = module_0.asciify(str_0)
    int_1 = module_0.roman_decode(str_0)
    str_2 = "f{d$dno_!eO5r"
    str_3 = module_0.strip_margin(str_2)
    bool_0 = module_0.booleanize(str_1)
    str_4 = "Ip~mt"
    str_5 = "\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    "
    str_6 = module_0.prettify(str_5)
    str_7 = module_0.prettify(str_4)
    str_8 = "e`Fs;_sjoxm]]C<"
    str_9 = module_0.prettify(str_4)
    str_10 = module_0.camel_case_to_snake(str_8)
    list_0 = []
    roman_numbers_0 = module_0.__RomanNumbers(*list_0)
    str_11 = module_0.snake_case_to_camel(str_4)
    str_12 = "is_credit_card"
    roman_numbers_1 = module_0.__RomanNumbers()
    str_13 = module_0.snake_case_to_camel(str_12, bool_0)
    str_14 = "Bh(@hQv)n"
    str_15 = module_0.compress(str_14)
