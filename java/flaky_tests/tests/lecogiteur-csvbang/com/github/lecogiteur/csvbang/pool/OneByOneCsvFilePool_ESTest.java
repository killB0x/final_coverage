/*
 * This file was automatically generated by EvoSuite
 * Sat Oct 29 07:38:24 GMT 2022
 */

package com.github.lecogiteur.csvbang.pool;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.github.lecogiteur.csvbang.configuration.CsvBangConfiguration;
import com.github.lecogiteur.csvbang.file.CsvFileContext;
import com.github.lecogiteur.csvbang.file.FileName;
import com.github.lecogiteur.csvbang.pool.OneByOneCsvFilePool;
import com.github.lecogiteur.csvbang.pool.WrapperCsvFileContext;
import java.util.Collection;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class OneByOneCsvFilePool_ESTest extends OneByOneCsvFilePool_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, (FileName) null, csvBangConfiguration0, csvBangConfiguration0);
      csvBangConfiguration0.maxRecordByFile = 47L;
      boolean boolean0 = oneByOneCsvFilePool0.isAllowedToModification(47L, (-1));
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      Object object0 = new Object();
      csvBangConfiguration0.maxRecordByFile = 0L;
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, (FileName) null, object0, object0);
      boolean boolean0 = oneByOneCsvFilePool0.isAllowedToModification(48L, 1191L);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      WrapperCsvFileContext wrapperCsvFileContext0 = new WrapperCsvFileContext();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, (Object) null, wrapperCsvFileContext0);
      boolean boolean0 = oneByOneCsvFilePool0.isAllowedToModification(3258L, (-1L));
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      Object object0 = new Object();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, (FileName) null, object0, object0);
      csvBangConfiguration0.maxFileSize = (long) '0';
      boolean boolean0 = oneByOneCsvFilePool0.isAllowedToModification(48L, 1191L);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool((CsvBangConfiguration) null, (FileName) null, csvBangConfiguration0, csvBangConfiguration0);
      // Undeclared exception!
      try { 
        oneByOneCsvFilePool0.isAllowedToModification((-1L), (-1L));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.github.lecogiteur.csvbang.pool.OneByOneCsvFilePool", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, csvBangConfiguration0, csvBangConfiguration0);
      csvBangConfiguration0.maxFileSize = 0L;
      // Undeclared exception!
      try { 
        oneByOneCsvFilePool0.getFile((-1), (-1));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.github.lecogiteur.csvbang.pool.OneByOneCsvFilePool", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, csvBangConfiguration0, csvBangConfiguration0);
      csvBangConfiguration0.maxFileSize = 0L;
      try { 
        oneByOneCsvFilePool0.getFile('\\', '\\');
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // No file available in pool for update. The maximum number files [-1] has been already created and are full.
         //
         verifyException("com.github.lecogiteur.csvbang.pool.OneByOneCsvFilePool", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      csvBangConfiguration0.init();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, csvBangConfiguration0, csvBangConfiguration0);
      CsvFileContext csvFileContext0 = oneByOneCsvFilePool0.getFile('#', '#');
      assertNotNull(csvFileContext0);
      
      csvBangConfiguration0.maxRecordByFile = 14L;
      CsvFileContext csvFileContext1 = oneByOneCsvFilePool0.getFile((-1), (-2146777702));
      assertNotSame(csvFileContext1, csvFileContext0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      csvBangConfiguration0.init();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, csvBangConfiguration0, csvBangConfiguration0);
      CsvFileContext csvFileContext0 = oneByOneCsvFilePool0.getFile('#', '#');
      CsvFileContext csvFileContext1 = oneByOneCsvFilePool0.getFile((-1), (-1));
      assertSame(csvFileContext1, csvFileContext0);
      assertNotNull(csvFileContext1);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      Object object0 = new Object();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, (FileName) null, object0, object0);
      Collection<CsvFileContext> collection0 = oneByOneCsvFilePool0.getAllFiles();
      assertNotNull(collection0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, csvBangConfiguration0.fileName, csvBangConfiguration0, csvBangConfiguration0);
      Object object0 = new Object();
      oneByOneCsvFilePool0.setCustomFooter(object0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CsvBangConfiguration csvBangConfiguration0 = new CsvBangConfiguration();
      OneByOneCsvFilePool oneByOneCsvFilePool0 = new OneByOneCsvFilePool(csvBangConfiguration0, (FileName) null, csvBangConfiguration0, csvBangConfiguration0);
      oneByOneCsvFilePool0.setCustomHeader((Object) null);
  }
}
