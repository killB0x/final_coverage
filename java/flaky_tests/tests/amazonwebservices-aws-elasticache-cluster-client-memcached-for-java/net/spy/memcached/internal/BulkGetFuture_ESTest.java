/*
 * This file was automatically generated by EvoSuite
 * Tue Nov 15 13:11:24 GMT 2022
 */

package net.spy.memcached.internal;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.net.InetSocketAddress;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Delayed;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;
import net.spy.memcached.BinaryConnectionFactory;
import net.spy.memcached.BroadcastOpFactory;
import net.spy.memcached.DefaultHashAlgorithm;
import net.spy.memcached.MemcachedConnection;
import net.spy.memcached.config.ClusterConfiguration;
import net.spy.memcached.config.NodeEndPoint;
import net.spy.memcached.internal.BasicThreadFactory;
import net.spy.memcached.internal.BulkGetCompletionListener;
import net.spy.memcached.internal.BulkGetFuture;
import net.spy.memcached.ops.GetlOperation;
import net.spy.memcached.ops.Operation;
import net.spy.memcached.ops.OperationStatus;
import net.spy.memcached.ops.StatsOperation;
import net.spy.memcached.protocol.binary.GetlOperationImpl;
import net.spy.memcached.protocol.binary.ReplicaGetOperationImpl;
import net.spy.memcached.protocol.binary.StatsOperationImpl;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class BulkGetFuture_ESTest extends BulkGetFuture_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      StatsOperation.Callback statsOperation_Callback0 = mock(StatsOperation.Callback.class, new ViolatedAssumptionAnswer());
      StatsOperationImpl statsOperationImpl0 = new StatsOperationImpl("`8(", statsOperation_Callback0);
      linkedHashSet0.add(statsOperationImpl0);
      GetlOperation.Callback getlOperation_Callback0 = mock(GetlOperation.Callback.class, new ViolatedAssumptionAnswer());
      GetlOperationImpl getlOperationImpl0 = new GetlOperationImpl("`8(", 0, getlOperation_Callback0);
      linkedHashSet0.add(getlOperationImpl0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      assertFalse(bulkGetFuture0.isCancelled());
      
      boolean boolean0 = bulkGetFuture0.cancel(true);
      assertTrue(bulkGetFuture0.isCancelled());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      GetlOperation.Callback getlOperation_Callback0 = mock(GetlOperation.Callback.class, new ViolatedAssumptionAnswer());
      GetlOperationImpl getlOperationImpl0 = new GetlOperationImpl("`8(", 0, getlOperation_Callback0);
      linkedHashSet0.add(getlOperationImpl0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      bulkGetFuture0.cancel(false);
      assertTrue(bulkGetFuture0.isCancelled());
      
      HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>> hashMap1 = new HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>>();
      BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>> bulkGetFuture1 = new BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>>(hashMap1, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      bulkGetFuture1.getStatus();
      assertFalse(bulkGetFuture1.isCancelled());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      assertFalse(bulkGetFuture0.isCancelled());
      
      bulkGetFuture0.cancel(false);
      boolean boolean0 = bulkGetFuture0.isCancelled();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>> hashMap0 = new HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>>();
      BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>> bulkGetFuture0 = new BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      bulkGetFuture0.getStatus();
      assertFalse(bulkGetFuture0.isCancelled());
      assertFalse(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      PriorityBlockingQueue<ReplicaGetOperationImpl> priorityBlockingQueue0 = new PriorityBlockingQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(priorityBlockingQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<CompletableFuture<Object>>> hashMap0 = new HashMap<String, Future<CompletableFuture<Object>>>();
      BulkGetFuture<CompletableFuture<Object>> bulkGetFuture0 = new BulkGetFuture<CompletableFuture<Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      Supplier<CompletableFuture<Object>> supplier0 = (Supplier<CompletableFuture<Object>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      CompletableFuture<CompletableFuture<Object>> completableFuture0 = CompletableFuture.supplyAsync(supplier0);
      hashMap0.put("Interrupted", completableFuture0);
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      bulkGetFuture0.getSome(3988L, timeUnit0);
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      ThreadPoolExecutor.AbortPolicy threadPoolExecutor_AbortPolicy0 = new ThreadPoolExecutor.AbortPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0, threadPoolExecutor_AbortPolicy0);
      BulkGetFuture<CompletionStage<ReplicaGetOperationImpl>> bulkGetFuture0 = new BulkGetFuture<CompletionStage<ReplicaGetOperationImpl>>((Map<String, Future<CompletionStage<ReplicaGetOperationImpl>>>) null, linkedHashSet0, countDownLatch0, scheduledThreadPoolExecutor0);
      BulkGetCompletionListener bulkGetCompletionListener0 = mock(BulkGetCompletionListener.class, new ViolatedAssumptionAnswer());
      bulkGetFuture0.addListener(bulkGetCompletionListener0);
      assertFalse(bulkGetFuture0.isCancelled());
      assertFalse(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>();
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, (CountDownLatch) null, (ExecutorService) null);
      // Undeclared exception!
      try { 
        bulkGetFuture0.isDone();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.spy.memcached.internal.BulkGetFuture", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      BulkGetFuture<CompletableFuture<Object>> bulkGetFuture0 = new BulkGetFuture<CompletableFuture<Object>>((Map<String, Future<CompletableFuture<Object>>>) null, linkedHashSet0, (CountDownLatch) null, (ExecutorService) null);
      TimeUnit timeUnit0 = TimeUnit.DAYS;
      // Undeclared exception!
      try { 
        bulkGetFuture0.getSome(0, timeUnit0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.spy.memcached.internal.BulkGetFuture", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      GetlOperationImpl getlOperationImpl0 = new GetlOperationImpl("/L", 0, (GetlOperation.Callback) null);
      linkedHashSet0.add(getlOperationImpl0);
      CountDownLatch countDownLatch0 = new CountDownLatch(2144091098);
      ForkJoinPool forkJoinPool0 = ForkJoinPool.commonPool();
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, forkJoinPool0);
      // Undeclared exception!
      try { 
        bulkGetFuture0.cancel(true);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.spy.memcached.protocol.BaseOperationImpl", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      boolean boolean0 = bulkGetFuture0.isDone();
      assertTrue(boolean0);
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<NodeEndPoint>> hashMap0 = new HashMap<String, Future<NodeEndPoint>>();
      BulkGetFuture<NodeEndPoint> bulkGetFuture0 = new BulkGetFuture<NodeEndPoint>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      bulkGetFuture0.get();
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(7);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      boolean boolean0 = bulkGetFuture0.isDone();
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(boolean0);
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      LinkedBlockingQueue<ReplicaGetOperationImpl> linkedBlockingQueue0 = new LinkedBlockingQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(linkedBlockingQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>> hashMap0 = new HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>>();
      BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>> bulkGetFuture0 = new BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      assertFalse(bulkGetFuture0.isCancelled());
      
      bulkGetFuture0.cancel(false);
      bulkGetFuture0.getStatus();
      assertTrue(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>> hashMap0 = new HashMap<String, Future<HashMap<ReplicaGetOperationImpl, Object>>>();
      hashMap0.put("{xH", (Future<HashMap<ReplicaGetOperationImpl, Object>>) null);
      BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>> bulkGetFuture0 = new BulkGetFuture<HashMap<ReplicaGetOperationImpl, Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      // Undeclared exception!
      try { 
        bulkGetFuture0.getStatus();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.spy.memcached.internal.BulkGetFuture", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<CompletableFuture<Object>>> hashMap0 = new HashMap<String, Future<CompletableFuture<Object>>>();
      BulkGetFuture<CompletableFuture<Object>> bulkGetFuture0 = new BulkGetFuture<CompletableFuture<Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      TimeUnit timeUnit0 = TimeUnit.HOURS;
      bulkGetFuture0.get(60000L, timeUnit0);
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      GetlOperationImpl getlOperationImpl0 = new GetlOperationImpl("Operation timed out: ", (-135), (GetlOperation.Callback) null);
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>();
      linkedHashSet0.add(getlOperationImpl0);
      CountDownLatch countDownLatch0 = new CountDownLatch(2145348972);
      HashMap<String, Future<CompletableFuture<Object>>> hashMap0 = new HashMap<String, Future<CompletableFuture<Object>>>();
      BulkGetFuture<CompletableFuture<Object>> bulkGetFuture0 = new BulkGetFuture<CompletableFuture<Object>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      assertFalse(bulkGetFuture0.isTimeout());
      
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      bulkGetFuture0.getSome((-532L), timeUnit0);
      assertTrue(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      assertFalse(bulkGetFuture0.isCancelled());
      
      CompletableFuture<Delayed> completableFuture0 = new CompletableFuture<Delayed>();
      hashMap0.put("", completableFuture0);
      boolean boolean0 = bulkGetFuture0.cancel(true);
      assertTrue(bulkGetFuture0.isCancelled());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      GetlOperation.Callback getlOperation_Callback0 = mock(GetlOperation.Callback.class, new ViolatedAssumptionAnswer());
      GetlOperationImpl getlOperationImpl0 = new GetlOperationImpl("", 1, getlOperation_Callback0);
      linkedHashSet0.add(getlOperationImpl0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      ForkJoinPool forkJoinPool0 = ForkJoinPool.commonPool();
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, forkJoinPool0);
      bulkGetFuture0.cancel(true);
      BulkGetFuture<ReplicaGetOperationImpl> bulkGetFuture1 = new BulkGetFuture<ReplicaGetOperationImpl>((Map<String, Future<ReplicaGetOperationImpl>>) null, linkedHashSet0, countDownLatch0, forkJoinPool0);
      TimeUnit timeUnit0 = TimeUnit.DAYS;
      try { 
        bulkGetFuture1.getSome(7L, timeUnit0);
        fail("Expecting exception: ExecutionException");
      
      } catch(ExecutionException e) {
         //
         // java.util.concurrent.CancellationException: Cancelled
         //
         verifyException("net.spy.memcached.internal.BulkGetFuture", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      ForkJoinPool forkJoinPool0 = ForkJoinPool.commonPool();
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, forkJoinPool0);
      boolean boolean0 = bulkGetFuture0.isTimeout();
      assertFalse(boolean0);
      assertFalse(bulkGetFuture0.isCancelled());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      boolean boolean0 = bulkGetFuture0.isCancelled();
      assertFalse(boolean0);
      assertFalse(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      HashMap<String, Future<CompletableFuture<ReplicaGetOperationImpl>>> hashMap0 = new HashMap<String, Future<CompletableFuture<ReplicaGetOperationImpl>>>();
      BulkGetFuture<CompletableFuture<ReplicaGetOperationImpl>> bulkGetFuture0 = new BulkGetFuture<CompletableFuture<ReplicaGetOperationImpl>>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      OperationStatus operationStatus0 = new OperationStatus(false, "5");
      bulkGetFuture0.setStatus(operationStatus0);
      assertFalse(bulkGetFuture0.isCancelled());
      assertFalse(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      DefaultHashAlgorithm defaultHashAlgorithm0 = DefaultHashAlgorithm.FNV1_32_HASH;
      BinaryConnectionFactory binaryConnectionFactory0 = new BinaryConnectionFactory((-3258), 2080374784, defaultHashAlgorithm0);
      LinkedList<NodeEndPoint> linkedList0 = new LinkedList<NodeEndPoint>();
      ClusterConfiguration clusterConfiguration0 = new ClusterConfiguration(1493L, linkedList0);
      List<InetSocketAddress> list0 = clusterConfiguration0.getInetSocketAddresses();
      MemcachedConnection memcachedConnection0 = binaryConnectionFactory0.createConnection(list0);
      BroadcastOpFactory broadcastOpFactory0 = mock(BroadcastOpFactory.class, new ViolatedAssumptionAnswer());
      CountDownLatch countDownLatch0 = memcachedConnection0.broadcastOperation(broadcastOpFactory0);
      BasicThreadFactory basicThreadFactory0 = new BasicThreadFactory("Completed read op: %s and giving the next %d bytes", true);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(16384, basicThreadFactory0);
      BulkGetFuture<Locale.Category> bulkGetFuture0 = new BulkGetFuture<Locale.Category>((Map<String, Future<Locale.Category>>) null, (Collection<Operation>) null, countDownLatch0, scheduledThreadPoolExecutor0);
      BulkGetCompletionListener bulkGetCompletionListener0 = mock(BulkGetCompletionListener.class, new ViolatedAssumptionAnswer());
      bulkGetFuture0.removeListener(bulkGetCompletionListener0);
      assertFalse(bulkGetFuture0.isCancelled());
      assertFalse(bulkGetFuture0.isTimeout());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<ReplicaGetOperationImpl> bulkGetFuture0 = new BulkGetFuture<ReplicaGetOperationImpl>((Map<String, Future<ReplicaGetOperationImpl>>) null, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      BulkGetCompletionListener bulkGetCompletionListener0 = mock(BulkGetCompletionListener.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        bulkGetFuture0.addListener(bulkGetCompletionListener0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.spy.memcached.internal.AbstractListenableFuture", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      HashMap<String, Future<Delayed>> hashMap0 = new HashMap<String, Future<Delayed>>();
      SynchronousQueue<ReplicaGetOperationImpl> synchronousQueue0 = new SynchronousQueue<ReplicaGetOperationImpl>();
      LinkedHashSet<Operation> linkedHashSet0 = new LinkedHashSet<Operation>(synchronousQueue0);
      CountDownLatch countDownLatch0 = new CountDownLatch(0);
      BulkGetFuture<Delayed> bulkGetFuture0 = new BulkGetFuture<Delayed>(hashMap0, linkedHashSet0, countDownLatch0, (ExecutorService) null);
      bulkGetFuture0.signalComplete();
      assertFalse(bulkGetFuture0.isTimeout());
      assertFalse(bulkGetFuture0.isCancelled());
  }
}
