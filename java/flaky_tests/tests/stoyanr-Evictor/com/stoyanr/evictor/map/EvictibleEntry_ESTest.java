/*
 * This file was automatically generated by EvoSuite
 * Sun Oct 23 11:24:35 GMT 2022
 */

package com.stoyanr.evictor.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator;
import com.stoyanr.evictor.map.EvictibleEntry;
import com.stoyanr.evictor.queue.NavigableMapEvictionQueue;
import com.stoyanr.evictor.queue.PriorityEvictionQueue;
import com.stoyanr.evictor.scheduler.DelayedTaskEvictionScheduler;
import com.stoyanr.evictor.scheduler.ExecutorServiceEvictionScheduler;
import com.stoyanr.evictor.scheduler.RegularTaskEvictionScheduler;
import com.stoyanr.evictor.scheduler.SingleThreadEvictionScheduler;
import java.util.LinkedList;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.Delayed;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class EvictibleEntry_ESTest extends EvictibleEntry_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      TimeUnit timeUnit0 = TimeUnit.MILLISECONDS;
      RegularTaskEvictionScheduler<Integer, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, Integer>(2448L, timeUnit0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap0, regularTaskEvictionScheduler0);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (Integer) 1, (Integer) regularTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 2448L);
      evictibleEntry0.evict(false);
      assertEquals(1392411729320000L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Callable<Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Callable<Integer>>>();
      LinkedList<EvictibleEntry<Integer, Callable<Integer>>> linkedList0 = new LinkedList<EvictibleEntry<Integer, Callable<Integer>>>();
      PriorityEvictionQueue<Integer, Callable<Integer>> priorityEvictionQueue0 = new PriorityEvictionQueue<Integer, Callable<Integer>>(linkedList0);
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ThreadPoolExecutor.CallerRunsPolicy threadPoolExecutor_CallerRunsPolicy0 = new ThreadPoolExecutor.CallerRunsPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0, threadFactory0, threadPoolExecutor_CallerRunsPolicy0);
      DelayedTaskEvictionScheduler<Integer, Callable<Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, Callable<Integer>>(priorityEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Callable<Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Callable<Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      Callable<Integer> callable0 = (Callable<Integer>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(callable0).toString();
      EvictibleEntry<Integer, Callable<Integer>> evictibleEntry0 = new EvictibleEntry<Integer, Callable<Integer>>(concurrentMapWithTimedEvictionDecorator0, (Integer) 1, callable0, 0);
      Callable<Integer> callable1 = (Callable<Integer>) mock(Callable.class, new ViolatedAssumptionAnswer());
      Callable<Integer> callable2 = evictibleEntry0.setValue(callable1);
      assertSame(callable2, callable0);
      assertEquals(0L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      RegularTaskEvictionScheduler<Integer, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap0, regularTaskEvictionScheduler0);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (Integer) 1, (Integer) regularTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 1L);
      boolean boolean0 = evictibleEntry0.isEvictible();
      assertEquals(1392409282320000L, evictibleEntry0.getEvictionTime());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Integer integer0 = new Integer((-188));
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 0L);
      boolean boolean0 = evictibleEntry0.isEvictible();
      assertEquals(0L, evictibleEntry0.getEvictionTime());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ConcurrentHashMap<Object, EvictibleEntry<Object, Object>> concurrentHashMap0 = new ConcurrentHashMap<Object, EvictibleEntry<Object, Object>>();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Object, Object> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Object, Object>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Object, Object> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Object, Object>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      EvictibleEntry<Object, Object> evictibleEntry0 = new EvictibleEntry<Object, Object>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, scheduledThreadPoolExecutor0, 1);
      evictibleEntry0.getValue();
      assertEquals(1392409282320000L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      ExecutorServiceEvictionScheduler<Delayed, Integer> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap0, executorServiceEvictionScheduler0);
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      doReturn((Thread) null).when(threadFactory0).newThread(any(java.lang.Runnable.class));
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1, threadFactory0);
      Callable<Delayed> callable0 = (Callable<Delayed>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(callable0).toString();
      TimeUnit timeUnit0 = TimeUnit.HOURS;
      ScheduledFuture<Delayed> scheduledFuture0 = scheduledThreadPoolExecutor0.schedule(callable0, (long) 1, timeUnit0);
      EvictibleEntry<Delayed, Integer> evictibleEntry0 = new EvictibleEntry<Delayed, Integer>(concurrentMapWithTimedEvictionDecorator0, scheduledFuture0, (Integer) 1, 1L);
      evictibleEntry0.getKey();
      assertEquals(1392409282320000L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Integer integer0 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 0L);
      long long0 = evictibleEntry0.getEvictionTime();
      assertEquals(0L, long0);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      ThreadPoolExecutor.CallerRunsPolicy threadPoolExecutor_CallerRunsPolicy0 = new ThreadPoolExecutor.CallerRunsPolicy();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1, threadFactory0, threadPoolExecutor_CallerRunsPolicy0);
      ConcurrentSkipListMap<Callable<Delayed>, EvictibleEntry<Callable<Delayed>, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Callable<Delayed>, EvictibleEntry<Callable<Delayed>, Integer>>();
      ConcurrentSkipListMap<Long, EvictibleEntry<Callable<Delayed>, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Callable<Delayed>, Integer>>();
      NavigableMapEvictionQueue<Callable<Delayed>, Integer> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Callable<Delayed>, Integer>(concurrentSkipListMap1);
      DelayedTaskEvictionScheduler<Callable<Delayed>, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Callable<Delayed>, Integer>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Callable<Delayed>, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Callable<Delayed>, Integer>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      Callable<Delayed> callable0 = (Callable<Delayed>) mock(Callable.class, new ViolatedAssumptionAnswer());
      EvictibleEntry<Callable<Delayed>, Integer> evictibleEntry0 = new EvictibleEntry<Callable<Delayed>, Integer>(concurrentMapWithTimedEvictionDecorator0, callable0, (Integer) delayedTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 2);
      long long0 = evictibleEntry0.getEvictionTime();
      assertEquals(1392409283320000L, long0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Integer integer0 = new Integer((-188));
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 0L);
      Object object0 = new Object();
      evictibleEntry0.setData(object0);
      evictibleEntry0.getData();
      assertEquals(0L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Integer integer0 = new Integer(2147044848);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 1876L);
      String string0 = evictibleEntry0.toString();
      assertEquals(1392411157320000L, evictibleEntry0.getEvictionTime());
      assertEquals("[2147044848, 2147044848, 1876]", string0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Integer>>();
      NavigableMapEvictionQueue<Delayed, Integer> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Delayed, Integer>(concurrentSkipListMap0);
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>(navigableMapEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      EvictibleEntry<Delayed, Integer> evictibleEntry0 = new EvictibleEntry<Delayed, Integer>(concurrentMapWithTimedEvictionDecorator0, (Delayed) null, (Integer) delayedTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 1);
      String string0 = evictibleEntry0.toString();
      assertEquals(1392409282320000L, evictibleEntry0.getEvictionTime());
      assertEquals("[null, 1, 1]", string0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Integer>>();
      NavigableMapEvictionQueue<Delayed, Integer> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Delayed, Integer>(concurrentSkipListMap0);
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>(navigableMapEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      EvictibleEntry<Delayed, Integer> evictibleEntry0 = new EvictibleEntry<Delayed, Integer>(concurrentMapWithTimedEvictionDecorator0, (Delayed) null, (Integer) delayedTaskEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 3539108316320000L);
      boolean boolean0 = evictibleEntry0.shouldEvict();
      assertEquals((-9221979627573455809L), evictibleEntry0.getEvictionTime());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Integer integer0 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 1000000L);
      boolean boolean0 = evictibleEntry0.shouldEvict();
      assertEquals(1393409281320000L, evictibleEntry0.getEvictionTime());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Integer integer0 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 0L);
      boolean boolean0 = evictibleEntry0.shouldEvict();
      assertFalse(boolean0);
      assertEquals(0L, evictibleEntry0.getEvictionTime());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Integer integer0 = new Integer((-188));
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, integer0, integer0, 0L);
      // Undeclared exception!
      try { 
        evictibleEntry0.setValue((Integer) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // value cannot be null
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Long long0 = new Long((-2766L));
      EvictibleEntry<Callable<Long>, Long> evictibleEntry0 = null;
      try {
        evictibleEntry0 = new EvictibleEntry<Callable<Long>, Long>((ConcurrentMapWithTimedEvictionDecorator<Callable<Long>, Long>) null, (Callable<Long>) null, long0, (-2766L));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Eviction time cannot be less than zero
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Delayed, Delayed>>();
      NavigableMapEvictionQueue<Delayed, Delayed> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Delayed, Delayed>(concurrentSkipListMap1);
      RegularTaskEvictionScheduler<Delayed, Delayed> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Delayed>(navigableMapEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, regularTaskEvictionScheduler0);
      EvictibleEntry<Delayed, Delayed> evictibleEntry0 = null;
      try {
        evictibleEntry0 = new EvictibleEntry<Delayed, Delayed>(concurrentMapWithTimedEvictionDecorator0, (Delayed) null, (Delayed) null, 595L);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Value cannot be null
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Integer integer0 = new Integer(1);
      EvictibleEntry<Delayed, Integer> evictibleEntry0 = new EvictibleEntry<Delayed, Integer>((ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>) null, (Delayed) null, integer0, 0L);
      // Undeclared exception!
      try { 
        evictibleEntry0.evict(false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ExecutorServiceEvictionScheduler<Delayed, Integer> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Delayed, Integer>();
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      SingleThreadEvictionScheduler<Integer, Integer> singleThreadEvictionScheduler0 = new SingleThreadEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap0, singleThreadEvictionScheduler0);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (Integer) executorServiceEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, (Integer) executorServiceEvictionScheduler0.DEFAULT_THREAD_POOL_SIZE, 1L);
      evictibleEntry0.getData();
      assertEquals(1392409282320000L, evictibleEntry0.getEvictionTime());
  }
}
