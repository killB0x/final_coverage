/*
 * This file was automatically generated by EvoSuite
 * Sun Oct 23 11:19:22 GMT 2022
 */

package com.stoyanr.evictor.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.stoyanr.evictor.EvictionScheduler;
import com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator;
import com.stoyanr.evictor.map.EvictibleEntry;
import com.stoyanr.evictor.queue.NavigableMapEvictionQueue;
import com.stoyanr.evictor.queue.PriorityEvictionQueue;
import com.stoyanr.evictor.scheduler.DelayedTaskEvictionScheduler;
import com.stoyanr.evictor.scheduler.ExecutorServiceEvictionScheduler;
import com.stoyanr.evictor.scheduler.RegularTaskEvictionScheduler;
import com.stoyanr.evictor.scheduler.SingleThreadEvictionScheduler;
import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Function;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ConcurrentMapWithTimedEvictionDecorator_ESTest extends ConcurrentMapWithTimedEvictionDecorator_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ArrayDeque<EvictibleEntry<Delayed, Delayed>> arrayDeque0 = new ArrayDeque<EvictibleEntry<Delayed, Delayed>>();
      PriorityEvictionQueue<Delayed, Delayed> priorityEvictionQueue0 = new PriorityEvictionQueue<Delayed, Delayed>(arrayDeque0);
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap1, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(0);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator1, (Integer) 1, integer0, 0);
      Callable<EvictibleEntry<Integer, Integer>> callable0 = (Callable<EvictibleEntry<Integer, Integer>>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn(evictibleEntry0).when(callable0).call();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      ScheduledFuture<EvictibleEntry<Integer, Integer>> scheduledFuture0 = scheduledThreadPoolExecutor0.schedule(callable0, (long) 1, timeUnit0);
      concurrentMapWithTimedEvictionDecorator0.replace((Delayed) scheduledFuture0, (Delayed) scheduledFuture0, (Delayed) scheduledFuture0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap2, regularTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator2.size();
      Integer integer1 = new Integer(1);
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator0.remove((Object) null, (Object) integer1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.ConcurrentSkipListMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      Integer integer0 = new Integer(1);
      ConcurrentHashMap<Map.Entry<Integer, Integer>, EvictibleEntry<Map.Entry<Integer, Integer>, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Map.Entry<Integer, Integer>, EvictibleEntry<Map.Entry<Integer, Integer>, Integer>>();
      PriorityBlockingQueue<EvictibleEntry<Map.Entry<Integer, Integer>, Integer>> priorityBlockingQueue0 = new PriorityBlockingQueue<EvictibleEntry<Map.Entry<Integer, Integer>, Integer>>();
      PriorityEvictionQueue<Map.Entry<Integer, Integer>, Integer> priorityEvictionQueue0 = new PriorityEvictionQueue<Map.Entry<Integer, Integer>, Integer>(priorityBlockingQueue0);
      DelayedTaskEvictionScheduler<Map.Entry<Integer, Integer>, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Map.Entry<Integer, Integer>, Integer>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Integer>, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Integer>, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler1);
      ConcurrentSkipListMap<Integer, Integer> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, Integer>();
      concurrentSkipListMap0.pollLastEntry();
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator0.putIfAbsent((Map.Entry<Integer, Integer>) null, (Integer) 1, 1L);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.ConcurrentHashMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(1);
      Integer integer1 = new Integer(0);
      Integer integer2 = new Integer(0);
      Integer integer3 = new Integer(280);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer4 = new Integer(0);
      Integer integer5 = new Integer(0);
      Integer integer6 = new Integer(0);
      concurrentMapWithTimedEvictionDecorator2.replace(integer6, (Integer) 1, 2622L);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator3 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap2, regularTaskEvictionScheduler0);
      Integer integer7 = new Integer(2);
      concurrentMapWithTimedEvictionDecorator3.containsValue(integer4);
      ConcurrentSkipListMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>> concurrentSkipListMap3 = new ConcurrentSkipListMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>>();
      PriorityQueue<EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>> priorityQueue0 = new PriorityQueue<EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>>(1);
      PriorityEvictionQueue<Map.Entry<Integer, Delayed>, Delayed> priorityEvictionQueue0 = new PriorityEvictionQueue<Map.Entry<Integer, Delayed>, Delayed>(priorityQueue0);
      RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Delayed> regularTaskEvictionScheduler1 = new RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Delayed>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Delayed> concurrentMapWithTimedEvictionDecorator4 = new ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Delayed>(concurrentSkipListMap3, regularTaskEvictionScheduler1);
      TreeMap<Integer, Delayed> treeMap0 = new TreeMap<Integer, Delayed>();
      Integer integer8 = new Integer(2);
      treeMap0.floorEntry(integer8);
      DelayQueue<Delayed> delayQueue0 = new DelayQueue<Delayed>();
      delayQueue0.poll((-175L), regularTaskEvictionScheduler1.DEFAULT_TIME_UNIT);
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator4.putIfAbsent((Map.Entry<Integer, Delayed>) null, (Delayed) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Value cannot be null
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      Integer integer0 = new Integer(0);
      Integer integer1 = new Integer(0);
      Integer integer2 = new Integer(280);
      Integer integer3 = new Integer(0);
      Integer integer4 = new Integer(0);
      Integer integer5 = new Integer(0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap2, regularTaskEvictionScheduler0);
      Integer integer6 = new Integer(2);
      concurrentMapWithTimedEvictionDecorator0.containsValue(integer3);
      ConcurrentSkipListMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>> concurrentSkipListMap3 = new ConcurrentSkipListMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>>();
      PriorityQueue<EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>> priorityQueue0 = new PriorityQueue<EvictibleEntry<Map.Entry<Integer, Delayed>, Delayed>>(1);
      PriorityEvictionQueue<Map.Entry<Integer, Delayed>, Delayed> priorityEvictionQueue0 = new PriorityEvictionQueue<Map.Entry<Integer, Delayed>, Delayed>(priorityQueue0);
      RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Delayed> regularTaskEvictionScheduler1 = new RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Delayed>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Delayed> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Delayed>(concurrentSkipListMap3, regularTaskEvictionScheduler1);
      TreeMap<Integer, Delayed> treeMap0 = new TreeMap<Integer, Delayed>();
      Integer integer7 = new Integer(2);
      treeMap0.floorEntry(integer7);
      DelayQueue<Delayed> delayQueue0 = new DelayQueue<Delayed>();
      delayQueue0.poll((-175L), regularTaskEvictionScheduler1.DEFAULT_TIME_UNIT);
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator1.putIfAbsent((Map.Entry<Integer, Delayed>) null, (Delayed) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Value cannot be null
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap1);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      SingleThreadEvictionScheduler<Integer, Integer> singleThreadEvictionScheduler0 = new SingleThreadEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap2, singleThreadEvictionScheduler0);
      Integer integer0 = new Integer(1);
      Integer integer1 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (Integer) 1, integer0, 1);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>();
      delayedTaskEvictionScheduler1.cancelEviction(evictibleEntry0);
      Integer integer2 = new Integer(0);
      Integer integer3 = new Integer((-816));
      Integer integer4 = new Integer(0);
      Integer integer5 = new Integer(0);
      concurrentMapWithTimedEvictionDecorator0.replace(integer4, integer5, (long) 0);
      Integer integer6 = new Integer(0);
      Integer integer7 = new Integer((-816));
      Integer integer8 = new Integer((-816));
      concurrentMapWithTimedEvictionDecorator0.replace(integer6, integer7, integer8, (long) 0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      int int0 = 4464;
      MockThread mockThread0 = new MockThread();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      doReturn(mockThread0).when(threadFactory0).newThread(any(java.lang.Runnable.class));
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(4464, threadFactory0);
      ExecutorServiceEvictionScheduler<Delayed, Delayed> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Delayed, Delayed>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentHashMap0, executorServiceEvictionScheduler0);
      MockThread mockThread1 = new MockThread();
      TimeUnit timeUnit0 = TimeUnit.DAYS;
      ScheduledFuture<?> scheduledFuture0 = scheduledThreadPoolExecutor0.scheduleWithFixedDelay(mockThread1, 1, 1, timeUnit0);
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap1 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap1, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator1.remove((Object) scheduledFuture0);
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>> concurrentHashMap2 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>>();
      RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>> regularTaskEvictionScheduler0 = null;
      try {
        regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>(0L, timeUnit0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Delay cannot be less than or equal to zero
         //
         verifyException("com.stoyanr.evictor.scheduler.RegularTaskEvictionScheduler", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      MockThread mockThread0 = new MockThread();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      doReturn(mockThread0).when(threadFactory0).newThread(any(java.lang.Runnable.class));
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(4464, threadFactory0);
      ExecutorServiceEvictionScheduler<Delayed, Delayed> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Delayed, Delayed>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentHashMap0, executorServiceEvictionScheduler0);
      MockThread mockThread1 = new MockThread();
      TimeUnit timeUnit0 = TimeUnit.DAYS;
      ScheduledFuture<?> scheduledFuture0 = scheduledThreadPoolExecutor0.scheduleWithFixedDelay(mockThread1, 1, 1, timeUnit0);
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap1 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap1, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator1.remove((Object) scheduledFuture0);
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>> concurrentHashMap2 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>>();
      RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>> regularTaskEvictionScheduler0 = null;
      try {
        regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>(0L, timeUnit0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Delay cannot be less than or equal to zero
         //
         verifyException("com.stoyanr.evictor.scheduler.RegularTaskEvictionScheduler", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap1);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      SingleThreadEvictionScheduler<Integer, Integer> singleThreadEvictionScheduler0 = new SingleThreadEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap2, singleThreadEvictionScheduler0);
      singleThreadEvictionScheduler0.shutdown();
      Integer integer0 = new Integer(1);
      Integer integer1 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (Integer) 1, integer0, 1);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>();
      delayedTaskEvictionScheduler1.cancelEviction(evictibleEntry0);
      Integer integer2 = new Integer(0);
      Integer integer3 = new Integer(1);
      Integer integer4 = new Integer(1);
      Integer integer5 = new Integer((-816));
      Integer integer6 = new Integer(0);
      concurrentMapWithTimedEvictionDecorator0.replace(integer5, integer6, (long) 1);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap3 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap3, regularTaskEvictionScheduler0);
      Integer integer7 = new Integer(1);
      concurrentMapWithTimedEvictionDecorator1.keySet();
      Integer integer8 = new Integer(0);
      concurrentMapWithTimedEvictionDecorator1.containsValue(integer8);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.keySet();
      Integer integer0 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, (Integer) 1, integer0, 1);
      Integer integer1 = new Integer(1);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1, threadFactory0, threadPoolExecutor_DiscardOldestPolicy0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(scheduledThreadPoolExecutor0);
      delayedTaskEvictionScheduler1.shutdown();
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler1);
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, Delayed>> concurrentHashMap1 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, Delayed>>(0, 1, 1);
      LinkedBlockingDeque<EvictibleEntry<Integer, Delayed>> linkedBlockingDeque0 = null;
      try {
        linkedBlockingDeque0 = new LinkedBlockingDeque<EvictibleEntry<Integer, Delayed>>(0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.LinkedBlockingDeque", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ArrayDeque<EvictibleEntry<Delayed, Delayed>> arrayDeque0 = new ArrayDeque<EvictibleEntry<Delayed, Delayed>>();
      PriorityEvictionQueue<Delayed, Delayed> priorityEvictionQueue0 = new PriorityEvictionQueue<Delayed, Delayed>(arrayDeque0);
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1, threadPoolExecutor_DiscardOldestPolicy0);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap1, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(0);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>(concurrentMapWithTimedEvictionDecorator1, (Integer) 1, integer0, 0);
      Callable<EvictibleEntry<Integer, Integer>> callable0 = (Callable<EvictibleEntry<Integer, Integer>>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn(evictibleEntry0).when(callable0).call();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      ScheduledFuture<EvictibleEntry<Integer, Integer>> scheduledFuture0 = scheduledThreadPoolExecutor0.schedule(callable0, (long) 1, timeUnit0);
      concurrentMapWithTimedEvictionDecorator0.replace((Delayed) scheduledFuture0, (Delayed) scheduledFuture0, (Delayed) scheduledFuture0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap2, regularTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator2.size();
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ArrayDeque<EvictibleEntry<Delayed, Delayed>> arrayDeque0 = new ArrayDeque<EvictibleEntry<Delayed, Delayed>>();
      PriorityEvictionQueue<Delayed, Delayed> priorityEvictionQueue0 = new PriorityEvictionQueue<Delayed, Delayed>(arrayDeque0);
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(1, threadPoolExecutor_DiscardOldestPolicy0);
      Callable<EvictibleEntry<Integer, Integer>> callable0 = (Callable<EvictibleEntry<Integer, Integer>>) mock(Callable.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(callable0).call();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      ScheduledFuture<EvictibleEntry<Integer, Integer>> scheduledFuture0 = scheduledThreadPoolExecutor0.schedule(callable0, (long) 1, timeUnit0);
      concurrentMapWithTimedEvictionDecorator0.replace((Delayed) scheduledFuture0, (Delayed) scheduledFuture0, (Delayed) scheduledFuture0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap1, regularTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator1.size();
      Integer integer0 = null;
      concurrentMapWithTimedEvictionDecorator1.replace((Delayed) scheduledFuture0, (Integer) 1, (Integer) null);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      TimeUnit timeUnit1 = TimeUnit.MINUTES;
      RegularTaskEvictionScheduler<Integer, Integer> regularTaskEvictionScheduler1 = null;
      try {
        regularTaskEvictionScheduler1 = new RegularTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0, 0L, timeUnit1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Delay cannot be less than or equal to zero
         //
         verifyException("com.stoyanr.evictor.scheduler.RegularTaskEvictionScheduler", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap1);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, regularTaskEvictionScheduler0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      RegularTaskEvictionScheduler<Delayed, Delayed> regularTaskEvictionScheduler1 = new RegularTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap2, regularTaskEvictionScheduler1);
      concurrentMapWithTimedEvictionDecorator2.containsKey(integer0);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Delayed>> concurrentSkipListMap3 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Delayed>>();
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Delayed>> concurrentSkipListMap4 = concurrentSkipListMap3.clone();
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      RegularTaskEvictionScheduler<Integer, Delayed> regularTaskEvictionScheduler2 = new RegularTaskEvictionScheduler<Integer, Delayed>(1000000L, timeUnit0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Delayed> concurrentMapWithTimedEvictionDecorator3 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Delayed>(concurrentSkipListMap4, regularTaskEvictionScheduler2);
      BiConsumer<Integer, Delayed> biConsumer0 = (BiConsumer<Integer, Delayed>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      concurrentMapWithTimedEvictionDecorator3.forEach(biConsumer0);
      Set<Map.Entry<Integer, Delayed>> set0 = (Set<Map.Entry<Integer, Delayed>>)concurrentMapWithTimedEvictionDecorator3.entrySet();
      assertTrue(set0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      doReturn(0).when(comparator0).compare(anyInt() , anyInt());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      Integer integer0 = new Integer((-1));
      Integer integer1 = new Integer((-1));
      concurrentSkipListMap0.subMap(integer0, integer1);
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap2);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer2 = new Integer(1304);
      Integer integer3 = new Integer(0);
      BiConsumer<Integer, EvictibleEntry<Integer, Integer>> biConsumer0 = (BiConsumer<Integer, EvictibleEntry<Integer, Integer>>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      concurrentMapWithTimedEvictionDecorator0.forEach(biConsumer0);
      Integer integer4 = concurrentMapWithTimedEvictionDecorator1.replace(integer3, (Integer) 1, 380L);
      assertNull(integer4);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap1);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(1);
      Integer integer1 = new Integer(0);
      Integer integer2 = new Integer(0);
      Integer integer3 = new Integer(0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer4 = new Integer(1);
      Integer integer5 = new Integer(1);
      concurrentMapWithTimedEvictionDecorator2.replace(integer4, integer5, 1L);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap2 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator3 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap2, regularTaskEvictionScheduler0);
      Integer integer6 = new Integer(1);
      boolean boolean0 = concurrentMapWithTimedEvictionDecorator3.containsValue(integer6);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>> concurrentHashMap0 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ThreadPoolExecutor.DiscardPolicy threadPoolExecutor_DiscardPolicy0 = new ThreadPoolExecutor.DiscardPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0, threadFactory0, threadPoolExecutor_DiscardPolicy0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Delayed>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Delayed>>();
      Integer integer0 = new Integer(0);
      Integer integer1 = new Integer(0);
      Integer integer2 = new Integer(0);
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap0, delayedTaskEvictionScheduler1);
      concurrentMapWithTimedEvictionDecorator0.replace((Integer) 1, (Integer) 1, (long) 0);
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      RegularTaskEvictionScheduler<Delayed, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Delayed, Integer>();
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler2 = new DelayedTaskEvictionScheduler<Delayed, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentSkipListMap1, regularTaskEvictionScheduler0);
      Integer integer3 = new Integer(1);
      boolean boolean0 = concurrentMapWithTimedEvictionDecorator1.containsValue(integer1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, Integer>>();
      int int0 = 0;
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.entrySet();
      ConcurrentHashMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Map.Entry<Integer, Delayed>, EvictibleEntry<Map.Entry<Integer, Delayed>, Integer>>();
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Map.Entry<Integer, Delayed>, Integer>(2684L, timeUnit0);
      ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Map.Entry<Integer, Delayed>, Integer>(concurrentHashMap0, regularTaskEvictionScheduler0);
      TreeMap<Integer, Delayed> treeMap0 = new TreeMap<Integer, Delayed>();
      treeMap0.floorEntry((Integer) 1);
      EvictibleEntry<Map.Entry<Integer, Delayed>, Integer> evictibleEntry0 = null;
      try {
        evictibleEntry0 = new EvictibleEntry<Map.Entry<Integer, Delayed>, Integer>(concurrentMapWithTimedEvictionDecorator1, (Map.Entry<Integer, Delayed>) null, (Integer) 1, (-1L));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Eviction time cannot be less than zero
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      DelayedTaskEvictionScheduler<Delayed, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Integer>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      Integer integer0 = new Integer(1);
      EvictibleEntry<Integer, Integer> evictibleEntry0 = new EvictibleEntry<Integer, Integer>((ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>) null, (Integer) 1, integer0, 1);
      Integer integer1 = concurrentMapWithTimedEvictionDecorator0.get(evictibleEntry0);
      assertNull(integer1);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Comparator<Integer> comparator0 = (Comparator<Integer>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(comparator0);
      ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Long, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap1);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>(navigableMapEvictionQueue0, scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      DelayedTaskEvictionScheduler<Integer, Integer> delayedTaskEvictionScheduler1 = new DelayedTaskEvictionScheduler<Integer, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, delayedTaskEvictionScheduler1);
      Integer integer0 = new Integer(0);
      Integer integer1 = new Integer(0);
      Integer integer2 = concurrentMapWithTimedEvictionDecorator1.replace(integer0, integer1, 2299L);
      assertNull(integer2);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.clear();
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      concurrentMapWithTimedEvictionDecorator0.size();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      Integer integer0 = new Integer(0);
      boolean boolean0 = concurrentMapWithTimedEvictionDecorator0.containsKey(integer0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, Delayed>>();
      ThreadPoolExecutor.DiscardOldestPolicy threadPoolExecutor_DiscardOldestPolicy0 = new ThreadPoolExecutor.DiscardOldestPolicy();
      Thread thread0 = MockThread.currentThread();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(5249);
      threadPoolExecutor_DiscardOldestPolicy0.rejectedExecution(thread0, scheduledThreadPoolExecutor0);
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor1 = new ScheduledThreadPoolExecutor(5249, threadPoolExecutor_DiscardOldestPolicy0);
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      RegularTaskEvictionScheduler<Integer, Delayed> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, Delayed>(scheduledThreadPoolExecutor1, 5249, timeUnit0);
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      scheduledThreadPoolExecutor1.setThreadFactory(threadFactory0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Delayed>(concurrentHashMap0, regularTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.size();
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>>>();
      NavigableMapEvictionQueue<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>>();
      DelayedTaskEvictionScheduler<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>>(navigableMapEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, EvictibleEntry<Delayed, EvictibleEntry<Integer, Delayed>>>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      SingleThreadEvictionScheduler<Delayed, EvictibleEntry<Integer, Delayed>> singleThreadEvictionScheduler0 = new SingleThreadEvictionScheduler<Delayed, EvictibleEntry<Integer, Delayed>>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, EvictibleEntry<Integer, Delayed>> concurrentMapWithTimedEvictionDecorator2 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, EvictibleEntry<Integer, Delayed>>(concurrentMapWithTimedEvictionDecorator1, singleThreadEvictionScheduler0);
      Integer integer0 = new Integer(0);
      DelayQueue<Delayed> delayQueue0 = new DelayQueue<Delayed>();
      delayQueue0.poll();
      EvictibleEntry<Integer, Delayed> evictibleEntry0 = null;
      try {
        evictibleEntry0 = new EvictibleEntry<Integer, Delayed>(concurrentMapWithTimedEvictionDecorator0, integer0, (Delayed) null, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Value cannot be null
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>> concurrentHashMap0 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Delayed>>>();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ThreadPoolExecutor.DiscardPolicy threadPoolExecutor_DiscardPolicy0 = new ThreadPoolExecutor.DiscardPolicy();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0, threadFactory0, threadPoolExecutor_DiscardPolicy0);
      DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Delayed>> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Integer, EvictibleEntry<Integer, Delayed>>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Delayed>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Delayed>>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      Integer integer0 = new Integer(0);
      concurrentMapWithTimedEvictionDecorator0.containsKey(integer0);
      ConcurrentHashMap<EvictibleEntry<Integer, Integer>, EvictibleEntry<EvictibleEntry<Integer, Integer>, Integer>> concurrentHashMap1 = null;
      try {
        concurrentHashMap1 = new ConcurrentHashMap<EvictibleEntry<Integer, Integer>, EvictibleEntry<EvictibleEntry<Integer, Integer>, Integer>>(1, 0.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.ConcurrentHashMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.clear();
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      assertTrue(concurrentMapWithTimedEvictionDecorator1.equals((Object)concurrentMapWithTimedEvictionDecorator0));
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentSkipListMap0, delayedTaskEvictionScheduler0);
      concurrentMapWithTimedEvictionDecorator0.clear();
      ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>> concurrentSkipListMap1 = new ConcurrentSkipListMap<Delayed, EvictibleEntry<Delayed, Integer>>();
      PriorityEvictionQueue<Delayed, Integer> priorityEvictionQueue0 = null;
      try {
        priorityEvictionQueue0 = new PriorityEvictionQueue<Delayed, Integer>(0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.PriorityBlockingQueue", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      ConcurrentHashMap<Integer, EvictibleEntry<Integer, Integer>> concurrentHashMap0 = new ConcurrentHashMap<Integer, EvictibleEntry<Integer, Integer>>();
      NavigableMapEvictionQueue<Integer, Integer> navigableMapEvictionQueue0 = new NavigableMapEvictionQueue<Integer, Integer>();
      RegularTaskEvictionScheduler<Integer, Integer> regularTaskEvictionScheduler0 = new RegularTaskEvictionScheduler<Integer, Integer>(navigableMapEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentHashMap0, regularTaskEvictionScheduler0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentHashMap0, regularTaskEvictionScheduler0);
      Function<Integer, Integer> function0 = Function.identity();
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator1.computeIfAbsent((Integer) null, function0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = null;
      try {
        concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>((ConcurrentMap<Delayed, EvictibleEntry<Delayed, Delayed>>) null, delayedTaskEvictionScheduler0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Delegate to be used cannot be null
         //
         verifyException("com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>();
      ExecutorServiceEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Integer, EvictibleEntry<Integer, Integer>>();
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, Integer>>(concurrentSkipListMap0, executorServiceEvictionScheduler0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, Integer> concurrentMapWithTimedEvictionDecorator1 = null;
      try {
        concurrentMapWithTimedEvictionDecorator1 = new ConcurrentMapWithTimedEvictionDecorator<Integer, Integer>(concurrentMapWithTimedEvictionDecorator0, (EvictionScheduler<Integer, Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Delegate to be used cannot be null
         //
         verifyException("com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = null;
      try {
        concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentHashMap0, (EvictionScheduler<Delayed, Delayed>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Delegate to be used cannot be null
         //
         verifyException("com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      ConcurrentHashMap<EvictibleEntry<Integer, Integer>, EvictibleEntry<EvictibleEntry<Integer, Integer>, Integer>> concurrentHashMap0 = new ConcurrentHashMap<EvictibleEntry<Integer, Integer>, EvictibleEntry<EvictibleEntry<Integer, Integer>, Integer>>();
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(0);
      DelayedTaskEvictionScheduler<EvictibleEntry<Integer, Integer>, Integer> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<EvictibleEntry<Integer, Integer>, Integer>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<EvictibleEntry<Integer, Integer>, Integer> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<EvictibleEntry<Integer, Integer>, Integer>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      // Undeclared exception!
      try { 
        concurrentMapWithTimedEvictionDecorator0.putIfAbsent((EvictibleEntry<Integer, Integer>) null, (Integer) 1, (-295L));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Eviction time cannot be less than zero
         //
         verifyException("com.stoyanr.evictor.map.EvictibleEntry", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      doReturn((Thread) null).when(threadFactory0).newThread(any(java.lang.Runnable.class));
      ScheduledThreadPoolExecutor scheduledThreadPoolExecutor0 = new ScheduledThreadPoolExecutor(4464, threadFactory0);
      ExecutorServiceEvictionScheduler<Delayed, Delayed> executorServiceEvictionScheduler0 = new ExecutorServiceEvictionScheduler<Delayed, Delayed>(scheduledThreadPoolExecutor0);
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentHashMap0, executorServiceEvictionScheduler0);
      MockThread mockThread0 = new MockThread();
      TimeUnit timeUnit0 = TimeUnit.DAYS;
      ScheduledFuture<?> scheduledFuture0 = scheduledThreadPoolExecutor0.scheduleWithFixedDelay(mockThread0, 1, 1, timeUnit0);
      Delayed delayed0 = concurrentMapWithTimedEvictionDecorator0.replace((Delayed) scheduledFuture0, (Delayed) scheduledFuture0, 0L);
      assertNull(delayed0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = null;
      try {
        concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>((ConcurrentMap<Delayed, EvictibleEntry<Delayed, Delayed>>) null, (EvictionScheduler<Delayed, Delayed>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Delegate to be used cannot be null
         //
         verifyException("com.stoyanr.evictor.map.ConcurrentMapWithTimedEvictionDecorator", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>> concurrentHashMap0 = new ConcurrentHashMap<Delayed, EvictibleEntry<Delayed, Delayed>>();
      DelayedTaskEvictionScheduler<Delayed, Delayed> delayedTaskEvictionScheduler0 = new DelayedTaskEvictionScheduler<Delayed, Delayed>();
      ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Delayed, Delayed>(concurrentHashMap0, delayedTaskEvictionScheduler0);
      Integer integer0 = new Integer(1);
      Integer integer1 = new Integer(1);
      boolean boolean0 = concurrentMapWithTimedEvictionDecorator0.containsKey(integer1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>> concurrentSkipListMap0 = new ConcurrentSkipListMap<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>>();
      PriorityBlockingQueue<EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>> priorityBlockingQueue0 = new PriorityBlockingQueue<EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>>();
      PriorityEvictionQueue<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> priorityEvictionQueue0 = new PriorityEvictionQueue<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(priorityBlockingQueue0);
      SingleThreadEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> singleThreadEvictionScheduler0 = new SingleThreadEvictionScheduler<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(priorityEvictionQueue0);
      ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> concurrentMapWithTimedEvictionDecorator0 = new ConcurrentMapWithTimedEvictionDecorator<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(concurrentSkipListMap0, singleThreadEvictionScheduler0);
      int int0 = (-828);
      ThreadFactory threadFactory0 = mock(ThreadFactory.class, new ViolatedAssumptionAnswer());
      ThreadPoolExecutor.CallerRunsPolicy threadPoolExecutor_CallerRunsPolicy0 = new ThreadPoolExecutor.CallerRunsPolicy();
      Integer integer0 = new Integer((-828));
      EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>> evictibleEntry0 = (EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>) mock(EvictibleEntry.class, new ViolatedAssumptionAnswer());
      EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>> evictibleEntry1 = new EvictibleEntry<Integer, EvictibleEntry<Integer, EvictibleEntry<Integer, Integer>>>(concurrentMapWithTimedEvictionDecorator0, integer0, evictibleEntry0, 1L);
      PriorityEvictionQueue<Integer, EvictibleEntry<Integer, Integer>> priorityEvictionQueue1 = null;
      try {
        priorityEvictionQueue1 = new PriorityEvictionQueue<Integer, EvictibleEntry<Integer, Integer>>((-1));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.concurrent.PriorityBlockingQueue", e);
      }
  }
}
