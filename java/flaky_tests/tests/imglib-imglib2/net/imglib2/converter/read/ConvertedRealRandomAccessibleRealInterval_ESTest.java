/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 05 18:08:09 GMT 2022
 */

package net.imglib2.converter.read;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.function.Supplier;
import net.imglib2.FinalRealInterval;
import net.imglib2.RealInterval;
import net.imglib2.RealRandomAccess;
import net.imglib2.RealRandomAccessibleRealInterval;
import net.imglib2.converter.ChannelARGBConverter;
import net.imglib2.converter.ComplexPowerGLogFloatConverter;
import net.imglib2.converter.CompositeChannelConverter;
import net.imglib2.converter.Converter;
import net.imglib2.converter.read.ConvertedRealRandomAccess;
import net.imglib2.converter.read.ConvertedRealRandomAccessibleRealInterval;
import net.imglib2.type.numeric.integer.UnsignedByteType;
import net.imglib2.view.composite.AbstractComposite;
import net.imglib2.view.composite.RealComposite;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ConvertedRealRandomAccessibleRealInterval_ESTest extends ConvertedRealRandomAccessibleRealInterval_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>> realRandomAccessibleRealInterval0 = (RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>>) mock(RealRandomAccessibleRealInterval.class, new ViolatedAssumptionAnswer());
      doReturn((RealRandomAccess) null).when(realRandomAccessibleRealInterval0).realRandomAccess(any(net.imglib2.RealInterval.class));
      CompositeChannelConverter<UnsignedByteType, RealComposite<UnsignedByteType>> compositeChannelConverter0 = new CompositeChannelConverter<UnsignedByteType, RealComposite<UnsignedByteType>>(479L);
      Supplier<UnsignedByteType> supplier0 = (Supplier<UnsignedByteType>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, UnsignedByteType> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, UnsignedByteType>(realRandomAccessibleRealInterval0, compositeChannelConverter0, supplier0);
      double[] doubleArray0 = new double[9];
      FinalRealInterval finalRealInterval0 = new FinalRealInterval(doubleArray0, doubleArray0, false);
      ConvertedRealRandomAccess<RealComposite<UnsignedByteType>, UnsignedByteType> convertedRealRandomAccess0 = convertedRealRandomAccessibleRealInterval0.realRandomAccess((RealInterval) finalRealInterval0);
      assertNotNull(convertedRealRandomAccess0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Converter<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType> converter0 = (Converter<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType>) mock(Converter.class, new ViolatedAssumptionAnswer());
      UnsignedByteType unsignedByteType0 = new UnsignedByteType();
      Supplier<UnsignedByteType> supplier0 = (Supplier<UnsignedByteType>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType>((RealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, converter0, supplier0);
      UnsignedByteType unsignedByteType1 = convertedRealRandomAccessibleRealInterval0.getDestinationType();
      assertEquals(0.0, unsignedByteType1.getMinValue(), 0.01);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>>((RealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, (Converter<? super ComplexPowerGLogFloatConverter<UnsignedByteType>, ? super ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, (Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>>) null);
      Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = convertedRealRandomAccessibleRealInterval0.getDestinationSupplier();
      assertNull(supplier0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>> realRandomAccessibleRealInterval0 = (RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>>) mock(RealRandomAccessibleRealInterval.class, new ViolatedAssumptionAnswer());
      Converter<RealComposite<UnsignedByteType>, ChannelARGBConverter> converter0 = (Converter<RealComposite<UnsignedByteType>, ChannelARGBConverter>) mock(Converter.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(converter0).toString();
      ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ChannelARGBConverter> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ChannelARGBConverter>(realRandomAccessibleRealInterval0, converter0, (Supplier<? extends ChannelARGBConverter>) null);
      Converter<? super RealComposite<UnsignedByteType>, ? super ChannelARGBConverter> converter1 = convertedRealRandomAccessibleRealInterval0.getConverter();
      assertNotNull(converter1);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Supplier<UnsignedByteType> supplier0 = (Supplier<UnsignedByteType>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType>((RealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, (Converter<? super ComplexPowerGLogFloatConverter<UnsignedByteType>, ? super UnsignedByteType>) null, supplier0);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessibleRealInterval0.realRandomAccess();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessibleRealInterval", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Converter<AbstractComposite<ChannelARGBConverter>, ComplexPowerGLogFloatConverter<UnsignedByteType>> converter0 = (Converter<AbstractComposite<ChannelARGBConverter>, ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Converter.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessibleRealInterval<AbstractComposite<ChannelARGBConverter>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<AbstractComposite<ChannelARGBConverter>, ComplexPowerGLogFloatConverter<UnsignedByteType>>((RealRandomAccessibleRealInterval<AbstractComposite<ChannelARGBConverter>>) null, converter0, (Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>>) null);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessibleRealInterval0.getDestinationType();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessibleRealInterval", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>>((RealRandomAccessibleRealInterval<ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, (Converter<? super ComplexPowerGLogFloatConverter<UnsignedByteType>, ? super ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, (Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>>) null);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessibleRealInterval0.realRandomAccess((RealInterval) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessibleRealInterval", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Converter<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>> converter0 = (Converter<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessibleRealInterval<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>>((RealRandomAccessibleRealInterval<UnsignedByteType>) null, converter0, supplier0);
      Supplier<Converter<? super UnsignedByteType, ? super ComplexPowerGLogFloatConverter<UnsignedByteType>>> supplier1 = convertedRealRandomAccessibleRealInterval0.getConverterSupplier();
      assertNotNull(supplier1);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>> realRandomAccessibleRealInterval0 = (RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>>) mock(RealRandomAccessibleRealInterval.class, new ViolatedAssumptionAnswer());
      Converter<Object, Object> converter0 = (Converter<Object, Object>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>>(realRandomAccessibleRealInterval0, converter0, supplier0);
      ComplexPowerGLogFloatConverter<UnsignedByteType> complexPowerGLogFloatConverter0 = convertedRealRandomAccessibleRealInterval0.getDestinationType();
      assertNull(complexPowerGLogFloatConverter0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessibleRealInterval<ChannelARGBConverter, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<ChannelARGBConverter, ComplexPowerGLogFloatConverter<UnsignedByteType>>((RealRandomAccessibleRealInterval<ChannelARGBConverter>) null, (Converter<? super ChannelARGBConverter, ? super ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, supplier0);
      Converter<? super ChannelARGBConverter, ? super ComplexPowerGLogFloatConverter<UnsignedByteType>> converter0 = convertedRealRandomAccessibleRealInterval0.getConverter();
      assertNull(converter0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>> realRandomAccessibleRealInterval0 = (RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>>) mock(RealRandomAccessibleRealInterval.class, new ViolatedAssumptionAnswer());
      doReturn((RealRandomAccess) null).when(realRandomAccessibleRealInterval0).realRandomAccess();
      Converter<Object, Object> converter0 = (Converter<Object, Object>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>>(realRandomAccessibleRealInterval0, converter0, supplier0);
      ConvertedRealRandomAccess<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccess0 = convertedRealRandomAccessibleRealInterval0.realRandomAccess();
      assertNotNull(convertedRealRandomAccess0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>> realRandomAccessibleRealInterval0 = (RealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>>) mock(RealRandomAccessibleRealInterval.class, new ViolatedAssumptionAnswer());
      Converter<Object, Object> converter0 = (Converter<Object, Object>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(supplier0).toString();
      ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessibleRealInterval0 = new ConvertedRealRandomAccessibleRealInterval<RealComposite<UnsignedByteType>, ComplexPowerGLogFloatConverter<UnsignedByteType>>(realRandomAccessibleRealInterval0, converter0, supplier0);
      Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier1 = convertedRealRandomAccessibleRealInterval0.getDestinationSupplier();
      assertNotNull(supplier1);
  }
}
