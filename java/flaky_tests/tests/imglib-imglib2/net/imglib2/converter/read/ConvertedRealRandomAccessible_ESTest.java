/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 05 17:57:15 GMT 2022
 */

package net.imglib2.converter.read;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.function.BiConsumer;
import java.util.function.Supplier;
import net.imglib2.FinalRealInterval;
import net.imglib2.RealInterval;
import net.imglib2.RealLocalizable;
import net.imglib2.RealRandomAccess;
import net.imglib2.RealRandomAccessible;
import net.imglib2.converter.ChannelARGBConverter;
import net.imglib2.converter.ComplexPowerGLogFloatConverter;
import net.imglib2.converter.Converter;
import net.imglib2.converter.TypeIdentity;
import net.imglib2.converter.read.ConvertedRealRandomAccess;
import net.imglib2.converter.read.ConvertedRealRandomAccessible;
import net.imglib2.interpolation.Interpolant;
import net.imglib2.interpolation.InterpolatorFactory;
import net.imglib2.position.FunctionRealRandomAccessible;
import net.imglib2.type.numeric.complex.ComplexFloatType;
import net.imglib2.type.numeric.integer.UnsignedByteType;
import net.imglib2.type.volatiles.VolatileByteType;
import net.imglib2.type.volatiles.VolatileShortType;
import net.imglib2.view.composite.Composite;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class ConvertedRealRandomAccessible_ESTest extends ConvertedRealRandomAccessible_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test0()  throws Throwable  {
      ChannelARGBConverter.Channel channelARGBConverter_Channel0 = ChannelARGBConverter.Channel.A;
      ChannelARGBConverter channelARGBConverter0 = new ChannelARGBConverter(channelARGBConverter_Channel0);
      InterpolatorFactory<VolatileShortType, ChannelARGBConverter> interpolatorFactory0 = (InterpolatorFactory<VolatileShortType, ChannelARGBConverter>) mock(InterpolatorFactory.class, new ViolatedAssumptionAnswer());
      doReturn((RealRandomAccess) null).when(interpolatorFactory0).create(any(net.imglib2.converter.ChannelARGBConverter.class));
      Interpolant<VolatileShortType, ChannelARGBConverter> interpolant0 = new Interpolant<VolatileShortType, ChannelARGBConverter>(channelARGBConverter0, interpolatorFactory0, (-279));
      TypeIdentity<VolatileShortType> typeIdentity0 = new TypeIdentity<VolatileShortType>();
      Supplier<VolatileShortType> supplier0 = (Supplier<VolatileShortType>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessible<VolatileShortType, VolatileShortType> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<VolatileShortType, VolatileShortType>(interpolant0, typeIdentity0, supplier0);
      ConvertedRealRandomAccess<VolatileShortType, VolatileShortType> convertedRealRandomAccess0 = convertedRealRandomAccessible0.realRandomAccess();
      assertNotNull(convertedRealRandomAccess0);
  }

  @Test(timeout = 4000)
  public void test1()  throws Throwable  {
      ComplexPowerGLogFloatConverter<VolatileByteType> complexPowerGLogFloatConverter0 = new ComplexPowerGLogFloatConverter<VolatileByteType>();
      InterpolatorFactory<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>> interpolatorFactory0 = (InterpolatorFactory<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>>) mock(InterpolatorFactory.class, new ViolatedAssumptionAnswer());
      Interpolant<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>> interpolant0 = new Interpolant<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>>(complexPowerGLogFloatConverter0, interpolatorFactory0, 87);
      Converter<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter> converter0 = (Converter<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ChannelARGBConverter> supplier0 = (Supplier<ChannelARGBConverter>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessible<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter>(interpolant0, converter0, supplier0);
      ChannelARGBConverter channelARGBConverter0 = convertedRealRandomAccessible0.getDestinationType();
      assertNull(channelARGBConverter0);
  }

  @Test(timeout = 4000)
  public void test2()  throws Throwable  {
      Converter<ComplexPowerGLogFloatConverter<ComplexFloatType>, ChannelARGBConverter> converter0 = (Converter<ComplexPowerGLogFloatConverter<ComplexFloatType>, ChannelARGBConverter>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ChannelARGBConverter> supplier0 = (Supplier<ChannelARGBConverter>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessible<ComplexPowerGLogFloatConverter<ComplexFloatType>, ChannelARGBConverter> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<ComplexPowerGLogFloatConverter<ComplexFloatType>, ChannelARGBConverter>((RealRandomAccessible<ComplexPowerGLogFloatConverter<ComplexFloatType>>) null, converter0, supplier0);
      double[] doubleArray0 = new double[8];
      FinalRealInterval finalRealInterval0 = FinalRealInterval.wrap(doubleArray0, doubleArray0);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessible0.realRandomAccess((RealInterval) finalRealInterval0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessible", e);
      }
  }

  @Test(timeout = 4000)
  public void test3()  throws Throwable  {
      Converter<Object, Object> converter0 = (Converter<Object, Object>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ChannelARGBConverter> supplier0 = (Supplier<ChannelARGBConverter>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessible<Composite<Object>, ChannelARGBConverter> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<Composite<Object>, ChannelARGBConverter>((RealRandomAccessible<Composite<Object>>) null, converter0, supplier0);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessible0.realRandomAccess();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessible", e);
      }
  }

  @Test(timeout = 4000)
  public void test4()  throws Throwable  {
      Converter<ChannelARGBConverter, ChannelARGBConverter> converter0 = (Converter<ChannelARGBConverter, ChannelARGBConverter>) mock(Converter.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(converter0).toString();
      Supplier<ChannelARGBConverter> supplier0 = (Supplier<ChannelARGBConverter>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>((RealRandomAccessible<ChannelARGBConverter>) null, converter0, supplier0);
      Converter<? super ChannelARGBConverter, ? super ChannelARGBConverter> converter1 = convertedRealRandomAccessible0.getConverter();
      assertNotNull(converter1);
  }

  @Test(timeout = 4000)
  public void test5()  throws Throwable  {
      ComplexPowerGLogFloatConverter<VolatileByteType> complexPowerGLogFloatConverter0 = new ComplexPowerGLogFloatConverter<VolatileByteType>();
      InterpolatorFactory<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>> interpolatorFactory0 = (InterpolatorFactory<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>>) mock(InterpolatorFactory.class, new ViolatedAssumptionAnswer());
      doReturn((RealRandomAccess) null).when(interpolatorFactory0).create(any(net.imglib2.converter.ComplexPowerGLogFloatConverter.class) , any(net.imglib2.RealInterval.class));
      Interpolant<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>> interpolant0 = new Interpolant<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ComplexPowerGLogFloatConverter<VolatileByteType>>(complexPowerGLogFloatConverter0, interpolatorFactory0, 87);
      Converter<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter> converter0 = (Converter<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ChannelARGBConverter> supplier0 = (Supplier<ChannelARGBConverter>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      ConvertedRealRandomAccessible<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter>(interpolant0, converter0, supplier0);
      double[] doubleArray0 = new double[5];
      FinalRealInterval finalRealInterval0 = new FinalRealInterval(doubleArray0, doubleArray0, true);
      ConvertedRealRandomAccess<ConvertedRealRandomAccessible<ChannelARGBConverter, ChannelARGBConverter>, ChannelARGBConverter> convertedRealRandomAccess0 = convertedRealRandomAccessible0.realRandomAccess((RealInterval) finalRealInterval0);
      assertNotNull(convertedRealRandomAccess0);
  }

  @Test(timeout = 4000)
  public void test6()  throws Throwable  {
      Converter<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType> converter0 = (Converter<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<UnsignedByteType> supplier0 = (Supplier<UnsignedByteType>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessible<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<ComplexPowerGLogFloatConverter<UnsignedByteType>, UnsignedByteType>((RealRandomAccessible<ComplexPowerGLogFloatConverter<UnsignedByteType>>) null, converter0, supplier0);
      Supplier<Converter<? super ComplexPowerGLogFloatConverter<UnsignedByteType>, ? super UnsignedByteType>> supplier1 = convertedRealRandomAccessible0.getConverterSupplier();
      assertNotNull(supplier1);
  }

  @Test(timeout = 4000)
  public void test7()  throws Throwable  {
      BiConsumer<RealLocalizable, Object> biConsumer0 = (BiConsumer<RealLocalizable, Object>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      FunctionRealRandomAccessible<Object> functionRealRandomAccessible0 = new FunctionRealRandomAccessible<Object>((-2168), biConsumer0, (Supplier<Object>) null);
      Converter<Object, Object> converter0 = (Converter<Object, Object>) mock(Converter.class, new ViolatedAssumptionAnswer());
      ConvertedRealRandomAccessible<Object, Object> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<Object, Object>(functionRealRandomAccessible0, converter0, (Supplier<?>) null);
      // Undeclared exception!
      try { 
        convertedRealRandomAccessible0.getDestinationType();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("net.imglib2.converter.read.ConvertedRealRandomAccessible", e);
      }
  }

  @Test(timeout = 4000)
  public void test8()  throws Throwable  {
      BiConsumer<RealLocalizable, UnsignedByteType> biConsumer0 = (BiConsumer<RealLocalizable, UnsignedByteType>) mock(BiConsumer.class, new ViolatedAssumptionAnswer());
      FunctionRealRandomAccessible<UnsignedByteType> functionRealRandomAccessible0 = new FunctionRealRandomAccessible<UnsignedByteType>(1572, biConsumer0, (Supplier<UnsignedByteType>) null);
      Converter<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>> converter0 = (Converter<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Converter.class, new ViolatedAssumptionAnswer());
      Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier0 = (Supplier<ComplexPowerGLogFloatConverter<UnsignedByteType>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(supplier0).toString();
      ConvertedRealRandomAccessible<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>> convertedRealRandomAccessible0 = new ConvertedRealRandomAccessible<UnsignedByteType, ComplexPowerGLogFloatConverter<UnsignedByteType>>(functionRealRandomAccessible0, converter0, supplier0);
      Supplier<? extends ComplexPowerGLogFloatConverter<UnsignedByteType>> supplier1 = convertedRealRandomAccessible0.getDestinationSupplier();
      assertNotNull(supplier1);
  }
}
