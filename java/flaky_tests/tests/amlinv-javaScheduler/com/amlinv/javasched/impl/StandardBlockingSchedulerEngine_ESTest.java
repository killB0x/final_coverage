/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 05 08:29:52 GMT 2022
 */

package com.amlinv.javasched.impl;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.amlinv.javasched.Step;
import com.amlinv.javasched.engine.ProcessStepExecutionListener;
import com.amlinv.javasched.engine.ProcessStepExecutionSlip;
import com.amlinv.javasched.impl.StandardBlockingSchedulerEngine;
import java.util.concurrent.TimeUnit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.junit.runner.RunWith;
import org.slf4j.Logger;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class StandardBlockingSchedulerEngine_ESTest extends StandardBlockingSchedulerEngine_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      
      standardBlockingSchedulerEngine0.getNumStartedThread();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine0.hooks = standardBlockingSchedulerEngine_ConcurrencyValidationHooks0;
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1L);
      standardBlockingSchedulerEngine0.grabNextStep(573L);
      ProcessStepExecutionListener processStepExecutionListener0 = mock(ProcessStepExecutionListener.class, new ViolatedAssumptionAnswer());
      ProcessStepExecutionSlip processStepExecutionSlip0 = new ProcessStepExecutionSlip((Step) null, processStepExecutionListener0);
      Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = MockThread.getDefaultUncaughtExceptionHandler();
      MockThread.setDefaultUncaughtExceptionHandler(thread_UncaughtExceptionHandler0);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep(processStepExecutionSlip0);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ProcessorThread0.getStackTrace();
      standardBlockingSchedulerEngine0.getNumStartedThread();
      standardBlockingSchedulerEngine0.grabNextStep(573L);
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      standardBlockingSchedulerEngine0.start();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine0.getMaximumProcessors();
      standardBlockingSchedulerEngine0.grabNextStep(1L);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout((StandardBlockingSchedulerEngine.ProcessorThread) null);
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit(processStepExecutionSlip0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // scheduler has already stopped
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread((-1963L));
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      TimeUnit timeUnit0 = TimeUnit.MINUTES;
      standardBlockingSchedulerEngine0.hooks = standardBlockingSchedulerEngine_ConcurrencyValidationHooks0;
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread((-1131));
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime((-1963L), timeUnit0);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine0.hooks.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine0.getMaxThreadIdleTime();
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.onIdleThread((StandardBlockingSchedulerEngine.ProcessorThread) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(246L);
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
      standardBlockingSchedulerEngine0.setMaximumProcessors(1000);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine0.start();
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(246L);
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
      standardBlockingSchedulerEngine0.setMaximumProcessors((-1));
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onTaskAddedToBacklog();
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.start();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // scheduler engine needs a positive number of processors to start
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(246L);
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
      standardBlockingSchedulerEngine0.setMaximumProcessors(1000);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1000, timeUnit0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = MockThread.getDefaultUncaughtExceptionHandler();
      MockThread.setDefaultUncaughtExceptionHandler(thread_UncaughtExceptionHandler0);
      standardBlockingSchedulerEngine_ProcessorThread0.run();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine0.start();
      standardBlockingSchedulerEngine0.getLog();
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.getNumStartedThread();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine0.hooks = standardBlockingSchedulerEngine_ConcurrencyValidationHooks0;
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1L);
      standardBlockingSchedulerEngine0.grabNextStep(573L);
      ProcessStepExecutionListener processStepExecutionListener0 = mock(ProcessStepExecutionListener.class, new ViolatedAssumptionAnswer());
      ProcessStepExecutionSlip processStepExecutionSlip0 = new ProcessStepExecutionSlip((Step) null, processStepExecutionListener0);
      Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = MockThread.getDefaultUncaughtExceptionHandler();
      MockThread.setDefaultUncaughtExceptionHandler(thread_UncaughtExceptionHandler0);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep(processStepExecutionSlip0);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ProcessorThread0.getStackTrace();
      standardBlockingSchedulerEngine0.getNumStartedThread();
      standardBlockingSchedulerEngine0.grabNextStep(573L);
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      standardBlockingSchedulerEngine0.start();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onThreadStartingNewStep();
      standardBlockingSchedulerEngine0.initiateShutdown(true);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1L, timeUnit0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ProcessorThread0.run();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.hooks.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onNewProcessorThread();
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.start();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // already started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.start();
      long long0 = 0L;
      standardBlockingSchedulerEngine0.setMaximumProcessors(1000);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.start();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // already started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(246L);
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
      standardBlockingSchedulerEngine0.setMaximumProcessors(1000);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1000, timeUnit0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = MockThread.getDefaultUncaughtExceptionHandler();
      MockThread.setDefaultUncaughtExceptionHandler(thread_UncaughtExceptionHandler0);
      standardBlockingSchedulerEngine_ProcessorThread0.run();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine0.start();
      standardBlockingSchedulerEngine0.getLog();
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread((-1963L));
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      TimeUnit timeUnit0 = TimeUnit.MINUTES;
      standardBlockingSchedulerEngine0.hooks = standardBlockingSchedulerEngine_ConcurrencyValidationHooks0;
      standardBlockingSchedulerEngine0.setMaximumProcessors((-1131));
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime((-1963L), timeUnit0);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine0.hooks.onNewProcessorThread();
      standardBlockingSchedulerEngine0.getMaximumProcessors();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.getMaximumProcessors();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine0.grabNextStep(1006L);
      standardBlockingSchedulerEngine0.hooks.onIdleThreadRemoved();
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.getNumStartedThread();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine0.setMaximumProcessors((-4222));
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      int int0 = MockThread.NORM_PRIORITY;
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(5);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread((-914L));
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      standardBlockingSchedulerEngine0.initiateShutdown(true);
      standardBlockingSchedulerEngine0.grabNextStep(5);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread1);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit((Step) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // not yet started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      standardBlockingSchedulerEngine0.getNumStartedThread();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(0);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread((-914L));
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      standardBlockingSchedulerEngine0.getMaximumProcessors();
      standardBlockingSchedulerEngine0.grabNextStep(1000);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread2 = standardBlockingSchedulerEngine0.new ProcessorThread(0);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread2);
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit((Step) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // not yet started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine0.hooks = standardBlockingSchedulerEngine_ConcurrencyValidationHooks0;
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(0L);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      MockThread.reset();
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine0.grabNextStep((-2537L));
      standardBlockingSchedulerEngine_ProcessorThread1.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      standardBlockingSchedulerEngine0.getNumStartedThread();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks1.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine_ProcessorThread1.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.setMaximumProcessors(0);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.start();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // scheduler engine needs a positive number of processors to start
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.start();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread((-4138L));
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep((-1320L));
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine1 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine1.setMaximumProcessors((-2027));
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine1.new ProcessorThread(1000);
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine2 = new StandardBlockingSchedulerEngine();
      long long0 = 2739L;
      standardBlockingSchedulerEngine2.grabNextStep(2739L);
      ProcessStepExecutionListener processStepExecutionListener0 = mock(ProcessStepExecutionListener.class, new ViolatedAssumptionAnswer());
      ProcessStepExecutionSlip processStepExecutionSlip0 = new ProcessStepExecutionSlip((Step) null, processStepExecutionListener0);
      standardBlockingSchedulerEngine2.start();
      // Undeclared exception!
      try { 
        processStepExecutionSlip0.execute();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.amlinv.javasched.engine.ProcessStepExecutionSlip", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(3063L);
      long long0 = standardBlockingSchedulerEngine0.getTotalStepsStarted();
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      assertEquals(0L, long0);
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      
      standardBlockingSchedulerEngine0.getMaxThreadIdleTime();
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(0L);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setMaximumProcessors((-2031));
      standardBlockingSchedulerEngine0.setMaximumProcessors(0);
      standardBlockingSchedulerEngine0.getMaxThreadIdleTime();
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine1 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine1.new ProcessorThread(0L);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread1);
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep((-1795L));
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(766L);
      standardBlockingSchedulerEngine0.grabNextStep(766L);
      ProcessStepExecutionListener processStepExecutionListener0 = mock(ProcessStepExecutionListener.class, new ViolatedAssumptionAnswer());
      ProcessStepExecutionSlip processStepExecutionSlip0 = new ProcessStepExecutionSlip((Step) null, processStepExecutionListener0);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep(processStepExecutionSlip0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ProcessorThread0.getContextClassLoader();
      TimeUnit timeUnit0 = TimeUnit.HOURS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(766L, timeUnit0);
      standardBlockingSchedulerEngine0.grabNextStep(0);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      standardBlockingSchedulerEngine0.grabNextStep(0);
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      standardBlockingSchedulerEngine0.grabNextStep((-2543L));
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit((Step) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // not yet started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      
      standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.grabNextStep(246L);
      standardBlockingSchedulerEngine0.getTotalStepsStarted();
      standardBlockingSchedulerEngine0.setMaximumProcessors(1000);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1000, timeUnit0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = MockThread.getDefaultUncaughtExceptionHandler();
      MockThread.setDefaultUncaughtExceptionHandler(thread_UncaughtExceptionHandler0);
      standardBlockingSchedulerEngine_ProcessorThread0.run();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine0.start();
      standardBlockingSchedulerEngine0.submit((Step) null);
      assertEquals(1L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine0.initiateShutdown(true);
      standardBlockingSchedulerEngine0.grabNextStep((-1L));
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit((Step) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // not yet started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      // Undeclared exception!
      try { 
        standardBlockingSchedulerEngine0.submit((Step) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // not yet started
         //
         verifyException("com.amlinv.javasched.impl.StandardBlockingSchedulerEngine", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      TimeUnit timeUnit0 = TimeUnit.MICROSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(85L, timeUnit0);
      standardBlockingSchedulerEngine0.setMaximumProcessors(0);
      assertEquals(0, standardBlockingSchedulerEngine0.getMaximumProcessors());
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onIdleThreadRemoved();
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.initiateShutdown(true);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1947L);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(0L, timeUnit0);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      Logger logger0 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger0);
      TimeUnit timeUnit0 = TimeUnit.NANOSECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1L, timeUnit0);
      int int0 = standardBlockingSchedulerEngine0.getMaximumProcessors();
      assertEquals(1000, int0);
      
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      Logger logger1 = standardBlockingSchedulerEngine0.getLog();
      standardBlockingSchedulerEngine0.setLog(logger1);
      standardBlockingSchedulerEngine0.getMaxThreadIdleTime();
      standardBlockingSchedulerEngine0.initiateShutdown(false);
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.start();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = standardBlockingSchedulerEngine0.hooks;
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      boolean boolean0 = standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      assertFalse(boolean0);
      
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadStartingNewStep();
      int int0 = standardBlockingSchedulerEngine0.getNumStartedThread();
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
      assertEquals(0, int0);
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.initiateShutdown(true);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1947L);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep((Step) null);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      TimeUnit timeUnit0 = TimeUnit.SECONDS;
      standardBlockingSchedulerEngine0.setMaxThreadIdleTime(1947L, timeUnit0);
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onTaskAddedToBacklog();
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.getMaxThreadIdleTime();
      standardBlockingSchedulerEngine0.setMaximumProcessors(523);
      assertEquals(523, standardBlockingSchedulerEngine0.getMaximumProcessors());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      
      standardBlockingSchedulerEngine0.setMaximumProcessors(0);
      assertEquals(0, standardBlockingSchedulerEngine0.getMaximumProcessors());
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadNowIdle();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadStartingNewStep();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks1 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      standardBlockingSchedulerEngine0.setMaximumProcessors(0);
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onNewProcessorThread();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread1 = standardBlockingSchedulerEngine0.new ProcessorThread(0L);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread1);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.onProcessorThreadCompletion(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine0.getMaximumProcessors();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadStartingNewStep();
      standardBlockingSchedulerEngine0.grabNextStep(0L);
      ProcessStepExecutionListener processStepExecutionListener0 = mock(ProcessStepExecutionListener.class, new ViolatedAssumptionAnswer());
      ProcessStepExecutionSlip processStepExecutionSlip0 = new ProcessStepExecutionSlip((Step) null, processStepExecutionListener0);
      standardBlockingSchedulerEngine_ProcessorThread0.setNextStep(processStepExecutionSlip0);
      assertEquals(1, standardBlockingSchedulerEngine0.getNumIdleThread());
      assertEquals(0, standardBlockingSchedulerEngine0.getMaximumProcessors());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(1000);
      standardBlockingSchedulerEngine0.onIdleThread(standardBlockingSchedulerEngine_ProcessorThread0);
      standardBlockingSchedulerEngine0.getNumIdleThread();
      standardBlockingSchedulerEngine0.setMaximumProcessors(1);
      standardBlockingSchedulerEngine0.getLog();
      StandardBlockingSchedulerEngine.ConcurrencyValidationHooks standardBlockingSchedulerEngine_ConcurrencyValidationHooks0 = new StandardBlockingSchedulerEngine.ConcurrencyValidationHooks();
      standardBlockingSchedulerEngine_ConcurrencyValidationHooks0.onThreadStartingNewStep();
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      StandardBlockingSchedulerEngine standardBlockingSchedulerEngine0 = new StandardBlockingSchedulerEngine();
      StandardBlockingSchedulerEngine.ProcessorThread standardBlockingSchedulerEngine_ProcessorThread0 = standardBlockingSchedulerEngine0.new ProcessorThread(0L);
      boolean boolean0 = standardBlockingSchedulerEngine0.oneIdleThreadTimeout(standardBlockingSchedulerEngine_ProcessorThread0);
      assertFalse(boolean0);
      assertEquals(1000, standardBlockingSchedulerEngine0.getMaximumProcessors());
      assertEquals(0L, standardBlockingSchedulerEngine0.getTotalStepsStarted());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumStartedThread());
      assertEquals(0, standardBlockingSchedulerEngine0.getNumIdleThread());
  }
}
